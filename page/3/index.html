<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Zerohuan的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从CSDN迁徙而来">
<meta property="og:type" content="website">
<meta property="og:title" content="Zerohuan的博客">
<meta property="og:url" content="http://blog.zerohuan.com/page/3/index.html">
<meta property="og:site_name" content="Zerohuan的博客">
<meta property="og:description" content="从CSDN迁徙而来">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zerohuan的博客">
<meta name="twitter:description" content="从CSDN迁徙而来">
  
    <link rel="alternative" href="/atom.xml" title="Zerohuan的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zerohuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Talk is cheap, show me the code!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/Java-8集合框架源码/" style="font-size: 14px;">Java 8集合框架源码</a> <a href="/tags/Java基础知识/" style="font-size: 20px;">Java基础知识</a> <a href="/tags/Java并发/" style="font-size: 16px;">Java并发</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 12px;">TCP/IP</a> <a href="/tags/java-web/" style="font-size: 10px;">java web</a> <a href="/tags/思考和求解/" style="font-size: 18px;">思考和求解</a> <a href="/tags/技术更新/" style="font-size: 10px;">技术更新</a> <a href="/tags/杂谈-感悟/" style="font-size: 10px;">杂谈/感悟</a> <a href="/tags/算法和数据结构/" style="font-size: 10px;">算法和数据结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">现南京大学研究生一枚，目前专注于Java Web方向。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Zerohuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Zerohuan</h1>
			</hgroup>
			
			<p class="header-subtitle">Talk is cheap, show me the code!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java基础知识总结（一）——创建和销毁" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/05/Java基础知识总结（一）——创建和销毁/" class="article-date">
  	<time datetime="2015-12-05T10:26:28.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/Java基础知识总结（一）——创建和销毁/">Java基础知识总结（一）——创建和销毁</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="契子">契子</h2><p>明年就要离开学校找工作了，时间过的真快，想一想这几年，做了一些事，也有一些事并没有做好，有很多收获，也有不少遗憾。感性的话在此不宜多说，既然选择了程序员这条道路，也要有把它到做事业的态度。在正式找工作前还有几个月的时间，做东西，尝试新的技术固然很爽，但是基础也很重要，在这短短的几个月的时间里，我将把以前学过的一些知识，Java，数据结构，算法，网络，OS&amp;Linux，J2EE等等知识查缺补漏，好好梳理一遍，不光是为了找工作，也是一种必须要坚持的态度。<br>对于Java知识的整理，基于《Effetive Java》2nd和《Java编程思想》4th辅以JVM和设计模式的相关知识，结合书本上的知识和我的理解进行整理。好了，开始我的一篇——创建和销毁对象。</p>
<h2 id="1-_Java中的构造器：">1. Java中的构造器：</h2><p>构造器是一种特殊类型的方法，它和类同名，没有返回类型，和new关键字结合可以返回对象实例的引用。TIJ中说它是一种静态方法，但是通过字节码我们可以看到其实并没有static关键字，它的行为也和其他静态方法有异（可以访问非静态成员变量），因此这种说法并不完全准确，这里不再深究。</p>
<h3 id="1-1_定义构造器：">1.1 定义构造器：</h3><p>一个类可以有多个构造器，如果你没有定义构造器，Java编译器会在语义分析的阶段，首先添加一个默认构造器。<br>多个构造器可以通过方法重载（overload）实现，注意只有同方法名和不同参数列表可以区别不同的重载版本，返回类型并不能区分。<br>尤其是使用基本类型参数重载时，要注意类型的自动转换如（char—&gt;int，小转大）和窄化转换（强制类型转换，大转小），当然会使用最匹配的类型。</p>
<p>###1.2 this关键字：<br>通过this指针我们可以访问类的实例变量和方法，但最好是在必要的时候（需要返回或使用该实例，内部类访问外部类同名实例变量方法，构造器设置属性等）使用它，否则你不必添加它，编译同样会帮你添加。<br>在存在多个重载版本的构造器时我们可以在构造器内使用this调用其他构造器，可以避免一些重复的代码：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">ConstructorTest</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{
    <span class="keyword">this</span>.a = a;
}

<span class="function"><span class="keyword">public</span> <span class="title">ConstructorTest</span><span class="params">(<span class="keyword">int</span> a, String s)</span> </span>{
    <span class="keyword">this</span>(a);
    <span class="keyword">this</span>.s = s;
}
</code></pre><p>PS：在构造器存在很多参数情况下，重叠构造器是一种选择，但是更好的做法是使用Builder模式，后面会讲到。</p>
<h3 id="1-3_static关键字：">1.3 static关键字：</h3><p>static（静态），static方法和static变量是类方法和类变量，它们不能使用this引用，都放在方法区中，供各个线程共享。static变量初始化和static初始化其，会在类加载（隐式加载或显示加载）后执行一次。</p>
<h2 id="2-_清理，终结对象（finalize）/垃圾回收（CG）：">2. 清理，终结对象（finalize）/垃圾回收（CG）：</h2><p>这涉及到很多内容。Java提供了垃圾回收器，但内存泄漏可能以很隐秘的方式发生（使用引用数组时），同时对于对象中可能使用的一些资源必须在对象不再使用时进行释放（Connection，FileInputStream等）。</p>
<p>首先对象实例作为类的副本存放在Java堆中，在JVM中，一般使用可达性分析进行垃圾回收，也就是说，如果顺着引用追溯的话，“活”的对象应该可以到达CG Root（包括，静态变量，常量引用，栈中的本地变量表以及本地方法栈JNI native方法中的引用）。垃圾回收器会对不可达对象进行标记，在堆的不同区域使用不同的方法进行回收。</p>
<p><strong>标记-清除</strong>：如果只有很少的垃圾的话，它很快，而且简单，但是如果垃圾很多的话，会产生大量的碎片；</p>
<p><strong>复制</strong>：我们可以将需要进行垃圾回收的内存区域分为2个部分，比如A和B，需要CG时，将A的存活的对象直接复制到B（之前为空）中，清空A就可以了，不需要考虑碎片的问题，实际上在JVM（Hotspot）中分成了3个部分，一般比例可以为8：1：1,它们分别命名为eden，surivor1,surivor2，因为据统计Java程序中95%以上的对象很快就不再使用，因此eden很大，surivor可以较小（存活的对象少）。这实际上多用与新生代的垃圾回收。</p>
<p><strong>标记-整理</strong>：有新生代当然也有老年代了，与新生代不同，老年代的对象相对稳定的多，垃圾回收很少，毕竟是经过了minor CG洗礼的不会那么容易挂掉，开个玩笑。标记-整理与清除的不同的地方在，它并不是直接在原位置清除掉，而是将存活的对象移向一端，之后直接就可以一起清除掉挂了的对象。因为我们也说了老年代的对象回收的少，因此移动的也相对较少。这样就不会有大多的碎片了。</p>
<p>因此我们可以看到，JVM多采用分代回收的方式，对于不同的情况分而治之。</p>
<h3 id="释放资源，终结（finalize方法）和垃圾回收有什么关系：">释放资源，终结（finalize方法）和垃圾回收有什么关系：</h3><p>首先，垃圾回收只和内存的使用状况有关，当内存不足（或满足我们设置的条件）时，才会进行CG。<br>finalize()是什么时候执行的呢，对于那些不可达的对象，到它们真正被回收至少需要经过两次标记阶段：<br>（1）首先筛选那些不需要执行finalize方法的对象，没有override finalize方法的和已经执行过finalize方法的对象，那它们就可以“等死”了，对于finalize尚未执行的对象，它们进入F-Queue队列，相当于是“死缓”，还有一线生机；<br>（2）F-Queue队列中的，有一个终结线程专门去调用这些对象的finalize方法（所以finalize方法是一个回调方法），如果在finalize方法有和CG Roots有了关联，OK，它活了，否则“等死”去。</p>
<p>因此，我们看到finalize方法依赖直接于垃圾回收和终结线程，终结线程的优先级很低，这代表它可能很长时间都得不到执行，而垃圾回收也是你无法直接控制的（System.gc和System.runFinalize也是要看JVM脸的），所以finalize和C++中的析构函数并不是一回事；</p>
<p>而对于数据库连接、文件访问句柄等等占用数据库资源和系统资源的对象，我们必须及时的释放/关闭它们。你可以定义一个close方法，在try-finally中保证必要的关闭得到执行，Java中甚至有Closable接口，FileInputStream，Connection等都实现了它们。</p>
<h3 id="Finalize方法到底有什么用：">Finalize方法到底有什么用：</h3><p>（1）你可以在finalize方法检查close方法是否已经执行，这时一种安全敏感的做法，FileInputStream，Connection，Timer都是这样做的。<br>（2）使用JNI时，如果本地对象中要释放敏感资源，需要显示override finalize方法，进行释放。<br>（3）可以在finalize方法中拯救自己。</p>
<p>如果你要使用它，注意在继承体系中，要我们手动维持“终止方法链”，这和构造器方法是一样的道理。<br>总的来说除此以外尽量不要使用finalize方法。</p>
<h2 id="3-_初始化：">3. 初始化：</h2><p>如果想真正弄清楚对象初始化，而不是仅仅记住一些像成员变量的初始值这样的规则，我觉得应该了解一个类在第一个创建对象时是如何从字节码编程的可用的对象的。<br>在第一次使用一个类的时候，无论是显示加载一个类（Class.forName等）还是隐式加载一个类（A.staticVariable，new A()）时，首先要有ClassLoader进行加载：<br>（1）ClassLoader首先通过类名定位到类文件的位置（通过classpath等），将字节码加载到内存，通过准备、字节码验证和resolve等环节将等到一个个Class对象，放到方法区中；<br>（2）在此之后就是类初始化，这是类中的静态变量和静态初始化器将按照位置顺序进行初始化工作，静态变量同样放在方法区中；<br>（3）如果你进行是实例创建的化，接下来的工作首先是在堆上分配内存了，具体的方法可能有指针碰撞和空闲列表；<br>（4）获得了内存空间后，首先全部置零，这也就是为什么类的成员变量会还有初始值的原因，之后如果指定了初始化值，同样这里也是按顺序进行的；<br>（5）最后将执行<init>也就是我们定义使用的构造器来进行我们自定义的初始化过程了，这里就可以获得我们想要的对象实例的引用了。<br>所以在类中，各个部分的初始化顺序是：静态变量，静态初始化器（按位置顺序）——&gt;非静态成员变量（按位置顺序）——&gt;构造器；<br>说完了基本过程，我们来看看在Java中一些具体的类型是怎样进行初始化的。</init></p>
<h3 id="3-1_数组初始化：">3.1 数组初始化：</h3><p>在Java中数组同样也是一种对象，但它并不是由某个类实例化而来，而是有JVM直接创建的，它的父类是Object，因此你可以在数组上使用Object的方法。<br>首先来复习下基本的语法：<br>通过数组初始化器：int[] a = {12,3};<br>通过new动态创建：int[] a = new int[5]; </p>
<p>对于垃圾回收来说，数组同时也是一种特殊的类型，看下面的例子：</p>
<pre><code><span class="keyword">public</span> class MStack {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_SIZE = <span class="number">20</span>;
    <span class="keyword">private</span> <span class="keyword">Object</span>[] elements = <span class="keyword">new</span> <span class="keyword">Object</span>[DEFAULT_SIZE];
    <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">0</span>;

<span class="keyword">public</span> MStack() {
    elements = <span class="keyword">new</span> <span class="keyword">Object</span>[DEFAULT_SIZE];
}

<span class="keyword">public</span> <span class="keyword">void</span> push(<span class="keyword">Object</span> element) {
    ensureCapacity();
    elements[<span class="built_in">size</span>++] = element;
}

<span class="keyword">public</span> <span class="keyword">Object</span> pop() {
    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty stack cannot pop"</span>);
    }
    <span class="keyword">return</span> elements[--<span class="built_in">size</span>];
}

<span class="keyword">public</span> <span class="keyword">void</span> ensureCapacity() {
    <span class="keyword">if</span>(<span class="built_in">size</span> == elements.length) {
        elements = Arrays.copyOf(elements, <span class="number">2</span> * <span class="built_in">size</span> + <span class="number">1</span>);
    }
}
</code></pre><p>}</p>
<p>这是《Effective Java》的一个例子，该例中的Stack在pop是并没有将已经出栈的引用置为null；这些引用是“过期引用”，这些引用虽然没有被使用，但是它将随着Arrays.copy一起被复制到更大的数组中，对于JVM来说它们同样是存活的对象，但是对我们的应用程序来说这些是无用的。在一个需要长期运行的服务中如果出现这样的问题很容易导致OOM。</p>
<h3 id="3-2_可变参数列表：">3.2 可变参数列表：</h3><p>JDK1.5的特性，它和数组息息相关。实际上，可变参数列表实际还是通过数组来传递一组参数的，我觉得可以看作是一种语法糖。<br>可变参数列表与方法重载有关（静态分派，在编译和解析阶段确定），优先级最低；<br>使用可变参数列表时，如果有多个重载版本，会根据所传递的参数类型执行最匹配的版本，但是需要注意一些会产生“冲突”的情况：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VarArgsInit</span> {
    <span class="comment">//overload with var argument</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params">Long...longs</span>) </span>{
        System.<span class="keyword">out</span>.println(<span class="string">"f_long_varArgs"</span>);
    }

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params">Character...characters</span>) </span>{
    System.<span class="keyword">out</span>.println(<span class="string">"f_character_varArgs"</span>);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params"><span class="keyword">float</span> f, Character...characters</span>) </span>{
    System.<span class="keyword">out</span>.println(<span class="string">"f_float_character_varArgs"</span>);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span>(<span class="params"><span class="keyword">float</span> f, Character...characters</span>) </span>{
    System.<span class="keyword">out</span>.println(<span class="string">"g_float_character_varArgs"</span>);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span>(<span class="params"><span class="keyword">char</span> c, Character...characters</span>) </span>{
    System.<span class="keyword">out</span>.println(<span class="string">"g_char_character_varArgs"</span>);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
<span class="comment">//        f(); //Error:(19, 9) java: reference to f is ambiguous</span>
<span class="comment">//        f();</span>
        f(<span class="number">1</span>, <span class="string">'a'</span>); <span class="comment">//OK</span>
<span class="comment">//        f('a', 'b'); //Error:(19, 9) java: reference to f is ambiguous</span>
        g(<span class="string">'a'</span>, <span class="string">'b'</span>); <span class="comment">//OK</span>
    }
</code></pre><p>这个例子中，f(‘a’,’b’)会引起编译错误，因为它会同时匹配第3个和第2个f()版本（因为’a’可以转换成float），解决方法，很简单g方法的两个版本就不会有这种冲突。</p>
<h3 id="3-3_枚举：">3.3 枚举：</h3><p>JDK1.5的添加特性。enum也是类，它派生自Enum抽象类，但是与普通的类不同的时，编译器会给它添加一些特性，我觉得可以认为enum是一种具有特殊功能的class：<br>我们来看看一个枚举类型的字节码：</p>
<pre><code>final <span class="keyword">enum</span> hr.test.Color {

 <span class="comment">// 所有的枚举值都是类静态常量</span>
 <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">enum</span> hr.test.Color RED;
 <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">enum</span> hr.test.Color BLUE;
 <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">enum</span> hr.test.Color BLACK;
 <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">enum</span> hr.test.Color YELLOW;
 <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">enum</span> hr.test.Color GREEN;

<span class="keyword">private</span> <span class="keyword">static</span> final synthetic hr.test.Color[] ENUM$VALUES;

  <span class="comment">// 初始化过程，对枚举类的所有枚举值对象进行第一次初始化</span>
 <span class="keyword">static</span> {
       <span class="number">0</span>  <span class="keyword">new</span> hr.test.Color [<span class="number">1</span>] 
      <span class="number">3</span>  dup
      <span class="number">4</span>  ldc &lt;String <span class="string">"RED"</span>&gt; [<span class="number">16</span>] <span class="comment">//把枚举值字符串"RED"压入操作数栈</span>
      <span class="number">6</span>  iconst_0  <span class="comment">// 把整型值0压入操作数栈</span>
      <span class="number">7</span>  invokespecial hr.test.Color(java.lang.String, <span class="keyword">int</span>) [<span class="number">17</span>] <span class="comment">//调用Color类的私有构造器创建Color对象RED</span>
     <span class="number">10</span>  putstatic hr.test.Color.RED : hr.test.Color [<span class="number">21</span>]  <span class="comment">//将枚举对象赋给Color的静态常量RED。</span>
      .........  枚举对象BLUE等与上同
    <span class="number">102</span>  <span class="keyword">return</span>
};

  <span class="comment">// 私有构造器，外部不可能动态创建一个枚举类对象(也就是不可能动态创建一个枚举值)。</span>
 <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(java.lang.String arg0, <span class="keyword">int</span> arg1)</span></span>{
     <span class="comment">// 调用父类Enum的受保护构造器创建一个枚举对象</span>
     <span class="number">3</span>  invokespecial java.lang.Enum(java.lang.String, <span class="keyword">int</span>) [<span class="number">38</span>]
};

 <span class="keyword">public</span> <span class="keyword">static</span> hr.test.Color[] values();

  <span class="keyword">public</span> <span class="keyword">static</span> hr.test.<span class="function">Color <span class="title">valueOf</span><span class="params">(java.lang.String arg0)</span></span>;
}
</code></pre><p>从字节码解析中，首先可以看到：<br>（1）它是final的，因此我们无法继承它；<br>（2）所有枚举值，都是Color的实例，它们都是public static final的；</p>
<h4 id="编译器生成的方法：">编译器生成的方法：</h4><p>我们还有看到，编译器为enum添加了3个方法：<br>（1）私有构造器，保证无法从动态创建一个该类型的枚举对象；同时我们也无法使用反射创建一个enum类型实例：</p>
<pre><code>public <span class="class"><span class="keyword">enum</span>  <span class="title">MEnum</span> {</span>
    <span class="constant">E1</span>;

    static <span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>
        <span class="keyword">private</span> <span class="constant">A</span>(){
        }
    }

    public static void main(<span class="constant">String</span>[] args) throws <span class="constant">Exception</span> {
        <span class="constant">Class</span>&lt;<span class="constant">A</span>&gt; a = <span class="constant">A</span>.<span class="keyword">class</span>;
        <span class="constant">Constructor</span> constructor = a.getDeclaredConstructor();
        constructor.setAccessible(<span class="literal">true</span>);
        constructor.newInstance();
        <span class="constant">Class</span>&lt;?&gt; ec = <span class="constant">MEnum</span>.<span class="keyword">class</span>;
        <span class="constant">Constructor</span> constructor1 = ec.getDeclaredConstructor(<span class="constant">String</span>.<span class="keyword">class</span>, int.<span class="keyword">class</span>);
        constructor1.setAccessible(<span class="literal">true</span>);
        constructor1.newInstance(<span class="string">"YJH"</span>, <span class="number">2</span>);
    }

}
</code></pre><p>结果：A类可以正常创建，而enum类型，java.lang.IllegalArgumentException: Cannot reflectively create enum objects，因为在class.newInstance中有这样的检查：<br> if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)<br>            throw new IllegalArgumentException(“Cannot reflectively create enum objects”);<br>（2）values静态方法；<br>（3）valueOf(String)静态方法：它们都是编译器为具体的enum类型添加的，你在Enum抽象类中看不到它们；</p>
<p>enum可以说是严格全局不可修改的安全类型，它同样可以进行安全的序列化而不用担心不唯一的情况，正因为如此，使用单元素枚举创建单例对象是一种极佳的方法，同时可以不用担心反射攻击。</p>
<p>PS：enum可以和switch结合使用，十分方便；</p>
<h2 id="4-_创建和销毁对象的实践：">4. 创建和销毁对象的实践：</h2><p>《Effetive Java》中对于这一块给出了一些优秀的建议，以后在每一篇终结之后我都附上关于这篇的好的实践模式和要注意的反模式。学习这些思想和设计模式我觉得对我使用和理解Java中不同模块以及Spring等框架有很大的好处，因为它们都是基于这些的思想和模式建立的，能够帮助我更好的理解它们的结构和功能。</p>
<h3 id="4-1_使用静态工厂方法代替构造器：">4.1 使用静态工厂方法代替构造器：</h3><p><strong>优点</strong>：<br>（1）在具有比较复杂参数的构造器的时候，使用这很难通过重载版本来区别它们之间的功能差别，而使用静态工厂方法可以根据功能命名，像Executors中创建不同功能的线程池实例一样，静态工厂方法掩盖了构造器的复杂性；<br>（2）不必在每次调用它们的时候都创建一个新对象，静态工厂方法可以用于单例，享元模式，不可变类（final class，final field），不可实例化类（private 构造器）这些不同的场景；<br>（3）返回原返回类型的任何子类型：这一点影响觉得深远，广大，首先，在collection包中有Collection，List，Set，Map，Iterator等接口，Collections工具类，提供了很多具有附加功能的集合类实现，而它们都是定义在Collections中的嵌套类，通过静态工厂方法返回，还有Iterator，也是基于内部类实现的，通过它来返回，静态工厂方法可以隐藏具体的实现，支持面向接口的编程。<br>在开发J2EE项目时，经常用到Java Persistence API，websocket API，servlet API等等，它们是J2EE规范的一部分，我们仅仅引用了API，接口，而具体的实现我们可以会用到hibernate，spring的子项目，像servlet和websokcet API，它们的具体实现则多由J2EE 应用服务器实现它们，另外tomcat8.0也提供了websocket的实现。<br>这就是“服务提供者框架（service provider framework）”，提供者提供Service接口的具体实现，提供者可以使用提供者注册接口注册自己，提供者也可以实现provider接口或者通过类名直接注册，客户端使用者通过服务访问接口（其实就是静态工厂方法）；<br>（4）本来是用来简化有泛型参数时对象创建的，不过有了diomand表达式，java已经可以自己推导类型了；</p>
<h3 id="4-2_多个构造器参数时使用Builder模式：">4.2 多个构造器参数时使用Builder模式：</h3><p>重叠构造器和Bean+setter创建的方式真的不好维护，写过都知道，builder模式不仅仅可以灵活的组配参数；还可以创建不可变的对象。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HasBuilder</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i1;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i2;
    <span class="keyword">private</span> <span class="keyword">final</span> String s1;

<span class="function"><span class="keyword">public</span> <span class="title">HasBuilder</span><span class="params">(Builder builder)</span> </span>{
    <span class="keyword">this</span>.i1 = builder.i1;
    <span class="keyword">this</span>.i2 = builder.i2;
    <span class="keyword">this</span>.s1 = builder.s1;
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> i1;
    <span class="keyword">private</span> <span class="keyword">int</span> i2;
    <span class="keyword">private</span> String s1;

    <span class="function"><span class="keyword">public</span> Builder <span class="title">i1</span><span class="params">(<span class="keyword">int</span> i1)</span> </span>{
        <span class="keyword">this</span>.i1 = i1;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    <span class="function"><span class="keyword">public</span> Builder <span class="title">i2</span><span class="params">(<span class="keyword">int</span> i2)</span> </span>{
        <span class="keyword">this</span>.i2 = i2;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    <span class="function"><span class="keyword">public</span> Builder <span class="title">s1</span><span class="params">(String s1)</span> </span>{
        <span class="keyword">this</span>.s1 = s1;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    <span class="function"><span class="keyword">public</span> HasBuilder <span class="title">build</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> HasBuilder(<span class="keyword">this</span>);
    }
}
</code></pre><p>}<br>你可以通过在build构建在具体的设值方法里进行约束检查。</p>
<h3 id="4-3_建立合适的单例：">4.3 建立合适的单例：</h3><p>大致总结一下，有5种不同的单例模式：<br>（1）饿汉模式；<br>（2）懒汉模式：延迟加载，这就涉及到了线程安全的问题，用synchronized方法关键字效率太低；<br>（3）基于双检锁的单例：JDK1.5是安全的，需要通过volitale来保证可见性，一定要有手写它的能力！；<br>（4）基于静态内部类的方式：让静态内部类持有一个static final的实例，因为是内部类，所以自然也就可以延迟加载；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonWithInnerClass</span> {
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonWithInnerClass</span>(<span class="params"></span>) </span>{
        System.<span class="keyword">out</span>.println(<span class="string">"initialized"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonHolder</span> {
        <span class="keyword">private</span> <span class="keyword">static</span> final SingletonWithInnerClass s = <span class="keyword">new</span> SingletonWithInnerClass();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonWithInnerClass <span class="title">getInstance</span>(<span class="params"></span>) </span>{
        <span class="keyword">return</span> SingletonHolder.s;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        Class c = SingletonWithInnerClass.class; <span class="comment">//这里并没有进行初始化</span>
        System.<span class="keyword">out</span>.println(<span class="string">"start initialization:"</span>);
        SingletonWithInnerClass singletonWithInnerClass = SingletonWithInnerClass.getInstance();

    }
}
</code></pre><p>这段代码的输出结果：</p>
<pre><code><span class="operator"><span class="keyword">start</span> initialization:
<span class="keyword">initialized</span></span>
</code></pre><p>可见是延迟加载的；<br>（5）单元素枚举的方法，前面已经讨论过了，最佳，无偿序列化，防止反射攻击；</p>
<h3 id="4-4_私有构造器防止实例化：">4.4 私有构造器防止实例化：</h3><p>对于一些工具类或者存放全局变量来说，使用private构造器可以防止继承/实例化，如果使用接口和抽象类来实现，是一种反模式；</p>
<h3 id="4-5_避免创建不必要的对象：">4.5 避免创建不必要的对象：</h3><p>（1）注意String是有常量池的，它实际上是通过private final char[]来存放的，所以它是不可变的，只有第一次使用这个字符串组合的时候才进入常量池：<br>new String(“abc”);实际上是有两个字符串对象，”abc”是编译期存在，它已经进入常量池了；<br>（2）对于Calendar这样的实例化代价较大的对象考虑尽量复用；<br>（3）使用自动装箱类型一定要特别小心，以免在循环中因为自动装箱而创建大量对象，能用基本类型就不要用装箱类型；<br>（4）小对象的创建和销毁代价是很小的，因此，使用对象池的时候一定要考虑是不是值得，使用对象池管理不当也可能造成内存泄漏。</p>
<h3 id="4-6_消除过期引用：">4.6 消除过期引用：</h3><p>（1）自己管理内存的时候：之前提到的MyStack（自己管理内存之外），还有两个情形容易导致内存泄漏：<br>（2）缓存：不要让缓存的引用成为阻止垃圾回收的唯一原因，尽量使用weakHashMap，它不会影响引用，当然使用它需要注意，只有缓存项的生命周期依赖与它的外部引用时才可以使用它；常见的情况，使用一个后台线程Timer或者ScheduledTreadPoolExecutor或者添加新条目的时候检查（LinkedHashMap提供了这样的机制）；<br>（3）回调：这种基于观察者模式的方式都需要监听器或回调来注册，因此如果不再合适的时候释放也会造成泄漏，用弱引用是一种好的做法；<br>其实看看内存泄漏原因直接起来就是管理不当的引用池，这时由JVM可达性分析机制决定的；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java中的中介者模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/03/Java中的中介者模式/" class="article-date">
  	<time datetime="2015-12-03T07:21:37.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/Java中的中介者模式/">Java中的中介者模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java基础知识总结（二）——NIO" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/Java基础知识总结（二）——NIO/" class="article-date">
  	<time datetime="2015-12-02T07:10:05.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/Java基础知识总结（二）——NIO/">Java基础知识总结（二）——NIO</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于NIO这部分，除了《Java编程思想》中的介绍还有两份资料我觉得很好：一是《深入Java Web技术内幕》第2章的部分，二是并发编程网上Jakob JenkovNIO系列教程翻译，读完之后受益匪浅。</p>
<h1 id="1-_NIO是什么：">1. NIO是什么：</h1><p>java.nio是JDK1.4之后加入的，它新颖的特点在于：（1）面向缓存；（2）非阻塞；（3）直接内存；<br>首先来看看它的整体结构：一个完整的NIO程序体系应该包括Selector，Channel，Buffer，它们是NIO最核心的3个关键部分；</p>
<p>非阻塞IO是NIO的一大特点，那它是怎么实现的呢，Selector和它的名字所反映的一样起到选择和调度的作用，它所调度的就是Channel（通道），Channel包括：<br>FileChannel，<br>SocketChannel，ServerSocketChannel，<br>DatagramChannel，<br>管道；<br>它们负责对指定的资源进行访问读写，其中除了FileChannel都具有非阻塞的功能，ServerSocketChannel相当于一个服务器程序，它有accept方法监听和接受客户端的请求，而SocketChannel则对应于一个具体的Socket连接，它可以通过ServerSocketChannel的accept方法来得到，我们可以通过read和write对该连接信道进行读写，DatagramChannel是UDP数据报通信方式。在传统的IO中，accept，read，write方法都是阻塞的方式进行的，也就是说accept方法负责接受一个客户端请求，在未接受到一个请求之前线程就会阻塞在此处不能进行，因此要同时打开多个ServerSocketChannel必须要有多个线程支持，在非阻塞模式下，accept，read，write可以在直接返回，让其他任务可以执行，这样我们可以在一个线程中同时处理多个Channel，那你可能会问，accept直接返回了，请求来的时候如何在去调用accept接受呢，这就需要Selector来调度了，Selector的select()方法是阻塞的，它可以同时监听对Channel的操作请求，将请求转发到对应的channel中，从总体上看，把每个Channel中阻塞等待的行为统一移到了Selector，从而我们可以在单线程中同时处理多个信道的读写任务。Buffer缓存则是我们对Channel进行读写的工具，它还提供了Char，Int等多种不同的视图让我们可以以不同的方式读写数据，也提供了Heap和Direct直接内存两种缓存存储方式。<br>下面我们对这3个关键的“部件”进行详细的分析，当然我们应当明白不同的技术有不同的使用场景，这里为了突出NIO的特点我们集中于单线程（或少量线程）非阻塞的方式，它使用与高并发数据量处理少而简单的场景。</p>
<p>#2. Selector：<br>结合上面的论述，可以看到Selector起到了代替多个Channel监听感兴趣事件发生的作用，这让我很容易想起一个设计模式——观察者模式，在这里Selector是Obserable，Channel是Observer，Channel要向Selector注册自己对哪些事情感兴趣，当事件发生时，Selector通知对应的Channel。<br>这里注册有个两个部分：哪个channel和指定的事件，SelectionKey包含了注册的要素：</p>
<h2 id="2-1_SelectionKey（注册感兴趣的事，监听返回准备好的事，它关联一个Selector和Channel，我为什么忍不住想到迪米特法则，中毒太深…）：">2.1 SelectionKey（注册感兴趣的事，监听返回准备好的事，它关联一个Selector和Channel，我为什么忍不住想到迪米特法则，中毒太深…）：</h2><p>操作事件：<br>SelectionKey.OP_CONNECT<br>SelectionKey.OP_ACCEPT<br>SelectionKey.OP_READ<br>SelectionKey.OP_WRITE<br>因为SelectionKey包含5个部分：<br>（1）interest集合和ready集合一样包含有一些方便判断的方法，可以看api或源码；<br>（2）ready集合；<br>（3）channel引用；<br>（4）Selector引用；<br>（5）attach附加对象（可选）；</p>
<h2 id="2-2_Selector的重要方法：">2.2 Selector的重要方法：</h2><p>（1）select方法：包括select()，selectNow(非阻塞)，select(long timeout)返回int，有多个个ready的Channel；<br>（2）selectedKeys方法：返回ready的Channel的selectionKey集合，遍历它们，根据readyOps集合处理对应事件；<br>（3）wakeUp方法：从select阻塞中唤醒；<br>（4）close方法：是所用selectionKey无效，也就释放了对Channel们的引用不影响垃圾回收啦；</p>
<h2 id="2-3_Selector使用示例：">2.3 Selector使用示例：</h2><pre><code>public class <span class="type">SelectorSample</span> {
    private <span class="type">List</span>&lt;<span class="type">SelectableChannel</span>&gt; channels;
    private boolean isListening = <span class="literal">true</span>;

    public <span class="type">SelectorSample</span>(<span class="type">List</span>&lt;<span class="type">SelectableChannel</span>&gt; channels) {
        this.channels = channels;
    }

    public <span class="type">void</span> doHandle() {
        <span class="keyword">try</span>(<span class="type">Selector</span> selector = <span class="type">Selector</span>.open()) {
            <span class="keyword">for</span>(<span class="type">SelectableChannel</span> channel : channels) {
                channel.configureBlocking(<span class="literal">false</span>); //非阻塞
                channel.register(selector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span> | <span class="type">SelectionKey</span>.<span class="type">OP_CONNECT</span>
                        | <span class="type">SelectionKey</span>.<span class="type">OP_READ</span> | <span class="type">SelectionKey</span>.<span class="type">OP_WRITE</span>);
            }
            <span class="keyword">while</span>(isListening) {
                <span class="type">int</span> ready = selector.select();
                <span class="keyword">if</span>(ready == <span class="number">0</span>) <span class="keyword">continue</span>;
                <span class="type">Set</span>&lt;<span class="type">SelectionKey</span>&gt; selectionKeys = selector.selectedKeys();
                <span class="keyword">for</span>(<span class="type">Iterator</span>&lt;<span class="type">SelectionKey</span>&gt; <span class="keyword">iterator</span> = selectionKeys.<span class="keyword">iterator</span>(); <span class="keyword">iterator</span>.hasNext();) {
                    <span class="type">SelectionKey</span> key = <span class="keyword">iterator</span>.next();
                    <span class="keyword">if</span>(key.isAcceptable()) {
                        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"doSomething when be acceptable"</span>);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable()) {
                        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"doSomething when be able to connect"</span>);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) {
                        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"doSomething when be readable"</span>);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable()) {
                        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"doSomething when be writable"</span>);
                    }
                    <span class="keyword">iterator</span>.remove(); //注意要从就绪集合中删除，下次就绪有selector添加
                }
            }
        } catch (<span class="type">IOException</span> e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h1 id="2-_Channel_：">2. Channel ：</h1><p>Channel的体系中有：SelectableChannel和InterruptiableChannel，前者继承自后者，之前说过FileChannel是不可以非阻塞的它属于InterruptiableChannel，而其他3种进一步属于SelectableChannel。</p>
<h2 id="2-1_如何打开通道：">2.1 如何打开通道：</h2><p>ServerSocketChannel，SocketChannel，DatagramChannel都有open方法，可以用来打开通道，它们都属于网络编程，底层是要依赖操作系统层对应网络模块的实现，在Java中这3个通道和管道都是通过SelectorProvider来创建的，该Provider在不同平台上有不同的实现，JVM有一个“system-wide”的默认实现，它是单例的。<br>而FileChannel是对应于文件系统的，基于Java I/O，我们可以从FileInputStream，FileOutputStream，RandomAccessFile来获取一个对应于特定文件的通道。</p>
<p>我们进一步看看这四个具体的Channel实现那些接口，来分析它们各自有什么功能：</p>
<h2 id="2-2_ServerSocketChannel：">2.2 ServerSocketChannel：</h2><p>线程安全；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span>
    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>
    <span class="keyword">implements</span> <span class="title">NetworkChannel</span>
 它的主要功能就是监听的某个地址和端口上的套接字请求，并打开<span class="title">SocketChannel</span>；</span>
</code></pre><h2 id="2-3_SocketChannel：">2.3 SocketChannel：</h2><p>线程安全，read/write都进行了同步控制；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span>
    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>
    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span></span>
</code></pre><p> ByteChannel实现了WritableChannel和ReadableChannel，因此它是可读写的；<br>Scatter/Gatther分别实现了将一个channel的内容读到多个buffer（一个Buffer满了才能读到下一个）和多个Buffer写到一个Channel的功能；<br>NetworkChannel：绑定到地址/端口的能力；<br>我们可以通过它来进行一个端到端的，有连接的套接字通信；</p>
<h2 id="2-4_DatagramChannel：">2.4 DatagramChannel：</h2><p>线程安全的；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DatagramChannel</span>
    <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>
    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">MulticastChannel</span></span>
</code></pre><p> 与SocketChannel接口上的不同在与MulticastChannel，它是NetworkChannel子类；增加了多播的功能，使得我们可以使用基于UDP套接字的多播功能；</p>
<h2 id="2-5_Pipe：">2.5 Pipe：</h2><p>管道一般可以在两个线程中进行单向的数据传输，它有两个嵌套类：SinkChannel和SourceChannel，分别负责在一个线程（发送者）写入和在另一个线程中读取：<br>    public static abstract class SinkChannel<br>            extends AbstractSelectableChannel<br>            implements WritableByteChannel, GatheringByteChannel</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceChannel</span>
        <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>
        <span class="keyword">implements</span> <span class="title">ReadableByteChannel</span>, <span class="title">ScatteringByteChannel</span></span>
</code></pre><p> 基于上面的论述，相信已经可以很清除的明白它们各自有什么功能了：都可以非阻塞，一个负责写，并且可以将多个Buffer一起写入，一个负责读，可以从Channel中将数据读入多个Buffer；</p>
<h2 id="2-6_FileChannel：">2.6 FileChannel：</h2><p>这个Channel是阻塞的，是操作磁盘文件一种方式，它和之前几个Channel大不相同，所以我要将它和下面要介绍的DirectByteBuffer（MappedByteBuffer）一起讨论。</p>
<h1 id="3-_Buffer：">3. Buffer：</h1><p>总的来说，具体工作中使用Buffer的次数要远远多与Selector和Channel，我们通过它对Channel进行具体的读写操作。<br>之前说过NIO的特点之一就是面向缓存，我们在使用Buffer时都是基于一块分配指定的大小的固定内存进行操作的，只有两种分配方式：Heap和Direct，它们的区别下面会详细说明。无论我们进行视图转换（CharBuffer/IntBuffer等等），还是compact压缩，还是duplicate复制、slice切片，都是最初的allocate分配那一块内存。</p>
<h2 id="3-1_Buffer的基本属性和重要方法：">3.1 Buffer的基本属性和重要方法：</h2><p>capacity：容量；<br>limit：可操作的限制位置；<br>position：下一个操作位置；<br>mark：标记；<br>address：使用direct内存时的内存地址；<br>capacity，limit，position这3个属性是我们进行操作最关键和常用的，结合操作方法我们来看看它们的使用细节：<br>flip：limit=position，position=0；这个方法通常在从通道中读取数据后使用，这样我们可以再从Buffer中读取数据；或者在Buffer写入数据后调用，让通道写入；<br>rewind：position=0,mark=-1；<br>clear：position=0，limit=capacity，mark=-1；通常在重新从<br>remaining：limit-position；用于检查是否还有数据；<br>mark和reset：mark标记，mark=position；reset复位，position=mark（mark&gt;0时），注意它并不会修改mark值；<br>compact：将原来（limit-position）未处理完的数据复制到开头，再将position移到数据的下一个位置，limit=capacity，这个方法是进行压缩，去掉已处理过的数据，主要   为了接下来将数据写入Buffer，注意，它只是在原数组上进行复制的，没有新分配空间；<br>另一个你可能需要注意的是equals方法和compareTo方法，它们比较的是limit-position之间的大小；</p>
<h2 id="3-2_Buffer的体系结构：">3.2 Buffer的体系结构：</h2><p>首先，重要的事先说说：Buffer并不是线程安全的。<br>来看看Buffer的体系：</p>
<p>Channel都是基于字节的，我们一般也从ByteBuffer开始；</p>
<h3 id="ByteBuffer具体实现（分配）：">ByteBuffer具体实现（分配）：</h3><p>ByteBuffer有两个分配方法（它们返回<strong>HeapByteBuffer</strong>和<strong>DirectByteBuffer</strong>都是default包权限，我们无法直接使用它们）：<br><strong>allocate</strong>：<strong>HeapByteBuffer</strong>，从JVM堆中分配，收到JVM垃圾回收处理机制管理，实际上就是为了一个固定的byte[]；<br><strong>allocateDirect</strong>：<strong>DirectByteBuffer</strong>，使用JNI在native内存中分配，那怎么回收直接内存呢，DirectBuffer（DirectByteBuffer的接口），可以返回<strong>Cleaner</strong>，通过它我们可以释放直接内存，否则你就只能等待Full GC的发生来释放它了，依赖JNI响应的回收方法和堆中DirectByteBuffer对象的回收；<br>Buffer的视图：</p>
<p>在类图中我们可以看到有CharBuffer，IntBuffer，另外还有FloatBuffer，DoubleBuffer，ShortBuffer，LongBuffer以及MappedBuffer（特别的，内存映射）；<br>它们实际上都是由ByteBuffer而产生，操作同一块内存，只是读取的方式不一样，以HeapByteBuffer和CharBuffer为例我们来看看它们是怎么完成“视图”的使命的。<br>转换方法：<br>ByteBuffer.asCharBuffer();<br>HeapByteBuffer中是这样实现的：</p>
<pre><code><span class="function"><span class="keyword">public</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span> </span>{
        <span class="keyword">int</span> size = <span class="keyword">this</span>.remaining() &gt;&gt; <span class="number">1</span>;
        <span class="keyword">int</span> off = offset + position();
        <span class="keyword">return</span> (bigEndian
                ? (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferB(<span class="keyword">this</span>,
                                                               -<span class="number">1</span>,
                                                               <span class="number">0</span>,
                                                               size,
                                                               size,
                                                               off))
                : (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferL(<span class="keyword">this</span>,
                                                               -<span class="number">1</span>,
                                                               <span class="number">0</span>,
                                                               size,
                                                               size,
                                                               off)));
    }
</code></pre><p> 考虑到字顺这里有两个实现，新建一个ByteBufferAsCharBufferB还是操作那一块内存，只是我们换了一组capacity，limit，mark，position来操作；<br>而在具体的get/put方法中：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> Bits.getCharB(bb, ix(nextGetIndex()));
    }
</code></pre><p> 是通过Bits这个工具类来进行不同基本类型的读取和操作。整个事情就是这样，基于字节ByteBuffer，考虑字顺用不同的方式去读写同一块内存；<br>PS：对于CharBuffer和ByteBuffer之间的转换，涉及到编解码，Charset有ByteBuffer = encode(CharBuffer)和CharBuffer = decode(ByteBuffer)；</p>
<h1 id="4-_FileChannel">4. FileChannel</h1><p>同样它也是线程安全的。</p>
<h1 id="4-1_打开FileChannel：">4.1 打开FileChannel：</h1><p>之前我们已经提到了它可通过FileInputStream、FileOutputStream和RandomAccessFile获得，但是它们具有不同的读写权限：<br>RandomAccessFile：rw</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="keyword">if</span> (channel == <span class="keyword">null</span>) {
                channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, rw, <span class="keyword">this</span>);
            }
            <span class="keyword">return</span> channel;
        }
    }
</code></pre><p>FileOutputStream：</p>
<pre><code><span class="keyword">public</span> FileChannel getChannel() {
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="keyword">if</span> (channel == <span class="keyword">null</span>) {
                channel = FileChannelImpl.<span class="built_in">open</span>(fd, path, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="built_in">append</span>, <span class="keyword">this</span>);
            }
            <span class="keyword">return</span> channel;
        }
    }
</code></pre><p>FileInputStream：</p>
<pre><code><span class="keyword">public</span> <span class="function">FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="keyword">if</span> (channel == <span class="keyword">null</span>) {
                channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>);
            }
            <span class="keyword">return</span> channel;
        }
    }
</code></pre><p> 正如RandomAccessFile（可以seek方式前后读写文件），FileInputStream和FileOutputStream本身的差异一样，它们也具有不同的特点；</p>
<h2 id="4-2_FileChannel的独特的方法：">4.2 FileChannel的独特的方法：</h2><p>写，读，关闭和其他Channel使用方式是一样的，我们来看看它对文件还有什么其他操作：<br>FileChannel.position(long)：移到文件的特定位置，接下来你可以从这个位置写/读，你可以在文件结束符之后写入，这和我们在Unix中一样，它也可能会造成<strong>文件空洞</strong>。<br>FileChannel.truncate(long)：截取前多少字节的数据；<br>FileChannel.size()：返回关联文件大小；<br>FileChannel.force()：将缓存内（操作系统为了提高性能）的数据强制写入磁盘；</p>
<h2 id="4-3_transfer：">4.3 transfer：</h2><p>如果你需要在WritableChannel之间传递数据，使用transferTo和transferFrom是一个非常好的选择；<br>因为这种方式不需要将磁盘数据从内核空间复制到应用用户空间在传到另一个内核空间，而是直接在内核空间中通过“通道传输”；</p>
<h2 id="4-4_FileChannel中的内存映射：">4.4 FileChannel中的内存映射：</h2><p>为了显示内存映射到底是怎么存储，可以看看创建MapByteBuffer的源码：</p>
<pre><code><span class="keyword">static</span> <span class="function">MappedByteBuffer <span class="title">newMappedByteBuffer</span><span class="params">(<span class="keyword">int</span> var0, <span class="keyword">long</span> var1, FileDescriptor var3, Runnable var4)</span> </span>{
        <span class="keyword">if</span>(directByteBufferConstructor == <span class="keyword">null</span>) {
            initDBBConstructor();
        }

        <span class="keyword">try</span> {
            MappedByteBuffer var5 = (MappedByteBuffer)directByteBufferConstructor.newInstance(<span class="keyword">new</span> Object[]{<span class="keyword">new</span> Integer(var0), <span class="keyword">new</span> Long(var1), var3, var4});
            <span class="keyword">return</span> var5;
        } <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException | InstantiationException var7) {
            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(var7);
        }
    }
</code></pre><p> 这里可以看到显然是通过直接内存的方式，但是这段代码是在FileChannel的map方法中调用的，它和allocateDirect是有区别的；要理解直接内存和内存映射中的原理需要一些重要的基础知识，才能真正弄清楚HeapByteBuffer，DirectByteBuffer，和map之间的区别。<br><strong>（1）为什么FileInputStream和HeapByteBuffer相对要慢很多呢？</strong><br>Java中读取文件要依赖于内核的系统调用，将文件数据从磁盘读取到内核IO缓存区（内存中），再转到JVM堆中（上面已经看到了HeapByteBuffer中new byte[]）。首先要明白为什么要建立内核IO缓冲区，就是为了减少磁盘的访问次数，因为磁盘IO效率很低，读到内核IO缓存区转到JVM堆又需要调用native方法，依赖系统调用，系统调用的开销有比较大，因为我们可以BufferedInputStream和HeapByteBuffer来建立缓冲区减少系统调用。尽管我们通过内核IO缓冲区和Java应用缓冲区两层缓存分别减少了耗时的磁盘IO和系统调用，但是仍然不能避免内核态切换到用户态，内核空间复制到用户空间这样的耗时操作。</p>
<p><strong>（2）为什么allocateDirect要比传统方式快？</strong><br>如果你看了DirectByteBuffer的源码你就会发现其中并没有new byte[]这样在JVM Heap中分配的行为，用的是address（Buffer中定义，long，64位）。实际上DirectMemory使用的是native堆，因此避免了向JVM堆复制的开销，但是需要注意的一点是，allocateDirect方法本身的开销比allocate方法大，因为它依赖系统调用，因此我们使用时应该避免频繁调用它分配小块内存。<br>设置：JVM参数中，-XX:MaxDirectMemorySize可以控制它的大小，默认值为-Xmx的大小；<br>回收：FULL CG（JNI的回收方法和DirectByteBuffer对象的回收）和我们手动通过Cleaner去释放；</p>
<p>PS：2015/10/24 补充<br>allocateDirect存在于内核空间，如果所有的操作都存在与内核空间中，可以减少内核空间向用户空间复制，因此很快，但是如果频繁的分配小的直接内存，系统调用的开销会抵消减少复制的好处；另外如果我们用很小的直接内存读取磁盘数据到内存（也就是从ByteBuffer中get出来使用）还是会产生复制，性能并不会有太大改善。</p>
<p><strong>（3）为什么内存映射更快呢？</strong><br>简单的说，内存映射并没有上面的分配行为，既不需要native堆也不需要JVM堆，它是以Java进程直接将需要读写的文件映射为虚拟内存，以内存的方式进行读写，这样读写自然要比它们要快的多。同时它也是线程间进行通信的一种方式，两个进程映射同一块虚拟内存，共享内存的方式进行通信。<br>通过FileChannel.map可以对指定文件或其部分进行内存映射，有三种模式：READ_ONLY, READ_WRITE, PRIVATE。</p>
<h2 id="4-5_不同读取方式的对比：">4.5 不同读取方式的对比：</h2><pre><code><span class="keyword">public</span> class DirectMemoryTest {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> TEST_FILE = <span class="string">"/home/yjh/test.file"</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testNormal(<span class="keyword">String</span> TEST_FILE) {
        System.out.<span class="built_in">print</span>(<span class="string">"Normal "</span>);
        <span class="keyword">try</span>(FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(TEST_FILE);
            FileChannel fileChannel = inputStream.getChannel()) {
            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);
            <span class="keyword">while</span>(fileChannel.read(buffer) != -<span class="number">1</span>) {
                buffer.flip();
                buffer.<span class="built_in">clear</span>();
            }
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testDirect(<span class="keyword">String</span> TEST_FILE) {
        System.out.<span class="built_in">print</span>(<span class="string">"Direct "</span>);
        <span class="keyword">try</span>(FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(TEST_FILE);
            FileChannel fileChannel = inputStream.getChannel()) {
            ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);
            <span class="keyword">while</span>(fileChannel.read(buffer) != -<span class="number">1</span>) {
                buffer.flip();
                buffer.<span class="built_in">clear</span>();
            }
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testMapped(<span class="keyword">String</span> TEST_FILE) {
        System.out.<span class="built_in">print</span>(<span class="string">"Mapped "</span>);
        <span class="keyword">try</span>(FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(TEST_FILE);
            FileChannel fileChannel = inputStream.getChannel()) {
            MappedByteBuffer buffer = fileChannel.<span class="built_in">map</span>(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, fileChannel.<span class="built_in">size</span>());
            <span class="built_in">byte</span>[] b = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];
            <span class="keyword">while</span>(buffer.<span class="built_in">get</span>(b).position() &lt; buffer.limit()) {

            }
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> test(Consumer&lt;<span class="keyword">String</span>&gt; consumer) {
        <span class="keyword">long</span> startTime = System.currentTimeMillis();

        consumer.accept(TEST_FILE);

        <span class="keyword">long</span> endTime = System.currentTimeMillis();

        System.out.<span class="built_in">println</span>(<span class="string">"Time consume: "</span> + (endTime - startTime));
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
        test(DirectMemoryTest::testNormal);
        test(DirectMemoryTest::testDirect);
        test(DirectMemoryTest::testMapped);
    }
}
</code></pre><p>我对三种方式分别读取整个test文件的内容，该文件大小为500M，运行结果（单位：ms）：<br>Normal Time consume: 930<br>Direct Time consume: 800<br>Mapped Time consume: 222</p>
<p>在这个例子中，allocateDirect的直接内存同样读取了很多次（500MB / 1024B）磁盘数据，调用了很多次系统调用，因此和传统方式的效率并不有太大提升。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-基于wait和nofity的生产者和消费者模式版本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/基于wait和nofity的生产者和消费者模式版本/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/基于wait和nofity的生产者和消费者模式版本/">基于wait和nofity的生产者和消费者模式版本</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果不用阻塞队列，生产者和消费者模式如何实现，我自己写了一版本，小记一下：</p>
<p>除了Producer和Consumer之外，我还创建了一个ValueHolder用来解耦，并且包含了两个fianl对象作为锁；我觉得这样做可以基于final引用同步，更为安全一些；</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>{
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueHolder</span> </span>{
        <span class="keyword">private</span> <span class="keyword">final</span> Object mutexProduce = <span class="keyword">new</span> Object();
        <span class="keyword">private</span> <span class="keyword">final</span> Object mutexConsumer = <span class="keyword">new</span> Object();
        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;

        <span class="keyword">private</span> Value value;

        <span class="function"><span class="keyword">public</span> <span class="title">ValueHolder</span><span class="params">(ExecutorService executor)</span> </span>{
            <span class="keyword">this</span>.executor = executor;
        }
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
        <span class="keyword">private</span> <span class="keyword">final</span> ValueHolder holder;
        <span class="keyword">private</span> <span class="keyword">int</span> count;

        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(ValueHolder holder)</span> </span>{
            <span class="keyword">this</span>.holder = holder;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{
            <span class="keyword">if</span>(holder != <span class="keyword">null</span>) {
                <span class="keyword">try</span> {
                    <span class="keyword">while</span>(!Thread.interrupted()) {
                        <span class="keyword">synchronized</span> (holder.mutexProduce) {
                            <span class="keyword">while</span>(holder.value != <span class="keyword">null</span>)
                                holder.mutexProduce.wait();
                        }
                        <span class="keyword">if</span>(count &gt; <span class="number">10</span>)
                            holder.executor.shutdownNow();
                        System.out.println(<span class="string">"has a value produced..."</span>);
                        <span class="keyword">synchronized</span> (holder.mutexConsumer) {
                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);
                            holder.value = <span class="keyword">new</span> Value();
                            count++;
                            holder.mutexConsumer.notifyAll();
                        }
                    }
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            produce();
        }
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
        <span class="keyword">private</span> <span class="keyword">final</span> ValueHolder holder;

        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(ValueHolder holder)</span> </span>{
            <span class="keyword">this</span>.holder = holder;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{
            <span class="keyword">if</span>(holder != <span class="keyword">null</span>) {
                <span class="keyword">try</span> {
                    <span class="keyword">while</span>(!Thread.interrupted()) {
                        <span class="keyword">synchronized</span> (holder.mutexConsumer) {
                            <span class="keyword">while</span>(holder.value == <span class="keyword">null</span>)
                                holder.mutexConsumer.wait();
                        }
                        System.out.println(<span class="string">"has a value from producer..."</span>);
                        <span class="keyword">synchronized</span> (holder.mutexProduce) {
                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);
                            holder.value = <span class="keyword">null</span>;
                            holder.mutexProduce.notifyAll();
                        }
                    }
                } <span class="keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            consume();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);
        ValueHolder valueHolder = <span class="keyword">new</span> ValueHolder(executor);
        Producer producer = <span class="keyword">new</span> Producer(valueHolder);
        Consumer consumer = <span class="keyword">new</span> Consumer(valueHolder);


        executor.execute(producer);
        executor.execute(consumer);

        executor.shutdown();
    }

}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考和求解/">思考和求解</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java基础知识总结（五）——安全" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/Java基础知识总结（五）——安全/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/Java基础知识总结（五）——安全/">Java基础知识总结（五）——安全</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="小结：">小结：</h5><p>一直说Java安全性比较好，系统的整理了下有关的Java的安全的三个方面：语言特性，安全管理器（保护域），签名和加密算法的应用。</p>
<h1 id="1-_概括">1. 概括</h1><p>Java语言的安全由三个方面共同进行保证：</p>
<h3 id="（1）语言特性：">（1）语言特性：</h3><p>类，域，方法的访问控制；<br>运行时的检查：指针操作的封装，数组的越界检查，类型转换的检查；<br>编译时检查：字节码加载，比如语义分析时会对变量是否初始化，运算符两边的类型是否匹配等等；<br>类加载：双亲委托加载模型/线程上下文类加载器，验证（文件格式验证，元数据验证，字节码验证（是否初始化，类型是否匹配等），符号验证（访问权限））；</p>
<p><strong>类加载器的安全性在于</strong>：<br>（1）双亲委托的模型中核心类，扩展类，应用类有各自层次的类加载器；<br>（2）Java中每个类型有全限定名和类加载实例两者决定，每个类加载器实例提供一个类型的命名空间；<br>（3）类加载器会检查不能由非BootStrap类加载器加载JDK核心类；<br>（4）验证环节；</p>
<h3 id="（2）访问控制：安全管理器">（2）访问控制：安全管理器</h3><h3 id="（3）代码签名，加密算法验证创建者；">（3）代码签名，加密算法验证创建者；</h3><h1 id="2-_安全管理器">2. 安全管理器</h1><p>Java平台安全性的演进：<br>（1）JDK1.0：本地代码具有所有的权限，远程代码在沙盒中运行，只能打印到屏幕和与用户交互；<br>（2）JDK1.1：远程代码带有可信赖的签名，具有与本地代码资源的所有权限；<br>（3）JDK2.0：基于<strong>保护域</strong>的安全体系，保护域包括<strong>代码来源</strong>和<strong>权限集合</strong>的映射，SecurityManager检查<strong>调用堆栈上所有方法的类</strong>的保护域，其权限集合是否允许执行当前的操作,如果所有域都通过检查则通过，否则抛出SecurityException异常；</p>
<h2 id="2-1_重要的类和方法（体系结构）：">2.1 重要的类和方法（体系结构）：</h2><p>（1）SecurityManager：checkPermission等验证方法，抛出SecurityException；<br>（2）java.Security.ProtectionDomain：保护域，包含代码来源（CodeSource）和权限集合（PermissionCollection）；<br>（3）Class：getProtectionDomain获取该类的保护域；<br>（4）java.Security.CodeSource：代码来源，包含代码位置和相关联的证书链（用于类文件签名）；<br>（5）Permission：包含implies方法（条件间的依赖关系），通过name属性是关键，equals和hashcode主要由它决定，和Principal一样可以自定义；</p>
<p>安全策略文件：<br>位置：<br>（1）Java平台主目录（java.policy文件）；<br>（2）用户主目录（.java.policy）；<br>（3）通过jvm参数指定，<br>（4）System.setProperty(“java.security.plicy”,)设置；</p>
<h2 id="2-2_用户认证（JAAS_API规范）：">2.2 用户认证（JAAS API规范）：</h2><p>（1）通过LoginContext登录，可以传入CallbackHandler（handler中可以携带一些登录信息），使用在config文件中定义的LoginModule（也可以自定义）将callbackHandler中的登录信息传递到回调对象，从而获得登录信息；<br>（2）根据用户信息库（可以是目录文件，数据库等等）。通过验证后可以获得一个Subject；<br>（3）LoginModule会给这个用Subject添加一些Principal（特征），通过Subject.doAsPrivileged（一个新的上下文，与登录环境权限分离）中执行受检查的action；<br>（4）如果policy中subject带有的principal有对应权限的话这可以执行，否则抛出AccessControlException；</p>
<p>LoginModule是检查登录权限的关键，向它传入CallbackHandler（登录信息），Subject（认证对象），options（config中对应的键值对信息），sharedState（登录模块间通信）；</p>
<h1 id="3-_数字签名">3. 数字签名</h1><h2 id="3-1_消息摘要">3.1 消息摘要</h2><p>消息摘要（message digest）：是数据块的数字指纹。<br>基本属性：<br>（1）如果数据的1位或几位改变了，那么消息摘要也将要改变。<br>（2）拥有给定消息的伪造者不能创建与原消息具有相同的假消息；</p>
<p>Java中的MessageDigest和Charset的体系很像，作为消息摘要算法子类的超类的同时也是工厂类；</p>
<p>消息摘要意义在于检查文件（消息）是否被修改过，这就要求消息摘要和消息分开传递，否则一同截获再被修改（很容易）就无法起作用了。比如，保存文件是常常可以通过MD5验证的方式检查文件是否是同一文件。</p>
<h2 id="3-2_消息签名">3.2 消息签名</h2><p>由于消息摘要的局限性，在需要认证用户身份的时候就需要数字签名同时能够校验消息有无被修改，中途被篡改。</p>
<p>数字签名算法（DSA）；</p>
<h3 id="重要概念：">重要概念：</h3><p>（1）公共密钥：可以公开，数字签名中，对方通过公共密钥校验消息的来源可信性（原始信息未修改，验证对方身份）；在非对称加密算法中，可以用来加密给对方的消息；<br>（2）私有密钥：非公开，在数字签名中，可以用生成签名；在非对加密中，可以通过私有密钥解密对方发来的加密消息；<br>（3）公共密钥和私有密钥的设计在于通过一个密钥推算出另一个密钥是实际不可性的，在数字签名中，私有密钥相当于个人的凭证。</p>
<h3 id="数字签名原理：">数字签名原理：</h3><p>（1）发送方，生成自己的密钥库，包含私有密钥和公有密钥，将公有密钥包含导出成证书将这个证书发送给接受方；<br>（2）接收方，验证证书的真实性，接受到带有签名的消息后，利用证书验证<strong>是否为发送方的签名</strong>和<strong>消息有无被修改</strong>；</p>
<h3 id="基于第三方认证机构的认证">基于第三方认证机构的认证</h3><p>我觉得这种模式类似于中介者设计模式/迪米特法则，类似的还有集群架构中中心式的拓扑结构，将多对多的联系变成一对多，复杂性集中在中介者身上，将认证的步骤分离出来。<br>（1）第三方将自己的<strong>根证书（公有密钥）</strong>导出，可以利用pem格式（隐私增强型邮件格式）；<br>（2）用户将<strong>根证书</strong>导入密钥库中，这时用户的密钥库能够信任这个第三方平台发来的信息；<br>（3）将发送方的证书同样导出成pem格式，基于openssl和第三方的CA对该证书签名生成pem，这是第三方平台对发送方的认证；<br>（4）将这个带有第三方签名的证书由接收方导入密钥库（因为已有了第三方的证书），最后接收方就拥有了发送方的证书；</p>
<h3 id="keytool，jarsign：JDK数字证书，签名生成工具">keytool，jarsign：JDK数字证书，签名生成工具</h3><p>生成密钥库：keytool -genkeypair -keystore xxx.certs -alias xxx；<br>导出证书：keytool -exportcert -keystore xxx.certs -alias acmeroot -file acmeroot.cer；<br>导入证书到密钥库：keytool -importcert -keystore xxx.certs -alias yyy -file yyy.cer（yyy发送方别名）；<br>打印证书：keytool -printcert -file xxx.cer；<br>列出密钥库证书：keytool -list -v -keystore xxx</p>
<p>使用证书签名jar：jarsigner -keystore xxx.certs document.jar xxx<br>验证jar签名：jarsigner -verify -keystore xxx.certs document.jar</p>
<h2 id="4-_加密：">4. 加密：</h2><p>消息签名可以认证代码的来源，并且校验是否被修改，但是消息本身是可见的，对于重要的信息需要加密。</p>
<p>Cipher类：与Charset和MessageDigest一样，超类+工厂类。</p>
<h3 id="4-1_加密算法：">4.1 加密算法：</h3><p>对称密码：DES（穷举法可破解），AES等；<br>非对称密码：RSA等</p>
<h4 id="非对称加密算法的应用方式">非对称加密算法的应用方式</h4><p><strong>公有密钥算法比对称密钥算法慢的多</strong>，因此不能用来加密大量的信息。使用对称密钥算法加密正文，公有密钥加密对称密钥是一种可行的方式。<br>（1）发送方生成对称密钥，对明文进行加密，并使用接收方的公有密钥对对称密钥进行加密；<br>（2）将加密后的明文和对称密钥一同发送给接收方；<br>（3）接收方使用自己的私有密钥将对称密钥解密，再用对称密钥解密得到明文；</p>
<p>使用公有密钥算法的方式和下面对称加密算法的方式类似：主要要使用WARP_MODE和UNWARP_MODE对对称加密的<code>key</code>进行加解密。</p>
<h4 id="生成密钥">生成密钥</h4><p>生成密钥可以用<strong>SecureRandom</strong>或者<strong>随机序列（随机敲键盘）</strong>的得到随机种子。密钥可以用序列化的方式输出到磁盘等地方保存。<br>方式一：</p>
<pre><code><span class="constant">KeyGenerator keyGenerator</span> = KeyGenerator.getInstance(<span class="string">"AES"</span>);
<span class="comment">//"真正的随机数"，加密的随机数，需要额外性能</span>
<span class="comment">//Random以日期和时间为种子并不安全</span>
<span class="constant">SecureRandom secureRandom</span> = new SecureRandom();
keyGenerator.init(secureRandom);
<span class="constant">Key key</span> = keyGenerator.generateKey();
</code></pre><p>方式二：</p>
<pre><code><span class="built_in">byte</span>[] seq = <span class="string">"sdlkfjiuqoenrgiuerds,msfd"</span>.getBytes();
SecretKey <span class="variable">key</span> = <span class="keyword">new</span> SecretKeySpec(seq, <span class="string">"AES"</span>);
</code></pre><h4 id="加密">加密</h4><p>选择加密算法：</p>
<pre><code>Cipher aes = Cipher.getInstance(<span class="string">"AES"</span>);
<span class="comment">/* 
    模式有4种：
    ENCRYPT_MODE
    DECRYPT_MODE
    UNWARP_MODE
    WARP_MODE
*/</span>
<span class="built_in">int</span> mode = Cipher.ENCRYPT_MODE;
aes.init(mode, <span class="variable">key</span>);
</code></pre><p>将输入流中的数据加密写入输出流。注意如果数据不能以blockSize对齐，应该使用doFinal写入深入部分，该方法可以补齐。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crypt</span>(<span class="params">InputStream <span class="keyword">in</span>, OutputStream <span class="keyword">out</span>, Cipher cipher</span>) throws IOException, GeneralSecurityException </span>{
        <span class="keyword">int</span> blockSize = cipher.getBlockSize();
        <span class="keyword">int</span> outputSize = cipher.getOutputSize(blockSize);
        <span class="keyword">byte</span>[] inBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[blockSize];
        <span class="keyword">byte</span>[] outBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[outputSize];

        boolean more = <span class="keyword">true</span>;
        <span class="keyword">int</span> inLen = <span class="number">0</span>;
        <span class="keyword">while</span>(more) {
            inLen = <span class="keyword">in</span>.read(inBytes);
            <span class="keyword">if</span>(inLen == blockSize) {
                <span class="keyword">int</span> outputLen = cipher.update(inBytes, <span class="number">0</span>, blockSize, outBytes);
                <span class="keyword">out</span>.write(outBytes, <span class="number">0</span>, outputLen);
            } <span class="keyword">else</span> {
                more = <span class="keyword">false</span>;
            }
        }
        <span class="keyword">if</span>(inLen &gt; <span class="number">0</span>) outBytes = cipher.doFinal(inBytes, <span class="number">0</span>, inLen);
        <span class="keyword">else</span> outBytes = cipher.doFinal();
        <span class="keyword">out</span>.write(outBytes);
        <span class="keyword">out</span>.flush();
    }
</code></pre><h4 id="密码流">密码流</h4><p>使用CiperInputStream和CiperOutputStream可以屏蔽<code>update</code>和<code>doFinal</code>等细节；</p>
<hr>
<h3 id="附：policy，config语法小记：">附：policy，config语法小记：</h3><p>grant：codeBase，principal，signedBy（加alias）；<br>Login1 {LoginModule}：登录上下文定义；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-基于WebSocket，Spring开发消息系统后台" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/基于WebSocket，Spring开发消息系统后台/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/基于WebSocket，Spring开发消息系统后台/">基于WebSocket，Spring开发消息系统后台</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>更新：2016/01/14，补充基于HTTP流实现comet在服务端一个利用阻塞队列的例子。</p>
<h2 id="1-_为什么需要WebSocket：">1. 为什么需要WebSocket：</h2><p>回答这个首先需要知道一些历史，我们知道HTTP是客户端向服务器请求获取数据的普遍方式，但是它是一种被动性的通信机制。request=response，服务器只有在接受到客户端请求的时候才可能向客户端发送数据。但有时候服务器需要告诉客户端有新的数据应该接受，比如消息，即时聊天等功能，也就是说我们应该需要一种全双工的通信方式，而HTTP的被动性使得这一问题很难解决。</p>
<p>你可能会问webSocket很新啊，在这之前是如果实现类似的功能的呢？下面介绍几种技术用来在在“单连接的HTTP中模拟全双工”的：</p>
<h3 id="解决方案一：频繁轮询：">解决方案一：频繁轮询：</h3><p>客户端以较短的时间间隔向服务器请求新的数据，比如1秒：<br>那么请求过程可能是这样的：</p>
<pre><code>client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">123</span> 有，给你
<span class="number">1</span>s...
client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">0</span> 没有。。。
<span class="number">1</span>s...
client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">0</span> 没有。。。
<span class="number">1</span>s...
...n秒后
client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">123</span> 有，给你
</code></pre><p>显然这种方案产生了大量的请求，其中很多请求是无意义的，造成了大量的浪费。这时你可能会想：要是可以减少连接数就好了，这就是长轮询。</p>
<h3 id="解决方案二：长轮询：">解决方案二：长轮询：</h3><p>HTTP是被动性的，因此想要减少连接数量只能增长连接的时间否则你无法及时返回新的数据。客户端发起一个超时时间较长（比如20秒）的请求，服务器在没有数据的时候并不立即返回，而是以某种方式阻塞（使用阻塞队列神马的），当有数据的时候在返回，或者在时间超时时返回无数据。<br>那么请求过程可能是这样的：</p>
<pre><code>clinet：GET/longPollEndpoint
server：<span class="number">200</span> OK Content-Length:<span class="number">123</span>有，给你
client：GET/longPollEndpoint 
server检查没有数据，阻塞等待
.
. <span class="number">20</span>秒
.
server：<span class="number">200</span> OK Content-Length:<span class="number">0</span> 没有数据。。。
client：GET/longPollEndpoint 
.
. <span class="number">15</span>秒
.
server：<span class="number">200</span> OK Content-Length:<span class="number">123</span>有，给你
</code></pre><p>可以看到，连接的数量大大减少了，但是存在连接几乎一直存在啊，这样会不会有什么问题？有，首先，HTTP1.1规范中对同一主机名的访问是有数量限制的：不超过2个，也就是我们少了一半可以请求其他数据的连接资源。。。再有，如果在服务器没有数据阻塞的时候客户端又有新数据要请求时怎么办，只能另起一个并行的请求去做了。</p>
<h4 id="HTTP流实现：">HTTP流实现：</h4><p>服务端采用阻塞队列的时间：使用AsyncContext异步处理写个例子：<br>使用一个简单的生产者-消费者模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext asyncContext = req.startAsync();</span><br><span class="line"></span><br><span class="line">      asyncContext.setTimeout(<span class="number">6000000</span>); <span class="comment">//默认是Servlet的超时时间，默认30秒</span></span><br><span class="line">   <span class="comment">/* 略，可以设置AsyncListener等等 */</span></span><br><span class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">      asyncContext.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="annotation">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                      String msg = queue.take();</span><br><span class="line">                      PrintWriter out;</span><br><span class="line">                      (out = asyncContext.getResponse().getWriter()).println(msg);</span><br><span class="line">                      out.flush();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">              &#125;</span><br><span class="line">              asyncContext.complete(); <span class="comment">//任务完成调用onComplete，通知，调用回调函数</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> DataHandler(queue)).start();</span><br></pre></td></tr></table></figure></p>
<p>生产者代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DataHandler</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.queue = queue;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="annotation">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   queue.put(<span class="string">"new msg!"</span>);</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   logger.error(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在浏览器（chrome）地址栏请求，一般默认是notimeout，因此超时时间就是我在服务端设置的时间（如果不设置，AsyncContext的默认时间是ServletContext的超时时间，如果设置为0或负数，就是notimeout）。<br>这就是一个长时间（超时时间）保持的HTTP连接，在服务器方法超时或方法返回之前HTTP连接不会关闭，通过HTTP流向客户端发送。</p>
<h3 id="解决方案三：分块编码：">解决方案三：分块编码：</h3><p>这个方案可能是为了解决浏览器长时间等待而创建的，一直等待响应对浏览器来说并不友好，但我觉得这个方案有些奇葩，分块的思想大致是这样的，既然我发现有很多时间都是在等待，那我有数据的时候就不一次性返回给客户端了，把它分割分几次返回给客户端，这样看上去浏览不就是一直在请求和获取数据吗。。。这个方法并没有什么本质上的改观，如果某些时候需要返回的数据大量产生呢，那我们是不是需要动态维护块的大小适应数据流，显然这是一件不简单的事情，又需要额外的成本。</p>
<h3 id="解决方案四：Applet和Adobe_Flash：">解决方案四：Applet和Adobe Flash：</h3><p>Java applet是一个“久远”的概念，它是一种内嵌在浏览器中的Java 小程序和Flash一样，它们不再使用HTTP，而是TCP套接字来实现全双工的通信，但是它们并不安全，没有构建什么安全协议，而写资源消耗，你懂的。。。尤其是移动互联网出现后很多移动端的浏览器并不支持它们，所以。。。</p>
<h1 id="2-_WekSocket简介：">2. WekSocket简介：</h1><p>说了这么多，你应当发现这是个难搞的问题啊，是的，HTTP的被动性本质使得在它的框架内我们无法实现真正的全双工通信。WebSocket正是解决这一问题的方案。<br>那么如何从一个HTTP连接机制中的通信环境发起一个WebSocket连接呢？</p>
<p>利用HTTP/1.1的升级特性迁移到WebSocket协议：</p>
<pre><code>GET /chat HTTP/<span class="number">1.1</span>
<span class="label">Host:</span> server.example.com
<span class="label">Upgrade:</span> websocket
<span class="label">Connection:</span> Upgrade
<span class="keyword">Sec</span>-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
<span class="keyword">Sec</span>-WebSocket-Protocol: chat, superchat
<span class="keyword">Sec</span>-WebSocket-Version: <span class="number">13</span>
<span class="label">Origin:</span> http://example.com
<span class="label">Connection:</span> Upgrade表示我要升级成其他的协议；
<span class="label">Upgrade:</span>websocket表示我要升级层websocket，服务器你支持不？
<span class="keyword">Sec</span>-WebSocket-Key，客户端随机生成的，服务器之后会拿这个进行加密作为标识之一。
<span class="keyword">Sec</span>-WebSocket-Protocol：区分同一URL下需要使用的不同协议。
<span class="keyword">Sec</span>-WebSokcet-Version：版本号。
服务器会返回：
HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols
<span class="label">Upgrade:</span> websocket
<span class="label">Connection:</span> Upgrade
<span class="keyword">Sec</span>-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
<span class="keyword">Sec</span>-WebSocket-Protocol: chat
<span class="keyword">Sec</span>-WebSocket-Accept：看我加密了你发来的随机码，你认识我了吧！
<span class="keyword">Sec</span>-WebSocket-Protocol：我支持chat协议；
</code></pre><p>注意，HTTP的状态码是101, Switch Protocols，ok，到这里，我们从原来的HTTP协议已经建立了一个持久的、全双工的TCP套接字协议，</p>
<p>PS：有些时候，服务器的特定资源只接受HTTP升级请求，这时如果请求为发起升级，会返回426 Upgrade Required；如果客户端不支持就返回400咯。</p>
<h3 id="那WebSocket到底有什么好处呢？">那WebSocket到底有什么好处呢？</h3><p>在握手之后，信道已经建立起来了，ws和wss分别对应与http和https（看我们已经可以使用新的协议了）。<br>这时已经是一个全双工，持久的信道了，它有这些优点：<br>（1）使用HTTP来进行握手，可以很方便的继承与浏览器和HTTP服务器中；<br>（2）ws和wss与http和https一样同样对应与80和443端口，一般防火墙是不会阻止的；<br>（3）心跳机制，一般用来保持连接的，两边都不说话时，也通过心跳包来保持连接～；<br>（4）不再收到2个连接的限制了；<br>（5）可以安全进行跨域连接了，HTTP的origin会限制ajax和XMLHttpRequest跨域；<br>值得一提的是使用webSocket提供高清视频流更为强大；</p>
<h1 id="3-_Java中的WebSocket：">3. Java中的WebSocket：</h1><p>当然使用H5中的js的webSocket api是浏览器的方法，这里为了演示我就只介绍Java的WebSocket API了，同样分为客户端和服务端两部分。</p>
<p>maven依赖：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>集成了客户端和服务端，如果你只需要客户端可以使用 javax.websocket-client-api。<br>这里使用的是provided，显然和其他J2EE规范一样我们在开发时也只需要使用api面向接口开发，tomcat8.0中提供了websocket的实现。</p>
<h2 id="3-1_WebSocket_API：">3.1 WebSocket API：</h2><p><strong>客户端API：</strong><br>有几个关键的接口：<br><strong>ContainerProvider</strong>：这是服务提供者接口，不同的实现者可以通过实现该接口来构建服务（webSocket）的提供者，通过提供者注册接口来提供具体的服务，如果你不清楚这种模式可以参看《Effective Java》中的第一条；<br><strong>WebSocketContainer</strong>：这就我们需要的webSocket“服务”了，通过ContainerProvider.getContainer获得，通过他的connectToServer方法可以返回Session；<br><strong>Session</strong>：使用session我们一发送数据，关闭会话；<br><strong>RemoteEndPoint</strong>：我的理解是一个回调接口，它代表的实例由WebContainer管理，就像Servlet和Servlet容器一样；</p>
<p><strong>服务器API：</strong><br>serverContainer继承了WebSocketContainer，你可以通过ServletContext.getArribute(“javax.websocket.ServerContainer”)来获取它，但你并不需要这么做，你只需要在POJO上添加一个@ServerEndpoint，webSocket会扫面它创建实例，默认是每一个连接都会创建一个EndPoint实例，理解这一点很重要，因为在和Spring的自动注入结合后会产生问题（如果你不是用Spring WebSocket配置的话）。</p>
<p>EndPoint有四个回调方法：@OnOpen，@OnMessage，@OnClose，@OnError，你可以通过注解在POJO中标注。</p>
<h1 id="4-_基于Spring_webSocket开发消息系统：">4. 基于Spring webSocket开发消息系统：</h1><h2 id="4-1_服务端实现：">4.1 服务端实现：</h2><pre><code><span class="annotation">@ServerEndpoint</span>(value = <span class="string">"/message/{userId}"</span>, configurator = SpringConfigurator.class)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServer</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Session&gt; userSessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();
    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();
    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger();

    <span class="annotation">@Inject</span>
    <span class="keyword">private</span> MessageService messageService;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
        userSessions.clear();
        userSessions = <span class="keyword">null</span>;
    }

    <span class="comment">/**
     * Get unread messages by userId when session opened.
     *
     * <span class="doctag">@param</span> session session get from WebSocketContain.connectToServer
     * <span class="doctag">@param</span> userId user's ID
     */</span>
    <span class="annotation">@OnOpen</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onOpen(Session session, <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
        logger.debug(<span class="string">"open session: userId:"</span> + userId + <span class="string">" sessionId"</span> + session.getId());

        List&lt;BMessageEntity&gt; unReadMessages =
                <span class="keyword">this</span>.messageService.getMessageByIsRead(userId, BMessageState.UNREAD);

        <span class="keyword">if</span>(unReadMessages.size() &gt; <span class="number">0</span>) {
            <span class="keyword">this</span>.sendJsonMessage(session, userId, unReadMessages);
        }

        userSessions.put(userId, session);
    }

    <span class="comment">/**
     * client should send new BMessageEntity to this server, and opMessage() save data to dataBase
     *
     * <span class="doctag">@param</span> session session get from WebSocketContain.connectToServer
     * <span class="doctag">@param</span> byteBuffer accept messages
     */</span>
    <span class="annotation">@OnMessage</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onMessage(Session session, ByteBuffer byteBuffer,
                          <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
        CharBuffer charBuffer = Charset.forName(<span class="string">"utf8"</span>).decode(byteBuffer);
        String message = charBuffer.toString();

        <span class="keyword">try</span> {
            MessageJson messageJson = mapper.readValue(message, MessageJson.class);

            <span class="keyword">long</span> replyUserId = messageJson.getReplyUserId();

            <span class="comment">//save new message</span>
            BMessageEntity messageEntity = <span class="keyword">this</span>.messageService.saveMessage(userId, replyUserId, messageJson.getMessage());
            <span class="keyword">if</span>(messageEntity != <span class="keyword">null</span>) {
                <span class="comment">//send</span>
                Session replySession = userSessions.get(replyUserId);
                <span class="keyword">if</span>(replySession != <span class="keyword">null</span>) {
                    <span class="keyword">this</span>.sendJsonMessage(replySession, userId, messageEntity);
                }
            }
        } <span class="keyword">catch</span> (IOException e) {
            logger.<span class="keyword">error</span>(e);
        }
    }

    <span class="annotation">@OnError</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable e)</span> </span>{
        logger.<span class="keyword">error</span>(<span class="string">"sessionId:"</span> + session.getId() + <span class="string">" "</span> + e);
    }

    <span class="annotation">@OnClose</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onClose(Session session, <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
        Session session1 = userSessions.get(userId);
        <span class="keyword">if</span>(session1 != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                <span class="keyword">if</span>(session1.isOpen())
                    session1.close();
            } <span class="keyword">catch</span> (IOException e) {
                logger.<span class="keyword">error</span>(e);
            } <span class="keyword">finally</span> {
                userSessions.remove(userId);
            }
        }
    }

    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">sendJsonMessage</span><span class="params">(Session session, <span class="keyword">long</span> userId, Object object)</span> </span>{
        <span class="keyword">try</span> {
            session.getBasicRemote()
                    .sendText(MessageServer.mapper.writeValueAsString(object));
        } <span class="keyword">catch</span> (IOException e) {
            <span class="keyword">this</span>.handleException(e, userId);
        }
    }

    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Throwable throwable, <span class="keyword">long</span> userId)</span> </span>{
        <span class="keyword">try</span>(Session session = userSessions.get(userId)) {
            session.close(<span class="keyword">new</span> CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, throwable.toString()));
        } <span class="keyword">catch</span> (IOException e) {
            logger.<span class="keyword">error</span>(e);
        } <span class="keyword">finally</span> {
            userSessions.remove(userId);
        }
    }

    <span class="comment">/**
     * custom configurator, TODO collect some require, then use this configurator
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndpointConfigurator</span> <span class="keyword">extends</span> <span class="title">SpringConfigurator</span> </span>{

    }
}
</code></pre><p>首先，使用了configurator = SpringConfigurator.class，SpringConfigurator取代了默认的Configurator，它将使得我们可以正确使用Spring进行实例化和注入，如果没有这个设置，你会得到NullPointException，因为它是有WebSocket实现实例化，它并不会帮我们注入哦，这也是上面提到的问题。</p>
<pre><code>@<span class="function"><span class="title">ServerEndpoint</span><span class="params">(value = <span class="string">"/message/{userId}"</span>, configurator = SpringConfigurator.class)</span></span>
</code></pre><p>定义一个HashMap存放session，用来向指定的user发送消息，ObjectMapper是用来转换json格式的。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">Long</span>, Session&gt; userSessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();
<span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();
</code></pre><p>打开连接是，我从数据库中取出未读消息，返回给客户端，并将session存到map中：</p>
<pre><code><span class="keyword">@OnOpen</span>
<span class="keyword">public</span> <span class="keyword">void</span> onOpen(Session session, <span class="keyword">@PathParam</span>(<span class="string">"userId"</span>) <span class="built_in">long</span> userId) {
    logger.<span class="keyword">debug</span>(<span class="string">"open session: userId:"</span> + userId + <span class="string">" sessionId"</span> + session.getId());

    List&lt;BMessageEntity&gt; unReadMessages =
            <span class="keyword">this</span>.messageService.getMessageByIsRead(userId, BMessageState.UNREAD);

    <span class="keyword">if</span>(unReadMessages.size() &gt; <span class="number">0</span>) {
        <span class="keyword">this</span>.sendJsonMessage(session, userId, unReadMessages);
    }

    userSessions.put(userId, session);
}
</code></pre><p>接受到消息后，保存消息到数据库，然后在map中查找对方的session，如果存在的话（对方有可能不在线哦），将这条消息发送给他。</p>
<pre><code><span class="annotation">@OnMessage</span>
<span class="keyword">public</span> <span class="keyword">void</span> onMessage(Session session, ByteBuffer byteBuffer,
                      <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
    CharBuffer charBuffer = Charset.forName(<span class="string">"utf8"</span>).decode(byteBuffer);
    String message = charBuffer.toString();

    <span class="keyword">try</span> {
        MessageJson messageJson = mapper.readValue(message, MessageJson.class);

        <span class="keyword">long</span> replyUserId = messageJson.getReplyUserId();

        <span class="comment">//save new message</span>
        BMessageEntity messageEntity = <span class="keyword">this</span>.messageService.saveMessage(userId, replyUserId, messageJson.getMessage());
        <span class="keyword">if</span>(messageEntity != <span class="keyword">null</span>) {
            <span class="comment">//send</span>
            Session replySession = userSessions.get(replyUserId);
            <span class="keyword">if</span>(replySession != <span class="keyword">null</span>) {
                <span class="keyword">this</span>.sendJsonMessage(replySession, userId, messageEntity);
            }
        }
    } <span class="keyword">catch</span> (IOException e) {
        logger.<span class="keyword">error</span>(e);
    }
}
</code></pre><p>PS：这时，还是有WebSocket实现来创建它的，依然是一个连接一个实例，它也并不在Spring的单例bean注册表中，因此我们也无法将它注入到其他bean中，但是你可以在@Configuration配置中添加一个单例：</p>
<pre><code><span class="annotation">@Bean</span>
<span class="keyword">public</span> <span class="function">MessageServer <span class="title">messageServer</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">new</span> MessageServer();
}
</code></pre><p> 这样也很省资源呢，但是注意线程安全。</p>
<h2 id="4-2_客户端实现：">4.2 客户端实现：</h2><p>我这里使用了两个Servlet实例来模拟两个客户端，实现@ClientEndpoint，注意@ClientEndpoint并不会有websocket实例化，因此我们可以放心的在servlet上直接添加：</p>
<pre><code><span class="annotation">@ClientEndpoint</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger();

    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();

    <span class="keyword">private</span> Session session;
    <span class="keyword">private</span> <span class="keyword">long</span> userId;

    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{
        userId = Long.valueOf(<span class="keyword">this</span>.getInitParameter(<span class="string">"userId"</span>));

        String path = <span class="keyword">this</span>.getServletContext().getContextPath() + <span class="string">"/message/"</span> +
                userId;

        logger.debug(path);

        <span class="keyword">try</span> {
            URI uri = <span class="keyword">new</span> URI(<span class="string">"ws"</span>, <span class="string">"localhost:8080"</span>, path, <span class="keyword">null</span>, <span class="keyword">null</span>);
            <span class="keyword">this</span>.session = ContainerProvider.getWebSocketContainer()
                    .connectToServer(<span class="keyword">this</span>, uri);
            logger.debug(session.getId());
        } <span class="keyword">catch</span> (IOException | URISyntaxException | DeploymentException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Cannot connect to "</span> + path + <span class="string">"."</span> + e);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">this</span>.session.close();
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>{
        MessageJson messageJson = <span class="keyword">new</span> MessageJson();
        messageJson.setMessage(req.getParameter(<span class="string">"message"</span>));
        messageJson.setReplyUserId(Long.valueOf(req.getParameter(<span class="string">"replyUserId"</span>)));

        <span class="keyword">try</span>(OutputStream outputStream = <span class="keyword">this</span>.session.getBasicRemote().getSendStream()) {
            mapper.writeValue(outputStream, messageJson);
            outputStream.flush();
        }
        resp.getWriter().append(<span class="string">"OK"</span>);
    }

    <span class="annotation">@OnMessage</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>{
        System.out.println(message);
    }

    <span class="annotation">@OnClose</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(CloseReason reason)</span> </span>{
        CloseReason.CloseCode code = reason.getCloseCode();


    }
}
</code></pre><p>在部署描述符中，部署两个实例，它们分别有初始化参数，userId，代表两个用户～：</p>
<pre><code><span class="variable">&lt;servlet&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client1<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;servlet-class&gt;</span>com.yjh.cg.site.server.ClientServlet<span class="variable">&lt;/servlet-class&gt;</span>
        <span class="variable">&lt;init-param&gt;</span>
            <span class="variable">&lt;param-name&gt;</span><span class="keyword">user</span>Id<span class="variable">&lt;/param-name&gt;</span>
            <span class="variable">&lt;param-value&gt;</span><span class="number">1</span><span class="variable">&lt;/param-value&gt;</span>
        <span class="variable">&lt;/init-param&gt;</span>
    <span class="variable">&lt;/servlet&gt;</span>
    <span class="variable">&lt;servlet-mapping&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client1<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;url-pattern&gt;</span>/client1<span class="variable">&lt;/url-pattern&gt;</span>
    <span class="variable">&lt;/servlet-mapping&gt;</span>

    <span class="variable">&lt;servlet&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client2<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;servlet-class&gt;</span>com.yjh.cg.site.server.ClientServlet<span class="variable">&lt;/servlet-class&gt;</span>
        <span class="variable">&lt;init-param&gt;</span>
            <span class="variable">&lt;param-name&gt;</span><span class="keyword">user</span>Id<span class="variable">&lt;/param-name&gt;</span>
            <span class="variable">&lt;param-value&gt;</span><span class="number">2</span><span class="variable">&lt;/param-value&gt;</span>
        <span class="variable">&lt;/init-param&gt;</span>
    <span class="variable">&lt;/servlet&gt;</span>
    <span class="variable">&lt;servlet-mapping&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client2<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;url-pattern&gt;</span>/client2<span class="variable">&lt;/url-pattern&gt;</span>
    <span class="variable">&lt;/servlet-mapping&gt;</span>
</code></pre><p>在servlet初始化的时候，我们向服务器请求建立连接，获取session对象：</p>
<pre><code>URI uri = <span class="keyword">new</span> URI(<span class="string">"ws"</span>, <span class="string">"localhost:8080"</span>, path, <span class="literal">null</span>, <span class="literal">null</span>);
          <span class="keyword">this</span>.session = ContainerProvider.getWebSocketContainer()
                  .connectToServer(<span class="keyword">this</span>, uri);
</code></pre><p>在doGet方法中我将http请求“包装”成websocket消息发送到服务器，当然这只是为了模拟：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>{
    MessageJson messageJson = <span class="keyword">new</span> MessageJson();
    messageJson.setMessage(req.getParameter(<span class="string">"message"</span>));
    messageJson.setReplyUserId(Long.valueOf(req.getParameter(<span class="string">"replyUserId"</span>)));

    <span class="keyword">try</span>(OutputStream outputStream = <span class="keyword">this</span>.session.getBasicRemote().getSendStream()) {
        mapper.writeValue(outputStream, messageJson);
        outputStream.flush();
    }
    resp.getWriter().append(<span class="string">"OK"</span>);
}
</code></pre><h1 id="5-_模拟：">5. 模拟：</h1><p>user2发送消息给user1：<br><a href="http://localhost:8080/client2?message=我是谁&amp;replyUserId=2" target="_blank" rel="external">http://localhost:8080/client2?message=我是谁&amp;replyUserId=2</a></p>
<p>user1收到消息：我是谁</p>
<p>user1回复：Zerohuan<br><a href="http://localhost:8080/client1?message=Zerohuan&amp;replyUserId=1" target="_blank" rel="external">http://localhost:8080/client1?message=Zerohuan&amp;replyUserId=1</a></p>
<p>好了，控制台的log我就不一一贴了，碎觉去了。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考和求解/">思考和求解</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-关于Java类初始化和实例化中的2个“雷区”" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/关于Java类初始化和实例化中的2个“雷区”/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/关于Java类初始化和实例化中的2个“雷区”/">关于Java类初始化和实例化中的2个“雷区”</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在考虑类初始化时，我们都知道进行子类初始化时，如果父类没有初始化要先初始化子类。然而事情并没有一句话这么简单。</p>
<p><strong>首先看看Java中初始化触发的条件：</strong><br>（1）在使用new实例化对象，访问静态数据和方法时，也就是遇到指令：new，getstatic/putstatic和invokestatic时；<br>（2）使用反射对类进行调用时；<br>（3）当初始化一个类时，父类如果没有进行初始化，先触发父类的初始化；<br>（4）执行入口main方法所在的类；<br>（5）JDK1.7动态语言支持中方法句柄所在的类，如果没有初始化触发起初始化；</p>
<p>经过编译后生成一个<code>&lt;clinit&gt;</code>方法，类的初始化就在这个方法中进行，该方法只执行，由JVM保证这一点，并进行同步控制；</p>
<p>其中条件（3），从方法调用的角度来看，是子类的<code>&lt;clinit&gt;</code>会在开始时递归的调用父类的<code>&lt;clinit&gt;</code>，这类似与我们在子类构造器中必须首先调用父类的构造器；</p>
<p>但需要注意的是“触发”并不是完成初始化，这意味着有可能子类的初始化会提前于父类初始化结束，这就是“危险”的所在。</p>
<h2 id="1-_一个类初始化的例子：">1. 一个类初始化的例子：</h2><p>这个例子我使用一个外围类包含2个有继承关系的静态成员类，因为外围类的初始化和静态成员类没有因果关系，因此这样展示是安全和方便的；<br>父类A和子类B分别包含main函数，由上面的触发条件（4）可知，通过分别调用这个两个main函数来触发不同的类初始化路径；<br>这个例子的问题在于父类包含子类的static引用并在定义处进行初始化的问题：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WrapperClass</span> {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span> {
        <span class="keyword">static</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"类A初始化开始..."</span>);
        }
        <span class="comment">//父类包含子类的static引用</span>
        <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();
        <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> aInt = <span class="number">9</span>;

        <span class="keyword">static</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"类A初始化结束..."</span>);
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{

        }
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span> {
        <span class="keyword">static</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"类B初始化开始..."</span>);
        }
        <span class="comment">//子类的域依赖于父类的域</span>
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> bInt = <span class="number">9</span> + A.aInt;

        <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>) </span>{
            <span class="comment">//构造器依赖类的static域</span>
            System.<span class="keyword">out</span>.println(<span class="string">"类B的构造器调用 "</span> + <span class="string">"bInt的值"</span> + bInt);
        }

        <span class="keyword">static</span> {
            System.<span class="keyword">out</span>.println(<span class="string">"类B初始化结束... "</span> + <span class="string">"aInt的值："</span> + bInt);
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{

        }
    }
}
</code></pre><p>情景一：入口为类B的main函数时输出结果：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> 类A初始化开始...
 <span class="keyword">*</span> 类B的构造器调用 bInt的值0
 <span class="keyword">*</span> 类A初始化结束...
 <span class="keyword">*</span> 类B初始化开始...
 <span class="keyword">*</span> 类B初始化结束... aInt的值：18
 <span class="keyword">*</span>/
</code></pre><p><strong>分析</strong>：可以看到，main函数的调用触发了类B的初始化，进入类B的<code>&lt;clinit&gt;</code>方法，类A作为其父类先开始初始化进入了A的<code>&lt;clinit&gt;</code>方法，其中有一个语句<code>new B();</code>这时会进行B的实例化，这是已经在类B的<code>&lt;clinit&gt;</code>中了，main线程已经获得锁开始执行类B的<code>&lt;clinit&gt;</code>，我们开头说过JVM会保证一个类的初始化方法只被执行一次，JVM收到new指令后不会再进入类B的<code>&lt;clinit&gt;</code>方法而是直接进行实例化，但是此时类B还没有完成类初始化，所以可以看到bInt的值为0（这个0是类加载中准备阶段分配方法区内存后进行的置零初始化）；<br>因此，可以得出，再父类中包含子类类型的static域并进行赋值动作，会可能导致子类实例化在类初始化完成前进行；</p>
<p>情景二：入口为类A的main函数时输出结果：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> 类A初始化开始...
 <span class="keyword">*</span> 类B初始化开始...
 <span class="keyword">*</span> 类B初始化结束... aInt的值：9
 <span class="keyword">*</span> 类B的构造器调用 bInt的值9
 <span class="keyword">*</span> 类A初始化结束...
 <span class="keyword">*</span>/
</code></pre><p><strong>分析</strong>：经过情景一的分析，我们知道，由类B的初始化触发类A的初始化，会导致类A中类变量b的实例化在类B初始化完成前进行，那如果先初始化类A是不是就可以在类变量实例化的时候先触发类B的初始化，从而使得初始化在实例化前呢？答案是肯定的，但是这仍然有问题。<br>根据输出，可以看到，类B的初始化在类A的初始化完成前进行了，这导致了像类变量aInt的变量在类B初始化完成后才进行初始化，所以类B中的域bInt获取到的aInt的值是“0”，而不是我们预期的“18”；</p>
<h2 id="结论：">结论：</h2><p>综上，可以得出，在父类中包含子类类型的类变量，并在定义出进行实例化是非常危险的行为，具体情况可能不会向例子一样直白，调用方法在定义处赋值一样隐含着危险，即使要包含子类类型的static域，也应该通过static方法进行赋值，因为JVM可以保证在static方法调用前完成所有的初始化动作（当然这种保证也是你不应该包含static B b = new B();这样的初始化行为）；</p>
<h1 id="2-_一个实例化的例子：">2. 一个实例化的例子：</h1><p>首先需要知道对象创建的过程：<br>（1）遇到new指令，检查类是否完成了加载，验证，准备，解析，初始化（解析过程就是符号引用解析成直接引用，比如方法名就是一个符号引用，可以在初始化完成后使用这个符号引用的时候进行，正是为了支持动态绑定），没有完成先进行这些过程；<br>（2）分配内存，采用空闲列表或者指针碰撞的方法，并将新分配的内存“置零”，因此所有的实例变量在此环节都进行了一次默认初始化为0（引用为null）的过程；<br>（3）执行<code>&lt;init&gt;</code>方法，包括检查调用父类的<code>&lt;init&gt;</code>方法（构造器），实例变量定义出的赋值动作，实例化器顺序执行，最后调用构造器中的动作。</p>
<p>这个例子可能更为大家所熟知，也就是它违反了“不要在构造器，clone方法和readObject方法中调用可被覆盖的方法”。其原因就在于Java中的多态，也就是动态绑定。<br>父类A的构造器中包含一个protected方法，类B是其子类。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongInstantiation</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{
        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>{
            doSomething();
        }

    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"A's doSomething"</span>);
    }
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> bInt = <span class="number">9</span>;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"B's doSomething, bInt: "</span> + bInt);
    }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    B b = <span class="keyword">new</span> B();
}
</code></pre><p>}<br>输出结果：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> B's doSomething, bInt: 0
 <span class="keyword">*</span>/
</code></pre><p><strong>分析</strong>：首先需要知道，在没有显示提供构造器时Java编译器会生成默认构造器，并在开始处调用父类的构造器，因此类B的构造器开始会先调用类A的构造器。<br>类A中调用了protected方法doSomething，从输出结果中我们看到实际上调用的是子类的方法实现，而此时子类的实例化还未开始，因此bInt并没有如“预期”那样是9,而是0；</p>
<p>这就是由于动态绑定，doSomething是一个protected方法，因此它是通过invokevirtual指令调用的，该指令根据对象实例的类型找到对应的方法实现（这里就是B的实例对象，对应方法就是类B的方法实现）执行，故而有此结果。</p>
<h2 id="结论">结论</h2><p>正如前面说的“不要在构造器，clone方法和readObject方法中调用可被覆盖的方法”；<br>PS：在构造器中调用可被覆盖的方法的另一个风险是造成对象在构造过程中“逸出”，导致线程不安全；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考和求解/">思考和求解</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java基础知识总结（四）——异常与异常处理表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/Java基础知识总结（四）——异常与异常处理表/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/Java基础知识总结（四）——异常与异常处理表/">Java基础知识总结（四）——异常与异常处理表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要想弄清楚异常的一些知识点，比如try/finally的return，异常的丢失等等，光记住“形式”是不够的，不从字节码异常表的层面分析是很难真正的将一些问题弄明白。</p>
<h2 id="先吃两个栗子">先吃两个栗子</h2><p>（1）判断程序的返回值：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hasException</span><span class="params">()</span> </span>{
        <span class="keyword">int</span> x;
        <span class="keyword">try</span> {
            x = <span class="number">1</span>;
            <span class="keyword">return</span> x;
        } <span class="keyword">catch</span> (Exception e) {
            x = <span class="number">2</span>;
            <span class="keyword">return</span> x;
        } finally {
            x = <span class="number">3</span>;
        }
    }
</code></pre><p>结果：<br>（1）未发生异常，返回1；<br>（2）发生Exception异常返回2；<br>（3）发生其他异常，没有返回值；</p>
<p>以正常返回为例分析：<br>Java中返回值实际上是由一个returnValue变量保存的，编译器会将finally中的逻辑查到return之前，通过查看字节码可以知道，变量x等于1时，赋值给了returnValue变量，之后才赋值为3的，因此最后返回3。</p>
<pre><code><span class="number">0</span>: iconst_1 <span class="comment">//常量1压入操作数栈</span>
<span class="number">1</span>: istore_1 <span class="comment">//x=1,保存到局部变量表slot 1</span>
<span class="number">2</span>: iload_1 <span class="comment">//局部变量表slot 1也就是x压入操作数栈</span>
<span class="number">3</span>: istore_2 <span class="comment">//栈顶值“1”保存到slot 2，returnValue = 1</span>
<span class="number">4</span>: iconst_3 <span class="comment">//常量3压入操作数栈</span>
<span class="number">5</span>: istore_1 <span class="comment">//栈顶值“3”保存到局部变量表slot 1, x=3</span>
<span class="number">6</span>: iload_2 <span class="comment">//returnValue压入操作数栈</span>
<span class="number">7</span>: ireturn <span class="comment">//返回栈顶元素，returnValue的值</span>
</code></pre><p>（2） finally中的return：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">finallyReturn</span><span class="params">()</span> </span>{
    <span class="keyword">int</span> x;
    <span class="keyword">try</span> {
        x = <span class="number">1</span>;
        <span class="keyword">return</span> x;
    } <span class="keyword">catch</span>(Exception e) {
        x = <span class="number">2</span>;
        <span class="keyword">return</span> x;
    } finally {
        x = <span class="number">3</span>;
        <span class="keyword">return</span> <span class="number">3</span>;
    }
}
</code></pre><p>结果：<br>正常返回或者Exception异常或者其他异常都返回3；</p>
<p>分析：<br>正如前叙，编译器会将finally中的逻辑插入各个分支之中。因此try和catch中的return都不会执行到（被编译器忽略了）。查看字节码：</p>
<pre><code><span class="number">6</span>: iconst_3 <span class="comment">//常量3压入操作数栈</span>
<span class="number">7</span>: ireturn <span class="comment">//返回栈顶元素3</span>
</code></pre><p>PS：<br>能看懂字节码，很多问题轻松弄明白。<br>上述字节码使用javap -verbose -private xxxx输出查看。<br>后面finally子句小节中有更系统的解释。</p>
<h2 id="1-_异常体系">1. 异常体系</h2><p><strong>基类</strong>：Throwable；<br><strong>子类划分</strong>：Error（内部错误/资源耗尽错误），Exception（又又子类RuntimeException）；</p>
<p><strong>是否为受检查异常：</strong><br><strong>checked异常</strong>：Exception，因为为一些不可预测的情况导致的异常，checked的目的是为了让我们能够给出相应的恢复手段；<br><strong>unchecked异常</strong>：Error和RunntimeException，后者一般是“程序员自己的问题导致的”；</p>
<h3 id="声明checked异常：">声明checked异常：</h3><p>throws关键字；<br>class文件中可以通过方法表的Exceptions属性查看（这是javap输出的，实际上Exceptions中保存的是异常类全限定名在常量池中的索引）：</p>
<pre><code>Exceptions:
throws java<span class="class">.io</span><span class="class">.IOException</span>, java<span class="class">.sql</span><span class="class">.SQLException</span>
</code></pre><h3 id="声明异常与继承：">声明异常与继承：</h3><p> 子类重写父类方法，如果父类方法声明了异常，子类方法可以：<br> （1）不声明异常；<br> （2）声明父类方法中异常或其子类异常；</p>
<pre><code><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> {</span>
    <span class="keyword">protected</span> void f() <span class="keyword">throws</span> <span class="type">IOException</span> {}
}

<span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SuperClass</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void f() <span class="keyword">throws</span> <span class="type">ZipException</span> {}
}

<span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SuperClass</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void f() {}
}
</code></pre><h2 id="2-_捕获异常">2. 捕获异常</h2><p>在catch语句中重新包装异常，通过设置initCause的方式保证不丢失原始异常：</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">catchAndThrowNew</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{
    <span class="keyword">try</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException();
    } <span class="keyword">catch</span> (SQLException e) {
        Throwable se = <span class="keyword">new</span> ServletException();
        se.initCause(e);
        <span class="keyword">throw</span> se;
    }
}
</code></pre><h3 id="finally子句：">finally子句：</h3><h4 id="（1）与return的关系：">（1）与return的关系：</h4><p>正如开头的例子：<br>当try子句中有return语句，编译器将产生一个中间变量“returnValue”，保存try中return语句中变量在try语句中的最后赋值；<br>当finally子句中有return语句，将“覆盖”try中的return；<br>当finally子句中没有return语句，try中的return因为有returnValue值，不会受finally的影响；</p>
<h4 id="（2）嵌套的finally子句：">（2）嵌套的finally子句：</h4><p>（1）如果不同层次的finally子句中包含return，内层的return语句将被忽略，最外层的return才有效；<br>（2）如果一个内层的finally子句中包含return，外层还有finally子句（没有return），编译器同样会生成一个“returnValue”中间变量，保证内层的return逻辑，可见Java设计的思想在于保证“可见”逻辑的正确性；<br>（3）执行顺序是先内后外；</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nestedTryCatch</span><span class="params">()</span> </span>{
    <span class="keyword">int</span> x;
    <span class="keyword">try</span> {
        <span class="keyword">try</span> {
            x = <span class="number">2</span>;
        } finally {
            x = <span class="number">3</span>;
            <span class="keyword">return</span> x;
        }
    } finally {
        x = <span class="number">4</span>;
        <span class="keyword">return</span> x;
    }
}
</code></pre><h4 id="（3）finally子句与AutoClosable接口：">（3）finally子句与AutoClosable接口：</h4><p>JSE 7中提供了“try-with-resources”的简化形式：</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryWithResources</span>(<span class="params"></span>) throws IOException </span>{
    <span class="keyword">try</span>(InputStream <span class="keyword">in</span> = <span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>])) {
        <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">in</span>))) {

        }
    }
}
</code></pre><p><strong>注意：带资源的try语句也可以有自己的catch和finally，但是要在资源关闭之后执行。</strong></p>
<h4 id="（4）finally与丢失异常：">（4）finally与丢失异常：</h4><p>情形1：finally中的新异常：</p>
<pre><code><span class="keyword">try</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();
} <span class="keyword">finally</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();
}
</code></pre><p>情形2：finally中的return：</p>
<pre><code><span class="keyword">try</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();
} <span class="keyword">finally</span> {
    <span class="keyword">return</span>;
} 
</code></pre><p>情形3：finally中没有新异常和return：</p>
<pre><code><span class="keyword">try</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();
} <span class="keyword">finally</span> {
    <span class="keyword">int</span> x = <span class="number">3</span>;
}
</code></pre><h4 id="字节码分析：">字节码分析：</h4><p>首先，athrow指令是将栈顶异常引用抛出：<br>（1）情况1的字节码：</p>
<pre><code>Code:
  <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span>
     <span class="number">0</span>: <span class="keyword">new</span>           <span class="preprocessor">#<span class="number">21</span>                 <span class="comment">// class java/lang/IllegalArgumentException</span></span>
     <span class="number">3</span>: dup
     <span class="number">4</span>: invokespecial <span class="preprocessor">#<span class="number">22</span>                 <span class="comment">// Method java/lang/IllegalArgumentException."&lt;init&gt;":()V</span></span>
     <span class="number">7</span>: athrow
     <span class="number">8</span>: astore_1
     <span class="number">9</span>: <span class="keyword">new</span>           <span class="preprocessor">#<span class="number">23</span>                 <span class="comment">// class java/lang/IllegalStateException</span></span>
    <span class="number">12</span>: dup
    <span class="number">13</span>: invokespecial <span class="preprocessor">#<span class="number">24</span>                 <span class="comment">// Method java/lang/IllegalStateException."&lt;init&gt;":()V</span></span>
    <span class="number">16</span>: athrow
  Exception table:
     from    to  target type
         <span class="number">0</span>     <span class="number">9</span>     <span class="number">8</span>   any
</code></pre><p>分析：<br>从异常表中可以看到，0到9行中如果有任何的异常出现，转到8行进行处理，第8行之后就是finally之后的逻辑重新抛出了新的异常；</p>
<p>（2）情形3字节码分析：</p>
<pre><code>Code:
  <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span>
     <span class="number">0</span>: <span class="keyword">new</span>           <span class="preprocessor">#<span class="number">21</span>                 <span class="comment">// class java/lang/IllegalArgumentException</span></span>
     <span class="number">3</span>: dup
     <span class="number">4</span>: invokespecial <span class="preprocessor">#<span class="number">22</span>                 <span class="comment">// Method java/lang/IllegalArgumentException."&lt;init&gt;":()V</span></span>
     <span class="number">7</span>: athrow
     <span class="number">8</span>: astore_1
     <span class="number">9</span>: iconst_3
    <span class="number">10</span>: istore_2
    <span class="number">11</span>: aload_1
    <span class="number">12</span>: athrow
  Exception table:
     from    to  target type
         <span class="number">0</span>     <span class="number">9</span>     <span class="number">8</span>   any
</code></pre><p>分析：异常表的逻辑和情形1是相同的，但是finally的逻辑对应的字节码将局部变量表中的异常引用取出执行了athrow；</p>
<h3 id="因此，可以说finally的return和异常覆盖内层或者try中的return和异常">因此，可以说finally的return和异常覆盖内层或者try中的return和异常</h3><h2 id="3-_堆栈跟踪">3. 堆栈跟踪</h2><p>（1） Throwable的方法：printStackTrace和getStackTrace；<br>（2）Thread.getAllStackTraces()；</p>
<h2 id="4-_异常使用技巧">4. 异常使用技巧</h2><p>（1）不能用异常处理代替逻辑判断，因为异常处理的性能开销较大；<br>（2）不要过分细化异常及处理；<br>（3）不要压制异常，异常要么声明，要么正确在该方法内处理；<br>（4）设计具有意义的自定义异常体系；</p>
<p>PS：其他一些好的做法向《Efftive Java》中说的很详细。</p>
<h2 id="5-_关于Java中的断言和日志">5. 关于Java中的断言和日志</h2><p>就我的经验来看，还是使用开源的框架中的断言（比如Spring Framework中的断言）和日志（比如Log4j）比较合适。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java网络编程小记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/Java网络编程小记/" class="article-date">
  	<time datetime="2015-12-01T06:37:13.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/Java网络编程小记/">Java基础知识总结（六）——网络编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在系统的看Tomcat源码的时候，先动手复习一下Java网络编程的基础知识，实现一个简单的服务器/客户端，并在实现中思考一个服务器需要考虑那些问题，记录下来，看Tomcat源码的时候带着这些问题。</p>
<hr>
<h3 id="积累的问题和思考：">积累的问题和思考：</h3><ol>
<li>异常的处理，如何定义自己的异常体系，像具体协议HTTP的404等异常状态如何分发到对应页面；</li>
<li>怎样设计软件结构，支持NIO和BIO切换，并和Servlet规范结合的；</li>
<li>如何让Java进程成为类似Daemon进程，当前终端退出后不关闭（shell脚本控制？）；</li>
<li>关闭服务器的时候，对于没有完成的连接是如何处理的；</li>
<li>tomcat是如何支持HTTP协议的；</li>
</ol>
<h1 id="1-_Socket和InetAddress">1. Socket和InetAddress</h1><p>套接字连接：<br>需要注意：<br>（1）设置合理的超时时间，包括连接超时和读取超时；<br>（2）这是基于TCP的套接字连接，另外的UDP连接是数据报的形式，是无连接的。</p>
<h3 id="基本用法：">基本用法：</h3><pre><code><span class="comment">//套接字连接</span>
<span class="constant">Socket socket</span> = new Socket(<span class="string">"www.baidu.com"</span>, <span class="number">80</span>); <span class="comment">//在构造函数中连接/阻塞</span>
<span class="comment">//获取输入输出流</span>
<span class="constant">InputStream inputStream</span> = socket.getInputStream();
<span class="constant">OutputStream outputStream</span> = socket.getOutputStream();
<span class="comment">//关闭</span>
socket.close();
</code></pre><h3 id="套接字超时时间：">套接字超时时间：</h3><pre><code><span class="comment">//套接字超时时间</span>
<span class="comment">//建立一个无连接的Socket</span>
Socket socket1 = <span class="keyword">new</span> Socket();
<span class="comment">//设置连接超时时间，超过时间直接返回</span>
socket1.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"www.baidu.com"</span>, <span class="number">80</span>), <span class="number">1000</span>);
<span class="comment">//设置等待读取的超时时间，超时返回InterruptedIOException</span>
socket1.setSoTimeout(<span class="number">5000</span>);
<span class="keyword">BufferedReader</span> reader = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(socket1.getInputStream()));
<span class="keyword">try</span> {
    System.out.<span class="built_in">println</span>(reader.readLine());
} <span class="keyword">catch</span> (InterruptedIOException e) {
    e.printStackTrace();
}
<span class="comment">//检查是否已经连接</span>
out.<span class="built_in">println</span>(socket.isConnected());
out.<span class="built_in">println</span>(socket1.isConnected());
<span class="comment">//是否关闭</span>
out.<span class="built_in">println</span>(socket1.isClosed());
socket1.close();
out.<span class="built_in">println</span>(socket1.isClosed());
</code></pre><h3 id="因特网地址">因特网地址</h3><p><strong>注意</strong>：<br>（1）如果一个主机名对应于多个ip，比如：<br><strong>基于DNS的负载均衡</strong>：<br>为多个ip地址配置相同的域名，客户端请求某个域名服务时，域名服务器采用轮询的方式为客户端选择一个ip地址。为不同的客户端选择不同的服务器，从而实现负载均衡的目的。<br>DNS做负载均衡简单方便，但存在不少问题。<br>a.DNS无法知道解析的服务节点是否有效，若服务节点无效，DNS服务器依然会将域名解析到该节点上，造成访问服务节点无效。<br>b.DNS的缓存时间较长，一旦出现问题，更新DNS信息需要等待客户数分钟甚至数十分钟，可靠性不高。<br>c.DNS无法知晓服务器间的差异，也不能反映服务器当前的运行状态。其有可能将轻量级的访问发给空闲的服务器，将重量级的访问发给负载已经很重的服务器。<br>（2）InetAddress使用工厂方法创建实例，根据主机名/地址返回具体的实现（Inet4Address或Inet6Address）；</p>
<pre><code><span class="comment">//根据主机名获取一个地址，依赖DNS，如果服务器是负载均衡将随机得到一个ip地址</span>
<span class="comment">//通过工厂方法返回Inet4Address或Inet6Address实例</span>
InetAddress taobao = InetAddress.getByName(<span class="string">"www.taobao.com"</span>);
<span class="comment">//得到ip地址</span>
byte[] ip = taobao.getAddress();
<span class="keyword">out</span>.println(<span class="string">"Taobao IP:"</span> + Arrays.<span class="keyword">toString</span>(ip));
<span class="comment">//获取主机名对应的所有ip地址</span>
InetAddress[] baidus = InetAddress.getAllByName(<span class="string">"www.baidu.com"</span>);
<span class="keyword">out</span>.println(Arrays.<span class="keyword">toString</span>(baidus));
<span class="comment">//获取本机地址</span>
InetAddress localhost = InetAddress.getLocalHost();
<span class="keyword">out</span>.println(localhost);
<span class="keyword">out</span>.println(InetAddress.getLoopbackAddress());
<span class="keyword">out</span>.println(localhost.getHostAddress());
<span class="keyword">out</span>.println(localhost.getHostName());
<span class="keyword">out</span>.println(localhost.getCanonicalHostName());
</code></pre><h1 id="2-_简单的服务器实现">2. 简单的服务器实现</h1><p>（1）使用阻塞IO要使用线程池支持并发访问，这里我用的固定大小的线程池；<br>（2）Socket等产生的阻塞是不可中断的，实现可中断的阻塞可以用nio中的Channel；<br>（3）在客户端实现合适的半关闭策略；</p>
<p><strong>代码实现：</strong><br>服务接口：</p>
<pre><code><span class="comment">/**
 * 服务接口
 * Created by yjh on 15-12-1.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">AutoCloseable</span> </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;
}
</code></pre><p>服务骨架类：<br>（1）原子类布尔值实现安全的close退出；<br>（2）设置是否为nio；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>{
    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String EOF = <span class="string">"EOF"</span>;

    <span class="keyword">protected</span> <span class="keyword">volatile</span> AtomicBoolean isDone = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> port;
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isNIO; <span class="comment">//false使用BIO</span>

    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractServer</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">boolean</span> isNIO)</span> </span>{
        <span class="keyword">this</span>.port = port;
        <span class="keyword">this</span>.isNIO = isNIO;

    }
}
</code></pre><p>阻塞IO服务实现：<br>（1）用静态内部类包含线程池实例，延迟加载；<br>（2）使用固定大小的线程池；<br>（3）简单的数据处理逻辑：返回客户端的请求数据；<br>（4）使用Scanner和PrintWriter包装操作输入输出流；<br>（5）使用CAS操作布尔值控制线程安全；</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();
    <span class="keyword">private</span> ServerSocket serverSocket;

    <span class="function"><span class="keyword">public</span> <span class="title">BioServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>{
        <span class="keyword">super</span>(port, <span class="keyword">false</span>);
        <span class="keyword">try</span> {
            serverSocket = <span class="keyword">new</span> ServerSocket(port);
        } <span class="keyword">catch</span> (IOException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"serverSocket created fail."</span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
        run();
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">this</span>.serverSocket) {
            <span class="keyword">while</span>(!isDone.get()) {
                Socket incoming = serverSocket.accept();
                ThreadPoolHolder.executor.execute(<span class="keyword">new</span> SocketHandler(incoming));
            }
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="comment">/**
     * 静态内部类，包含一个线程池实例，延迟加载
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolHolder</span> </span>{
        <span class="comment">//延时加载，固定大小10的线程池</span>
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
        <span class="keyword">private</span> Socket incoming;

        <span class="function"><span class="keyword">public</span> <span class="title">SocketHandler</span><span class="params">(Socket incoming)</span> </span>{
            <span class="keyword">this</span>.incoming = incoming;
            logger.info(Thread.currentThread().getName() + <span class="string">"'s connection is established"</span>);
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">try</span> {
                <span class="keyword">try</span>(Socket incoming = <span class="keyword">this</span>.incoming) {
                    InputStream inputStream = incoming.getInputStream();
                    OutputStream outputStream = incoming.getOutputStream();

                    <span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(inputStream);
                        PrintWriter out = <span class="keyword">new</span> PrintWriter(outputStream, <span class="keyword">true</span>)) {
                        out.println(<span class="string">"Accepted request, send '"</span> + EOF  + <span class="string">"' to exit"</span>);

                        <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;
                        String line;
                        <span class="keyword">while</span>(!isDone &amp;&amp; in.hasNextLine()) {
                            line = in.nextLine();
                            out.println(<span class="string">"Echo: "</span> + line);
                            <span class="keyword">if</span>(line.trim().equalsIgnoreCase(EOF) || StringUtils.isEmpty(line.trim())) isDone = <span class="keyword">true</span>;
                        }
                    }
                }
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
            logger.info(Thread.currentThread().getName() + <span class="string">"'s connection is closed"</span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{
        <span class="keyword">while</span>(isDone.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {
            ThreadPoolHolder.executor.shutdownNow();
        }
    }
}
</code></pre><p>非阻塞IO实现：<br>（1）使用ServerSocketChannel，SocketChannel注册到Selector，由Selector轮询并通知执行对应的回调（订阅-分发模式）；<br>（2）设置Channel设置为（同步）非阻塞模式，提高IO效率，增加CPU的负载，适用于并发量大，数据量小的情形；</p>
<pre><code>public class <span class="type">NioServer</span> extends <span class="type">AbstractServer</span> {
    private <span class="keyword">static</span> final <span class="type">Logger</span> logger = <span class="type">LogManager</span>.getLogger();

    private final <span class="type">ServerSocketChannel</span> serverChannel;
    private final <span class="type">Selector</span> selector;
    private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">BufferSize</span> = <span class="number">4096</span>;
    private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">TIME_OUT</span> = <span class="number">3000</span>;

    public <span class="type">NioServer</span>(<span class="type">int</span> port, boolean isNIO) {
        super(port, isNIO);
        <span class="keyword">try</span> {
            selector = <span class="type">Selector</span>.open();
            serverChannel = <span class="type">ServerSocketChannel</span>.open();
            serverChannel.configureBlocking(!isNIO);
        } catch (<span class="type">IOException</span> e) {
            throw new <span class="type">RuntimeException</span>(<span class="string">"serverSocket created fail."</span>);
        }
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> start() throws <span class="type">IOException</span> {
        serverChannel.socket().<span class="keyword">bind</span>(new <span class="type">InetSocketAddress</span>(port));
        serverChannel.register(selector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span>);
        run();
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> close() throws <span class="type">Exception</span> {
        <span class="keyword">try</span> {
            serverChannel.close();
        } <span class="keyword">finally</span> {
            isDone.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);
        }
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> run() {
        <span class="type">Protocol</span> protocol = new <span class="type">NioTCPProtocol</span>(<span class="type">BufferSize</span>);
        <span class="keyword">while</span>(!isDone.get()) {
            <span class="type">Iterator</span>&lt;<span class="type">SelectionKey</span>&gt; <span class="keyword">iterator</span> = null;
            <span class="keyword">try</span> {
                <span class="keyword">if</span>(selector.select(<span class="type">TIME_OUT</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;

                <span class="type">Set</span>&lt;<span class="type">SelectionKey</span>&gt; selectionKeys = selector.selectedKeys();
                <span class="keyword">for</span>(<span class="keyword">iterator</span> = selectionKeys.<span class="keyword">iterator</span>(); <span class="keyword">iterator</span>.hasNext();) {
                    <span class="type">SelectionKey</span> key = <span class="keyword">iterator</span>.next();
                    <span class="keyword">if</span>(key.isAcceptable()) {
                        protocol.handleAccept(key);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable()) {
                        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"doSomething when be able to connect"</span>);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) {
                        protocol.handleRead(key);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable()) {
                        protocol.handleWrite(key);
                    }
                    <span class="keyword">iterator</span>.remove(); //注意要从就绪集合中删除，下次就绪有selector添加
                }
            } catch (<span class="type">Exception</span> e) {
                logger.error(e);
                <span class="keyword">if</span>(<span class="keyword">iterator</span> != null)
                    <span class="keyword">iterator</span>.remove();
            }
        }
    }

}
</code></pre><p>处理对应Select事件：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();

    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> bufferSize; <span class="comment">//缓冲区大小</span>

    <span class="function"><span class="keyword">public</span> <span class="title">NioProtocol</span><span class="params">(<span class="keyword">int</span> bufferSize)</span> </span>{
        <span class="keyword">this</span>.bufferSize = bufferSize;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>{
        <span class="comment">//accept事件，由ServerSokcetChannel打开SocketChannel，并设置非阻塞和注册</span>
        SocketChannel channel = ((ServerSocketChannel)key.channel()).accept();
        channel.configureBlocking(<span class="keyword">false</span>);
        channel.register(key.selector(), SelectionKey.OP_READ,
                ByteBuffer.allocate(bufferSize));
        logger.info(channel.getRemoteAddress() + <span class="string">"'s connection is established."</span>);
    }

    <span class="comment">//客户端发送数据，通过Buffer从Channel中读取请求数据并返回</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>{
        SocketChannel channel = (SocketChannel) key.channel();
        <span class="comment">//创建缓冲区</span>
        ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
        buffer.clear();
        <span class="keyword">long</span> len = <span class="number">0</span>;
        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        Charset charset = Charset.forName(<span class="string">"UTF8"</span>);
        <span class="keyword">while</span> ((len = channel.read(buffer)) &gt; <span class="number">0</span>) {
            buffer.flip();
            sb.append(charset.decode(buffer).toString());
            buffer.clear();
        }
        logger.debug(sb.toString());
        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) {
            logger.info(channel.getRemoteAddress() + <span class="string">"'s connection is closed."</span>);
            channel.close();
        } <span class="keyword">else</span> {
            <span class="comment">//TODO 抽象出事件处理机制，类似Servlet的回调，分发给特定的处理点</span>
            <span class="keyword">byte</span>[] bytes = sb.toString().getBytes(<span class="string">"UTF8"</span>);
            ByteBuffer responseBuffer = ByteBuffer.allocate(bytes.length);
            responseBuffer.put(bytes);
            responseBuffer.flip();
            channel.write(responseBuffer);
            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>{

    }
}
</code></pre><h1 id="3-_URI，URL，URLConnection获取Web数据">3. URI，URL，URLConnection获取Web数据</h1><p>URI是统一资源标识符，起描述作用；<br>URL是统一资源定位符，起定位作用；URL是URI的特例；</p>
<p>URI的各个部分：<br>[scheme:][schemeSpecificPart][#fragment]<br>（1）绝对与相对：是否包含scheme部分；<br>（2）透明与不透明：schemeSpecificPart是否以”/“开头；<br>schemeSpecificPart又进一步分层：<br>[//authority][path][?query]<br>authority又可以分为：<br>[user-info@]host:[port]；</p>
<pre><code>URI uri = URI.create(<span class="string">"http://localhost:8080/example/servlets/servlet/空幻?author=空幻<span class="subst">#success</span>"</span>);
</code></pre><p>scheme：http；<br>schemeSpecificPart：localhost:8080/example/servlets/servlet/空幻?author=空幻；<br>fragment：success<br>authority：localhost:8080<br>path：/example/servlets/servlet/空幻<br>query：author=空幻<br>host：localhost<br>port：8080</p>
<p>对于Servlet规范来说这个URI可能是这样的：<br>getUri：/example/servlets/servlet/空幻，返回相对的；<br>Url：<a href="http://localhost:8080/example/servlets/servlet/空幻；" target="_blank" rel="external">http://localhost:8080/example/servlets/servlet/空幻；</a><br>ContextPath：example；<br>servletPath：/servlets/servlet<br>PathInfo：空幻<br>QueryString：author=空幻</p>
<h2 id="使用URLConnection">使用URLConnection</h2><p>（1）创建：</p>
<pre><code><span class="keyword">URL</span> url = new <span class="keyword">URL</span>(<span class="string">"http://localhost:8080/debug"</span>);
HttpURLConnection connection = (HttpURLConnection)url.openConnection();
</code></pre><p>（2）设置连接属性：</p>
<pre><code><span class="function">setOutput</span>(true); <span class="comment">//如果要写入必须设置</span>
<span class="function">setUseCaches</span>(boolean); <span class="comment">//URLConnection本身不提供缓存支持需要外部实现，如浏览器；</span>
<span class="function">setConnectionTimeout</span>(); <span class="comment">//连接超时时间</span>
<span class="function">setReadTimeout</span>(); <span class="comment">//读取超时时间</span>
</code></pre><p>使用HttpURLConnection时，使用post应该设置setContentLength；<br>（3）连接：</p>
<pre><code>connect()<span class="comment">;</span>
</code></pre><p>（4）获取响应属性：</p>
<pre><code><span class="function">getHeaderFields</span>();
<span class="function">getHeaderFieldKey</span>();
<span class="function">getHeaderField</span>();
<span class="function">getContentLength</span>();
<span class="function">getContentType</span>();
<span class="function">getContentEncoding</span>();
<span class="comment">//等等</span>
</code></pre><p>（5）获取响应数据：</p>
<pre><code><span class="function">getInputStream</span>();
<span class="function">getContent</span>(); <span class="comment">//不常用，需要MIME类型支持，对应的处理器处理</span>
</code></pre><p>补充：HttpURLConnection包含了一些额外方法，如：<br>setRequestMethod，getErrStream等；</p>
<p>在使用POST请求连接时，注意设置Content-Length等请求头；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java-Servlet-4-0-Specification解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/30/Java-Servlet-4-0-Specification解读/" class="article-date">
  	<time datetime="2015-11-30T09:34:47.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/Java-Servlet-4-0-Specification解读/">Java Servlet 4.0 Specification解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术更新/">技术更新</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Zerohuan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>