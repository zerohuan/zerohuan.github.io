<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Zerohuan的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从CSDN迁徙而来">
<meta property="og:type" content="website">
<meta property="og:title" content="Zerohuan的博客">
<meta property="og:url" content="http://blog.ssearch.cn/page/3/index.html">
<meta property="og:site_name" content="Zerohuan的博客">
<meta property="og:description" content="从CSDN迁徙而来">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zerohuan的博客">
<meta name="twitter:description" content="从CSDN迁徙而来">
  
    <link rel="alternative" href="/atom.xml" title="Zerohuan的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zerohuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">我在路上</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Java-8集合框架源码/" style="font-size: 15px;">Java 8集合框架源码</a> <a href="/tags/Java基础知识/" style="font-size: 20px;">Java基础知识</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 12.5px;">TCP/IP</a> <a href="/tags/思考和求解/" style="font-size: 17.5px;">思考和求解</a> <a href="/tags/技术更新/" style="font-size: 10px;">技术更新</a> <a href="/tags/杂谈-感悟/" style="font-size: 10px;">杂谈/感悟</a> <a href="/tags/算法和数据结构/" style="font-size: 10px;">算法和数据结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">现南京大学研究生一枚，目前专注于Java Web方向。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Zerohuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Zerohuan</h1>
			</hgroup>
			
			<p class="header-subtitle">我在路上</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java基础知识总结（五）——安全" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/Java基础知识总结（五）——安全/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/Java基础知识总结（五）——安全/">Java基础知识总结（五）——安全</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="小结：">小结：</h5><p>一直说Java安全性比较好，系统的整理了下有关的Java的安全的三个方面：语言特性，安全管理器（保护域），签名和加密算法的应用。</p>
<h1 id="1-_概括">1. 概括</h1><p>Java语言的安全由三个方面共同进行保证：</p>
<h3 id="（1）语言特性：">（1）语言特性：</h3><p>类，域，方法的访问控制；<br>运行时的检查：指针操作的封装，数组的越界检查，类型转换的检查；<br>编译时检查：字节码加载，比如语义分析时会对变量是否初始化，运算符两边的类型是否匹配等等；<br>类加载：双亲委托加载模型/线程上下文类加载器，验证（文件格式验证，元数据验证，字节码验证（是否初始化，类型是否匹配等），符号验证（访问权限））；</p>
<p><strong>类加载器的安全性在于</strong>：<br>（1）双亲委托的模型中核心类，扩展类，应用类有各自层次的类加载器；<br>（2）Java中每个类型有全限定名和类加载实例两者决定，每个类加载器实例提供一个类型的命名空间；<br>（3）类加载器会检查不能由非BootStrap类加载器加载JDK核心类；<br>（4）验证环节；</p>
<h3 id="（2）访问控制：安全管理器">（2）访问控制：安全管理器</h3><h3 id="（3）代码签名，加密算法验证创建者；">（3）代码签名，加密算法验证创建者；</h3><h1 id="2-_安全管理器">2. 安全管理器</h1><p>Java平台安全性的演进：<br>（1）JDK1.0：本地代码具有所有的权限，远程代码在沙盒中运行，只能打印到屏幕和与用户交互；<br>（2）JDK1.1：远程代码带有可信赖的签名，具有与本地代码资源的所有权限；<br>（3）JDK2.0：基于<strong>保护域</strong>的安全体系，保护域包括<strong>代码来源</strong>和<strong>权限集合</strong>的映射，SecurityManager检查<strong>调用堆栈上所有方法的类</strong>的保护域，其权限集合是否允许执行当前的操作,如果所有域都通过检查则通过，否则抛出SecurityException异常；</p>
<h2 id="2-1_重要的类和方法（体系结构）：">2.1 重要的类和方法（体系结构）：</h2><p>（1）SecurityManager：checkPermission等验证方法，抛出SecurityException；<br>（2）java.Security.ProtectionDomain：保护域，包含代码来源（CodeSource）和权限集合（PermissionCollection）；<br>（3）Class：getProtectionDomain获取该类的保护域；<br>（4）java.Security.CodeSource：代码来源，包含代码位置和相关联的证书链（用于类文件签名）；<br>（5）Permission：包含implies方法（条件间的依赖关系），通过name属性是关键，equals和hashcode主要由它决定，和Principal一样可以自定义；</p>
<p>安全策略文件：<br>位置：<br>（1）Java平台主目录（java.policy文件）；<br>（2）用户主目录（.java.policy）；<br>（3）通过jvm参数指定，<br>（4）System.setProperty(“java.security.plicy”,)设置；</p>
<h2 id="2-2_用户认证（JAAS_API规范）：">2.2 用户认证（JAAS API规范）：</h2><p>（1）通过LoginContext登录，可以传入CallbackHandler（handler中可以携带一些登录信息），使用在config文件中定义的LoginModule（也可以自定义）将callbackHandler中的登录信息传递到回调对象，从而获得登录信息；<br>（2）根据用户信息库（可以是目录文件，数据库等等）。通过验证后可以获得一个Subject；<br>（3）LoginModule会给这个用Subject添加一些Principal（特征），通过Subject.doAsPrivileged（一个新的上下文，与登录环境权限分离）中执行受检查的action；<br>（4）如果policy中subject带有的principal有对应权限的话这可以执行，否则抛出AccessControlException；</p>
<p>LoginModule是检查登录权限的关键，向它传入CallbackHandler（登录信息），Subject（认证对象），options（config中对应的键值对信息），sharedState（登录模块间通信）；</p>
<h1 id="3-_数字签名">3. 数字签名</h1><h2 id="3-1_消息摘要">3.1 消息摘要</h2><p>消息摘要（message digest）：是数据块的数字指纹。<br>基本属性：<br>（1）如果数据的1位或几位改变了，那么消息摘要也将要改变。<br>（2）拥有给定消息的伪造者不能创建与原消息具有相同的假消息；</p>
<p>Java中的MessageDigest和Charset的体系很像，作为消息摘要算法子类的超类的同时也是工厂类；</p>
<p>消息摘要意义在于检查文件（消息）是否被修改过，这就要求消息摘要和消息分开传递，否则一同截获再被修改（很容易）就无法起作用了。比如，保存文件是常常可以通过MD5验证的方式检查文件是否是同一文件。</p>
<h2 id="3-2_消息签名">3.2 消息签名</h2><p>由于消息摘要的局限性，在需要认证用户身份的时候就需要数字签名同时能够校验消息有无被修改，中途被篡改。</p>
<p>数字签名算法（DSA）；</p>
<h3 id="重要概念：">重要概念：</h3><p>（1）公共密钥：可以公开，数字签名中，对方通过公共密钥校验消息的来源可信性（原始信息未修改，验证对方身份）；在非对称加密算法中，可以用来加密给对方的消息；<br>（2）私有密钥：非公开，在数字签名中，可以用生成签名；在非对加密中，可以通过私有密钥解密对方发来的加密消息；<br>（3）公共密钥和私有密钥的设计在于通过一个密钥推算出另一个密钥是实际不可性的，在数字签名中，私有密钥相当于个人的凭证。</p>
<h3 id="数字签名原理：">数字签名原理：</h3><p>（1）发送方，生成自己的密钥库，包含私有密钥和公有密钥，将公有密钥包含导出成证书将这个证书发送给接受方；<br>（2）接收方，验证证书的真实性，接受到带有签名的消息后，利用证书验证<strong>是否为发送方的签名</strong>和<strong>消息有无被修改</strong>；</p>
<h3 id="基于第三方认证机构的认证">基于第三方认证机构的认证</h3><p>我觉得这种模式类似于中介者设计模式/迪米特法则，类似的还有集群架构中中心式的拓扑结构，将多对多的联系变成一对多，复杂性集中在中介者身上，将认证的步骤分离出来。<br>（1）第三方将自己的<strong>根证书（公有密钥）</strong>导出，可以利用pem格式（隐私增强型邮件格式）；<br>（2）用户将<strong>根证书</strong>导入密钥库中，这时用户的密钥库能够信任这个第三方平台发来的信息；<br>（3）将发送方的证书同样导出成pem格式，基于openssl和第三方的CA对该证书签名生成pem，这是第三方平台对发送方的认证；<br>（4）将这个带有第三方签名的证书由接收方导入密钥库（因为已有了第三方的证书），最后接收方就拥有了发送方的证书；</p>
<h3 id="keytool，jarsign：JDK数字证书，签名生成工具">keytool，jarsign：JDK数字证书，签名生成工具</h3><p>生成密钥库：keytool -genkeypair -keystore xxx.certs -alias xxx；<br>导出证书：keytool -exportcert -keystore xxx.certs -alias acmeroot -file acmeroot.cer；<br>导入证书到密钥库：keytool -importcert -keystore xxx.certs -alias yyy -file yyy.cer（yyy发送方别名）；<br>打印证书：keytool -printcert -file xxx.cer；<br>列出密钥库证书：keytool -list -v -keystore xxx</p>
<p>使用证书签名jar：jarsigner -keystore xxx.certs document.jar xxx<br>验证jar签名：jarsigner -verify -keystore xxx.certs document.jar</p>
<h2 id="4-_加密：">4. 加密：</h2><p>消息签名可以认证代码的来源，并且校验是否被修改，但是消息本身是可见的，对于重要的信息需要加密。</p>
<p>Cipher类：与Charset和MessageDigest一样，超类+工厂类。</p>
<h3 id="4-1_加密算法：">4.1 加密算法：</h3><p>对称密码：DES（穷举法可破解），AES等；<br>非对称密码：RSA等</p>
<h4 id="非对称加密算法的应用方式">非对称加密算法的应用方式</h4><p><strong>公有密钥算法比对称密钥算法慢的多</strong>，因此不能用来加密大量的信息。使用对称密钥算法加密正文，公有密钥加密对称密钥是一种可行的方式。<br>（1）发送方生成对称密钥，对明文进行加密，并使用接收方的公有密钥对对称密钥进行加密；<br>（2）将加密后的明文和对称密钥一同发送给接收方；<br>（3）接收方使用自己的私有密钥将对称密钥解密，再用对称密钥解密得到明文；</p>
<p>使用公有密钥算法的方式和下面对称加密算法的方式类似：主要要使用WARP_MODE和UNWARP_MODE对对称加密的<code>key</code>进行加解密。</p>
<h4 id="生成密钥">生成密钥</h4><p>生成密钥可以用<strong>SecureRandom</strong>或者<strong>随机序列（随机敲键盘）</strong>的得到随机种子。密钥可以用序列化的方式输出到磁盘等地方保存。<br>方式一：</p>
<pre><code><span class="constant">KeyGenerator keyGenerator</span> = KeyGenerator.getInstance(<span class="string">"AES"</span>);
<span class="comment">//"真正的随机数"，加密的随机数，需要额外性能</span>
<span class="comment">//Random以日期和时间为种子并不安全</span>
<span class="constant">SecureRandom secureRandom</span> = new SecureRandom();
keyGenerator.init(secureRandom);
<span class="constant">Key key</span> = keyGenerator.generateKey();
</code></pre><p>方式二：</p>
<pre><code><span class="built_in">byte</span>[] seq = <span class="string">"sdlkfjiuqoenrgiuerds,msfd"</span>.getBytes();
SecretKey <span class="variable">key</span> = <span class="keyword">new</span> SecretKeySpec(seq, <span class="string">"AES"</span>);
</code></pre><h4 id="加密">加密</h4><p>选择加密算法：</p>
<pre><code>Cipher aes = Cipher.getInstance(<span class="string">"AES"</span>);
<span class="comment">/* 
    模式有4种：
    ENCRYPT_MODE
    DECRYPT_MODE
    UNWARP_MODE
    WARP_MODE
*/</span>
<span class="built_in">int</span> mode = Cipher.ENCRYPT_MODE;
aes.init(mode, <span class="variable">key</span>);
</code></pre><p>将输入流中的数据加密写入输出流。注意如果数据不能以blockSize对齐，应该使用doFinal写入深入部分，该方法可以补齐。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crypt</span>(<span class="params">InputStream <span class="keyword">in</span>, OutputStream <span class="keyword">out</span>, Cipher cipher</span>) throws IOException, GeneralSecurityException </span>{
        <span class="keyword">int</span> blockSize = cipher.getBlockSize();
        <span class="keyword">int</span> outputSize = cipher.getOutputSize(blockSize);
        <span class="keyword">byte</span>[] inBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[blockSize];
        <span class="keyword">byte</span>[] outBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[outputSize];

        boolean more = <span class="keyword">true</span>;
        <span class="keyword">int</span> inLen = <span class="number">0</span>;
        <span class="keyword">while</span>(more) {
            inLen = <span class="keyword">in</span>.read(inBytes);
            <span class="keyword">if</span>(inLen == blockSize) {
                <span class="keyword">int</span> outputLen = cipher.update(inBytes, <span class="number">0</span>, blockSize, outBytes);
                <span class="keyword">out</span>.write(outBytes, <span class="number">0</span>, outputLen);
            } <span class="keyword">else</span> {
                more = <span class="keyword">false</span>;
            }
        }
        <span class="keyword">if</span>(inLen &gt; <span class="number">0</span>) outBytes = cipher.doFinal(inBytes, <span class="number">0</span>, inLen);
        <span class="keyword">else</span> outBytes = cipher.doFinal();
        <span class="keyword">out</span>.write(outBytes);
        <span class="keyword">out</span>.flush();
    }
</code></pre><h4 id="密码流">密码流</h4><p>使用CiperInputStream和CiperOutputStream可以屏蔽<code>update</code>和<code>doFinal</code>等细节；</p>
<hr>
<h3 id="附：policy，config语法小记：">附：policy，config语法小记：</h3><p>grant：codeBase，principal，signedBy（加alias）；<br>Login1 {LoginModule}：登录上下文定义；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-基于WebSocket，Spring开发消息系统后台" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/基于WebSocket，Spring开发消息系统后台/" class="article-date">
  	<time datetime="2015-12-02T05:19:32.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/基于WebSocket，Spring开发消息系统后台/">基于WebSocket，Spring开发消息系统后台</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_为什么需要WebSocket：">1. 为什么需要WebSocket：</h2><p>回答这个首先需要知道一些历史，我们知道HTTP是客户端向服务器请求获取数据的普遍方式，但是它是一种被动性的通信机制。request=response，服务器只有在接受到客户端请求的时候才可能向客户端发送数据。但有时候服务器需要告诉客户端有新的数据应该接受，比如消息，即时聊天等功能，也就是说我们应该需要一种全双工的通信方式，而HTTP的被动性使得这一问题很难解决。</p>
<p>你可能会问webSocket很新啊，在这之前是如果实现类似的功能的呢？下面介绍几种技术用来在在“单连接的HTTP中模拟全双工”的：</p>
<h3 id="解决方案一：频繁轮询：">解决方案一：频繁轮询：</h3><p>客户端以较短的时间间隔向服务器请求新的数据，比如1秒：<br>那么请求过程可能是这样的：</p>
<pre><code>client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">123</span> 有，给你
<span class="number">1</span>s...
client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">0</span> 没有。。。
<span class="number">1</span>s...
client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">0</span> 没有。。。
<span class="number">1</span>s...
...n秒后
client： GET/ajaxEndponit 有没有新数据
server： <span class="number">200</span> OK Content-Length:<span class="number">123</span> 有，给你
</code></pre><p>显然这种方案产生了大量的请求，其中很多请求是无意义的，造成了大量的浪费。这时你可能会想：要是可以减少连接数就好了，这就是长轮询。</p>
<h3 id="解决方案二：长轮询：">解决方案二：长轮询：</h3><p>HTTP是被动性的，因此想要减少连接数量只能增长连接的时间否则你无法及时返回新的数据。客户端发起一个超时时间较长（比如20秒）的请求，服务器在没有数据的时候并不立即返回，而是以某种方式阻塞（使用阻塞队列神马的），当有数据的时候在返回，或者在时间超时时返回无数据。<br>那么请求过程可能是这样的：</p>
<pre><code>clinet：GET/longPollEndpoint
server：<span class="number">200</span> OK Content-Length:<span class="number">123</span>有，给你
client：GET/longPollEndpoint 
server检查没有数据，阻塞等待
.
. <span class="number">20</span>秒
.
server：<span class="number">200</span> OK Content-Length:<span class="number">0</span> 没有数据。。。
client：GET/longPollEndpoint 
.
. <span class="number">15</span>秒
.
server：<span class="number">200</span> OK Content-Length:<span class="number">123</span>有，给你
</code></pre><p>可以看到，连接的数量大大减少了，但是存在连接几乎一直存在啊，这样会不会有什么问题？有，首先，HTTP/1.1规范中对同一主机名的访问是有数量限制的：不超过2个，也就是我们少了一半可以请求其他数据的连接资源。。。再有，如果在服务器没有数据阻塞的时候客户端又有新数据要请求时怎么办，只能另起一个并行的请求去做了。</p>
<h3 id="解决方案三：分块编码：">解决方案三：分块编码：</h3><p>这个方案可能是为了解决浏览器长时间等待而创建的，一直等待响应对浏览器来说并不友好，但我觉得这个方案有些奇葩，分块的思想大致是这样的，既然我发现有很多时间都是在等待，那我有数据的时候就不一次性返回给客户端了，把它分割分几次返回给客户端，这样看上去浏览不就是一直在请求和获取数据吗。。。这个方法并没有什么本质上的改观，如果某些时候需要返回的数据大量产生呢，那我们是不是需要动态维护块的大小适应数据流，显然这是一件不简单的事情，又需要额外的成本。</p>
<h3 id="解决方案四：Applet和Adobe_Flash：">解决方案四：Applet和Adobe Flash：</h3><p>Java applet是一个“久远”的概念，它是一种内嵌在浏览器中的Java 小程序和Flash一样，它们不再使用HTTP，而是TCP套接字来实现全双工的通信，但是它们并不安全，没有构建什么安全协议，而写资源消耗，你懂的。。。尤其是移动互联网出现后很多移动端的浏览器并不支持它们，所以。。。</p>
<h1 id="2-_WekSocket简介：">2. WekSocket简介：</h1><p>说了这么多，你应当发现这是个难搞的问题啊，是的，HTTP的被动性本质使得在它的框架内我们无法实现真正的全双工通信。WebSocket正是解决这一问题的方案。<br>那么如何从一个HTTP连接机制中的通信环境发起一个WebSocket连接呢？</p>
<p>利用HTTP/1.1的升级特性迁移到WebSocket协议：</p>
<pre><code>GET /chat HTTP/<span class="number">1.1</span>
<span class="label">Host:</span> server.example.com
<span class="label">Upgrade:</span> websocket
<span class="label">Connection:</span> Upgrade
<span class="keyword">Sec</span>-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
<span class="keyword">Sec</span>-WebSocket-Protocol: chat, superchat
<span class="keyword">Sec</span>-WebSocket-Version: <span class="number">13</span>
<span class="label">Origin:</span> http://example.com
<span class="label">Connection:</span> Upgrade表示我要升级成其他的协议；
<span class="label">Upgrade:</span>websocket表示我要升级层websocket，服务器你支持不？
<span class="keyword">Sec</span>-WebSocket-Key，客户端随机生成的，服务器之后会拿这个进行加密作为标识之一。
<span class="keyword">Sec</span>-WebSocket-Protocol：区分同一URL下需要使用的不同协议。
<span class="keyword">Sec</span>-WebSokcet-Version：版本号。
服务器会返回：
HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols
<span class="label">Upgrade:</span> websocket
<span class="label">Connection:</span> Upgrade
<span class="keyword">Sec</span>-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
<span class="keyword">Sec</span>-WebSocket-Protocol: chat
<span class="keyword">Sec</span>-WebSocket-Accept：看我加密了你发来的随机码，你认识我了吧！
<span class="keyword">Sec</span>-WebSocket-Protocol：我支持chat协议；
</code></pre><p>注意，HTTP的状态码是101, Switch Protocols，ok，到这里，我们从原来的HTTP协议已经建立了一个持久的、全双工的TCP套接字协议，</p>
<p>PS：有些时候，服务器的特定资源只接受HTTP升级请求，这时如果请求为发起升级，会返回426 Upgrade Required；如果客户端不支持就返回400咯。</p>
<h3 id="那WebSocket到底有什么好处呢？">那WebSocket到底有什么好处呢？</h3><p>在握手之后，信道已经建立起来了，ws和wss分别对应与http和https（看我们已经可以使用新的协议了）。<br>这时已经是一个全双工，持久的信道了，它有这些优点：<br>（1）使用HTTP来进行握手，可以很方便的继承与浏览器和HTTP服务器中；<br>（2）ws和wss与http和https一样同样对应与80和443端口，一般防火墙是不会阻止的；<br>（3）心跳机制，一般用来保持连接的，两边都不说话时，也通过心跳包来保持连接～；<br>（4）不再收到2个连接的限制了；<br>（5）可以安全进行跨域连接了，HTTP的origin会限制ajax和XMLHttpRequest跨域；<br>值得一提的是使用webSocket提供高清视频流更为强大；</p>
<h1 id="3-_Java中的WebSocket：">3. Java中的WebSocket：</h1><p>当然使用H5中的js的webSocket api是浏览器的方法，这里为了演示我就只介绍Java的WebSocket API了，同样分为客户端和服务端两部分。</p>
<p>maven依赖：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><p>集成了客户端和服务端，如果你只需要客户端可以使用 javax.websocket-client-api。<br>这里使用的是provided，显然和其他J2EE规范一样我们在开发时也只需要使用api面向接口开发，tomcat8.0中提供了websocket的实现。</p>
<h2 id="3-1_WebSocket_API：">3.1 WebSocket API：</h2><p><strong>客户端API：</strong><br>有几个关键的接口：<br><strong>ContainerProvider</strong>：这是服务提供者接口，不同的实现者可以通过实现该接口来构建服务（webSocket）的提供者，通过提供者注册接口来提供具体的服务，如果你不清楚这种模式可以参看《Effective Java》中的第一条；<br><strong>WebSocketContainer</strong>：这就我们需要的webSocket“服务”了，通过ContainerProvider.getContainer获得，通过他的connectToServer方法可以返回Session；<br><strong>Session</strong>：使用session我们一发送数据，关闭会话；<br><strong>RemoteEndPoint</strong>：我的理解是一个回调接口，它代表的实例由WebContainer管理，就像Servlet和Servlet容器一样；</p>
<p><strong>服务器API：</strong><br>serverContainer继承了WebSocketContainer，你可以通过ServletContext.getArribute(“javax.websocket.ServerContainer”)来获取它，但你并不需要这么做，你只需要在POJO上添加一个@ServerEndpoint，webSocket会扫面它创建实例，默认是每一个连接都会创建一个EndPoint实例，理解这一点很重要，因为在和Spring的自动注入结合后会产生问题（如果你不是用Spring WebSocket配置的话）。</p>
<p>EndPoint有四个回调方法：@OnOpen，@OnMessage，@OnClose，@OnError，你可以通过注解在POJO中标注。</p>
<h1 id="4-_基于Spring_webSocket开发消息系统：">4. 基于Spring webSocket开发消息系统：</h1><h2 id="4-1_服务端实现：">4.1 服务端实现：</h2><pre><code><span class="annotation">@ServerEndpoint</span>(value = <span class="string">"/message/{userId}"</span>, configurator = SpringConfigurator.class)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServer</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Session&gt; userSessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();
    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();
    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger();

    <span class="annotation">@Inject</span>
    <span class="keyword">private</span> MessageService messageService;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
        userSessions.clear();
        userSessions = <span class="keyword">null</span>;
    }

    <span class="comment">/**
     * Get unread messages by userId when session opened.
     *
     * <span class="doctag">@param</span> session session get from WebSocketContain.connectToServer
     * <span class="doctag">@param</span> userId user's ID
     */</span>
    <span class="annotation">@OnOpen</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onOpen(Session session, <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
        logger.debug(<span class="string">"open session: userId:"</span> + userId + <span class="string">" sessionId"</span> + session.getId());

        List&lt;BMessageEntity&gt; unReadMessages =
                <span class="keyword">this</span>.messageService.getMessageByIsRead(userId, BMessageState.UNREAD);

        <span class="keyword">if</span>(unReadMessages.size() &gt; <span class="number">0</span>) {
            <span class="keyword">this</span>.sendJsonMessage(session, userId, unReadMessages);
        }

        userSessions.put(userId, session);
    }

    <span class="comment">/**
     * client should send new BMessageEntity to this server, and opMessage() save data to dataBase
     *
     * <span class="doctag">@param</span> session session get from WebSocketContain.connectToServer
     * <span class="doctag">@param</span> byteBuffer accept messages
     */</span>
    <span class="annotation">@OnMessage</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onMessage(Session session, ByteBuffer byteBuffer,
                          <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
        CharBuffer charBuffer = Charset.forName(<span class="string">"utf8"</span>).decode(byteBuffer);
        String message = charBuffer.toString();

        <span class="keyword">try</span> {
            MessageJson messageJson = mapper.readValue(message, MessageJson.class);

            <span class="keyword">long</span> replyUserId = messageJson.getReplyUserId();

            <span class="comment">//save new message</span>
            BMessageEntity messageEntity = <span class="keyword">this</span>.messageService.saveMessage(userId, replyUserId, messageJson.getMessage());
            <span class="keyword">if</span>(messageEntity != <span class="keyword">null</span>) {
                <span class="comment">//send</span>
                Session replySession = userSessions.get(replyUserId);
                <span class="keyword">if</span>(replySession != <span class="keyword">null</span>) {
                    <span class="keyword">this</span>.sendJsonMessage(replySession, userId, messageEntity);
                }
            }
        } <span class="keyword">catch</span> (IOException e) {
            logger.<span class="keyword">error</span>(e);
        }
    }

    <span class="annotation">@OnError</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable e)</span> </span>{
        logger.<span class="keyword">error</span>(<span class="string">"sessionId:"</span> + session.getId() + <span class="string">" "</span> + e);
    }

    <span class="annotation">@OnClose</span>
    <span class="keyword">public</span> <span class="keyword">void</span> onClose(Session session, <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
        Session session1 = userSessions.get(userId);
        <span class="keyword">if</span>(session1 != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                <span class="keyword">if</span>(session1.isOpen())
                    session1.close();
            } <span class="keyword">catch</span> (IOException e) {
                logger.<span class="keyword">error</span>(e);
            } <span class="keyword">finally</span> {
                userSessions.remove(userId);
            }
        }
    }

    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">sendJsonMessage</span><span class="params">(Session session, <span class="keyword">long</span> userId, Object object)</span> </span>{
        <span class="keyword">try</span> {
            session.getBasicRemote()
                    .sendText(MessageServer.mapper.writeValueAsString(object));
        } <span class="keyword">catch</span> (IOException e) {
            <span class="keyword">this</span>.handleException(e, userId);
        }
    }

    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Throwable throwable, <span class="keyword">long</span> userId)</span> </span>{
        <span class="keyword">try</span>(Session session = userSessions.get(userId)) {
            session.close(<span class="keyword">new</span> CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, throwable.toString()));
        } <span class="keyword">catch</span> (IOException e) {
            logger.<span class="keyword">error</span>(e);
        } <span class="keyword">finally</span> {
            userSessions.remove(userId);
        }
    }

    <span class="comment">/**
     * custom configurator, TODO collect some require, then use this configurator
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndpointConfigurator</span> <span class="keyword">extends</span> <span class="title">SpringConfigurator</span> </span>{

    }
}
</code></pre><p>首先，使用了configurator = SpringConfigurator.class，SpringConfigurator取代了默认的Configurator，它将使得我们可以正确使用Spring进行实例化和注入，如果没有这个设置，你会得到NullPointException，因为它是有WebSocket实现实例化，它并不会帮我们注入哦，这也是上面提到的问题。</p>
<pre><code>@<span class="function"><span class="title">ServerEndpoint</span><span class="params">(value = <span class="string">"/message/{userId}"</span>, configurator = SpringConfigurator.class)</span></span>
</code></pre><p>定义一个HashMap存放session，用来向指定的user发送消息，ObjectMapper是用来转换json格式的。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">Long</span>, Session&gt; userSessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();
<span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();
</code></pre><p>打开连接是，我从数据库中取出未读消息，返回给客户端，并将session存到map中：</p>
<pre><code><span class="keyword">@OnOpen</span>
<span class="keyword">public</span> <span class="keyword">void</span> onOpen(Session session, <span class="keyword">@PathParam</span>(<span class="string">"userId"</span>) <span class="built_in">long</span> userId) {
    logger.<span class="keyword">debug</span>(<span class="string">"open session: userId:"</span> + userId + <span class="string">" sessionId"</span> + session.getId());

    List&lt;BMessageEntity&gt; unReadMessages =
            <span class="keyword">this</span>.messageService.getMessageByIsRead(userId, BMessageState.UNREAD);

    <span class="keyword">if</span>(unReadMessages.size() &gt; <span class="number">0</span>) {
        <span class="keyword">this</span>.sendJsonMessage(session, userId, unReadMessages);
    }

    userSessions.put(userId, session);
}
</code></pre><p>接受到消息后，保存消息到数据库，然后在map中查找对方的session，如果存在的话（对方有可能不在线哦），将这条消息发送给他。</p>
<pre><code><span class="annotation">@OnMessage</span>
<span class="keyword">public</span> <span class="keyword">void</span> onMessage(Session session, ByteBuffer byteBuffer,
                      <span class="annotation">@PathParam</span>(<span class="string">"userId"</span>) <span class="keyword">long</span> userId) {
    CharBuffer charBuffer = Charset.forName(<span class="string">"utf8"</span>).decode(byteBuffer);
    String message = charBuffer.toString();

    <span class="keyword">try</span> {
        MessageJson messageJson = mapper.readValue(message, MessageJson.class);

        <span class="keyword">long</span> replyUserId = messageJson.getReplyUserId();

        <span class="comment">//save new message</span>
        BMessageEntity messageEntity = <span class="keyword">this</span>.messageService.saveMessage(userId, replyUserId, messageJson.getMessage());
        <span class="keyword">if</span>(messageEntity != <span class="keyword">null</span>) {
            <span class="comment">//send</span>
            Session replySession = userSessions.get(replyUserId);
            <span class="keyword">if</span>(replySession != <span class="keyword">null</span>) {
                <span class="keyword">this</span>.sendJsonMessage(replySession, userId, messageEntity);
            }
        }
    } <span class="keyword">catch</span> (IOException e) {
        logger.<span class="keyword">error</span>(e);
    }
}
</code></pre><p>PS：这时，还是有WebSocket实现来创建它的，依然是一个连接一个实例，它也并不在Spring的单例bean注册表中，因此我们也无法将它注入到其他bean中，但是你可以在@Configuration配置中添加一个单例：</p>
<pre><code><span class="annotation">@Bean</span>
<span class="keyword">public</span> <span class="function">MessageServer <span class="title">messageServer</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">new</span> MessageServer();
}
</code></pre><p> 这样也很省资源呢，但是注意线程安全。</p>
<h2 id="4-2_客户端实现：">4.2 客户端实现：</h2><p>我这里使用了两个Servlet实例来模拟两个客户端，实现@ClientEndpoint，注意@ClientEndpoint并不会有websocket实例化，因此我们可以放心的在servlet上直接添加：</p>
<pre><code><span class="annotation">@ClientEndpoint</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger();

    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();

    <span class="keyword">private</span> Session session;
    <span class="keyword">private</span> <span class="keyword">long</span> userId;

    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{
        userId = Long.valueOf(<span class="keyword">this</span>.getInitParameter(<span class="string">"userId"</span>));

        String path = <span class="keyword">this</span>.getServletContext().getContextPath() + <span class="string">"/message/"</span> +
                userId;

        logger.debug(path);

        <span class="keyword">try</span> {
            URI uri = <span class="keyword">new</span> URI(<span class="string">"ws"</span>, <span class="string">"localhost:8080"</span>, path, <span class="keyword">null</span>, <span class="keyword">null</span>);
            <span class="keyword">this</span>.session = ContainerProvider.getWebSocketContainer()
                    .connectToServer(<span class="keyword">this</span>, uri);
            logger.debug(session.getId());
        } <span class="keyword">catch</span> (IOException | URISyntaxException | DeploymentException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Cannot connect to "</span> + path + <span class="string">"."</span> + e);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">this</span>.session.close();
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>{
        MessageJson messageJson = <span class="keyword">new</span> MessageJson();
        messageJson.setMessage(req.getParameter(<span class="string">"message"</span>));
        messageJson.setReplyUserId(Long.valueOf(req.getParameter(<span class="string">"replyUserId"</span>)));

        <span class="keyword">try</span>(OutputStream outputStream = <span class="keyword">this</span>.session.getBasicRemote().getSendStream()) {
            mapper.writeValue(outputStream, messageJson);
            outputStream.flush();
        }
        resp.getWriter().append(<span class="string">"OK"</span>);
    }

    <span class="annotation">@OnMessage</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>{
        System.out.println(message);
    }

    <span class="annotation">@OnClose</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(CloseReason reason)</span> </span>{
        CloseReason.CloseCode code = reason.getCloseCode();


    }
}
</code></pre><p>在部署描述符中，部署两个实例，它们分别有初始化参数，userId，代表两个用户～：</p>
<pre><code><span class="variable">&lt;servlet&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client1<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;servlet-class&gt;</span>com.yjh.cg.site.server.ClientServlet<span class="variable">&lt;/servlet-class&gt;</span>
        <span class="variable">&lt;init-param&gt;</span>
            <span class="variable">&lt;param-name&gt;</span><span class="keyword">user</span>Id<span class="variable">&lt;/param-name&gt;</span>
            <span class="variable">&lt;param-value&gt;</span><span class="number">1</span><span class="variable">&lt;/param-value&gt;</span>
        <span class="variable">&lt;/init-param&gt;</span>
    <span class="variable">&lt;/servlet&gt;</span>
    <span class="variable">&lt;servlet-mapping&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client1<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;url-pattern&gt;</span>/client1<span class="variable">&lt;/url-pattern&gt;</span>
    <span class="variable">&lt;/servlet-mapping&gt;</span>

    <span class="variable">&lt;servlet&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client2<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;servlet-class&gt;</span>com.yjh.cg.site.server.ClientServlet<span class="variable">&lt;/servlet-class&gt;</span>
        <span class="variable">&lt;init-param&gt;</span>
            <span class="variable">&lt;param-name&gt;</span><span class="keyword">user</span>Id<span class="variable">&lt;/param-name&gt;</span>
            <span class="variable">&lt;param-value&gt;</span><span class="number">2</span><span class="variable">&lt;/param-value&gt;</span>
        <span class="variable">&lt;/init-param&gt;</span>
    <span class="variable">&lt;/servlet&gt;</span>
    <span class="variable">&lt;servlet-mapping&gt;</span>
        <span class="variable">&lt;servlet-name&gt;</span>Client2<span class="variable">&lt;/servlet-name&gt;</span>
        <span class="variable">&lt;url-pattern&gt;</span>/client2<span class="variable">&lt;/url-pattern&gt;</span>
    <span class="variable">&lt;/servlet-mapping&gt;</span>
</code></pre><p>在servlet初始化的时候，我们向服务器请求建立连接，获取session对象：</p>
<pre><code>URI uri = <span class="keyword">new</span> URI(<span class="string">"ws"</span>, <span class="string">"localhost:8080"</span>, path, <span class="literal">null</span>, <span class="literal">null</span>);
          <span class="keyword">this</span>.session = ContainerProvider.getWebSocketContainer()
                  .connectToServer(<span class="keyword">this</span>, uri);
</code></pre><p>在doGet方法中我将http请求“包装”成websocket消息发送到服务器，当然这只是为了模拟：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>{
    MessageJson messageJson = <span class="keyword">new</span> MessageJson();
    messageJson.setMessage(req.getParameter(<span class="string">"message"</span>));
    messageJson.setReplyUserId(Long.valueOf(req.getParameter(<span class="string">"replyUserId"</span>)));

    <span class="keyword">try</span>(OutputStream outputStream = <span class="keyword">this</span>.session.getBasicRemote().getSendStream()) {
        mapper.writeValue(outputStream, messageJson);
        outputStream.flush();
    }
    resp.getWriter().append(<span class="string">"OK"</span>);
}
</code></pre><h1 id="5-_模拟：">5. 模拟：</h1><p>user2发送消息给user1：<br><a href="http://localhost:8080/client2?message=我是谁&amp;replyUserId=2" target="_blank" rel="external">http://localhost:8080/client2?message=我是谁&amp;replyUserId=2</a></p>
<p>user1收到消息：我是谁</p>
<p>user1回复：Zerohuan<br><a href="http://localhost:8080/client1?message=Zerohuan&amp;replyUserId=1" target="_blank" rel="external">http://localhost:8080/client1?message=Zerohuan&amp;replyUserId=1</a></p>
<p>好了，控制台的log我就不一一贴了，碎觉去了。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考和求解/">思考和求解</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java网络编程小记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/Java网络编程小记/" class="article-date">
  	<time datetime="2015-12-01T06:37:13.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/Java网络编程小记/">Java基础知识总结（六）——网络编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在系统的看Tomcat源码的时候，先动手复习一下Java网络编程的基础知识，实现一个简单的服务器/客户端，并在实现中思考一个服务器需要考虑那些问题，记录下来，看Tomcat源码的时候带着这些问题。</p>
<hr>
<h3 id="积累的问题和思考：">积累的问题和思考：</h3><ol>
<li>异常的处理，如何定义自己的异常体系，像具体协议HTTP的404等异常状态如何分发到对应页面；</li>
<li>怎样设计软件结构，支持NIO和BIO切换，并和Servlet规范结合的；</li>
<li>如何让Java进程成为类似Daemon进程，当前终端退出后不关闭（shell脚本控制？）；</li>
<li>关闭服务器的时候，对于没有完成的连接是如何处理的；</li>
<li>tomcat是如何支持HTTP协议的；</li>
</ol>
<h1 id="1-_Socket和InetAddress">1. Socket和InetAddress</h1><p>套接字连接：<br>需要注意：<br>（1）设置合理的超时时间，包括连接超时和读取超时；<br>（2）这是基于TCP的套接字连接，另外的UDP连接是数据报的形式，是无连接的。</p>
<h3 id="基本用法：">基本用法：</h3><pre><code><span class="comment">//套接字连接</span>
<span class="constant">Socket socket</span> = new Socket(<span class="string">"www.baidu.com"</span>, <span class="number">80</span>); <span class="comment">//在构造函数中连接/阻塞</span>
<span class="comment">//获取输入输出流</span>
<span class="constant">InputStream inputStream</span> = socket.getInputStream();
<span class="constant">OutputStream outputStream</span> = socket.getOutputStream();
<span class="comment">//关闭</span>
socket.close();
</code></pre><h3 id="套接字超时时间：">套接字超时时间：</h3><pre><code><span class="comment">//套接字超时时间</span>
<span class="comment">//建立一个无连接的Socket</span>
Socket socket1 = <span class="keyword">new</span> Socket();
<span class="comment">//设置连接超时时间，超过时间直接返回</span>
socket1.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"www.baidu.com"</span>, <span class="number">80</span>), <span class="number">1000</span>);
<span class="comment">//设置等待读取的超时时间，超时返回InterruptedIOException</span>
socket1.setSoTimeout(<span class="number">5000</span>);
<span class="keyword">BufferedReader</span> reader = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(socket1.getInputStream()));
<span class="keyword">try</span> {
    System.out.<span class="built_in">println</span>(reader.readLine());
} <span class="keyword">catch</span> (InterruptedIOException e) {
    e.printStackTrace();
}
<span class="comment">//检查是否已经连接</span>
out.<span class="built_in">println</span>(socket.isConnected());
out.<span class="built_in">println</span>(socket1.isConnected());
<span class="comment">//是否关闭</span>
out.<span class="built_in">println</span>(socket1.isClosed());
socket1.close();
out.<span class="built_in">println</span>(socket1.isClosed());
</code></pre><h3 id="因特网地址">因特网地址</h3><p><strong>注意</strong>：<br>（1）如果一个主机名对应于多个ip，比如：<br><strong>基于DNS的负载均衡</strong>：<br>为多个ip地址配置相同的域名，客户端请求某个域名服务时，域名服务器采用轮询的方式为客户端选择一个ip地址。为不同的客户端选择不同的服务器，从而实现负载均衡的目的。<br>DNS做负载均衡简单方便，但存在不少问题。<br>a.DNS无法知道解析的服务节点是否有效，若服务节点无效，DNS服务器依然会将域名解析到该节点上，造成访问服务节点无效。<br>b.DNS的缓存时间较长，一旦出现问题，更新DNS信息需要等待客户数分钟甚至数十分钟，可靠性不高。<br>c.DNS无法知晓服务器间的差异，也不能反映服务器当前的运行状态。其有可能将轻量级的访问发给空闲的服务器，将重量级的访问发给负载已经很重的服务器。<br>（2）InetAddress使用工厂方法创建实例，根据主机名/地址返回具体的实现（Inet4Address或Inet6Address）；</p>
<pre><code><span class="comment">//根据主机名获取一个地址，依赖DNS，如果服务器是负载均衡将随机得到一个ip地址</span>
<span class="comment">//通过工厂方法返回Inet4Address或Inet6Address实例</span>
InetAddress taobao = InetAddress.getByName(<span class="string">"www.taobao.com"</span>);
<span class="comment">//得到ip地址</span>
byte[] ip = taobao.getAddress();
<span class="keyword">out</span>.println(<span class="string">"Taobao IP:"</span> + Arrays.<span class="keyword">toString</span>(ip));
<span class="comment">//获取主机名对应的所有ip地址</span>
InetAddress[] baidus = InetAddress.getAllByName(<span class="string">"www.baidu.com"</span>);
<span class="keyword">out</span>.println(Arrays.<span class="keyword">toString</span>(baidus));
<span class="comment">//获取本机地址</span>
InetAddress localhost = InetAddress.getLocalHost();
<span class="keyword">out</span>.println(localhost);
<span class="keyword">out</span>.println(InetAddress.getLoopbackAddress());
<span class="keyword">out</span>.println(localhost.getHostAddress());
<span class="keyword">out</span>.println(localhost.getHostName());
<span class="keyword">out</span>.println(localhost.getCanonicalHostName());
</code></pre><h1 id="2-_简单的服务器实现">2. 简单的服务器实现</h1><p>（1）使用阻塞IO要使用线程池支持并发访问，这里我用的固定大小的线程池；<br>（2）Socket等产生的阻塞是不可中断的，实现可中断的阻塞可以用nio中的Channel；<br>（3）在客户端实现合适的半关闭策略；</p>
<p><strong>代码实现：</strong><br>服务接口：</p>
<pre><code><span class="comment">/**
 * 服务接口
 * Created by yjh on 15-12-1.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">AutoCloseable</span> </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;
}
</code></pre><p>服务骨架类：<br>（1）原子类布尔值实现安全的close退出；<br>（2）设置是否为nio；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>{
    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String EOF = <span class="string">"EOF"</span>;

    <span class="keyword">protected</span> <span class="keyword">volatile</span> AtomicBoolean isDone = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> port;
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isNIO; <span class="comment">//false使用BIO</span>

    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractServer</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">boolean</span> isNIO)</span> </span>{
        <span class="keyword">this</span>.port = port;
        <span class="keyword">this</span>.isNIO = isNIO;

    }
}
</code></pre><p>阻塞IO服务实现：<br>（1）用静态内部类包含线程池实例，延迟加载；<br>（2）使用固定大小的线程池；<br>（3）简单的数据处理逻辑：返回客户端的请求数据；<br>（4）使用Scanner和PrintWriter包装操作输入输出流；<br>（5）使用CAS操作布尔值控制线程安全；</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();
    <span class="keyword">private</span> ServerSocket serverSocket;

    <span class="function"><span class="keyword">public</span> <span class="title">BioServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>{
        <span class="keyword">super</span>(port, <span class="keyword">false</span>);
        <span class="keyword">try</span> {
            serverSocket = <span class="keyword">new</span> ServerSocket(port);
        } <span class="keyword">catch</span> (IOException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"serverSocket created fail."</span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
        run();
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">this</span>.serverSocket) {
            <span class="keyword">while</span>(!isDone.get()) {
                Socket incoming = serverSocket.accept();
                ThreadPoolHolder.executor.execute(<span class="keyword">new</span> SocketHandler(incoming));
            }
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="comment">/**
     * 静态内部类，包含一个线程池实例，延迟加载
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolHolder</span> </span>{
        <span class="comment">//延时加载，固定大小10的线程池</span>
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
        <span class="keyword">private</span> Socket incoming;

        <span class="function"><span class="keyword">public</span> <span class="title">SocketHandler</span><span class="params">(Socket incoming)</span> </span>{
            <span class="keyword">this</span>.incoming = incoming;
            logger.info(Thread.currentThread().getName() + <span class="string">"'s connection is established"</span>);
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">try</span> {
                <span class="keyword">try</span>(Socket incoming = <span class="keyword">this</span>.incoming) {
                    InputStream inputStream = incoming.getInputStream();
                    OutputStream outputStream = incoming.getOutputStream();

                    <span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(inputStream);
                        PrintWriter out = <span class="keyword">new</span> PrintWriter(outputStream, <span class="keyword">true</span>)) {
                        out.println(<span class="string">"Accepted request, send '"</span> + EOF  + <span class="string">"' to exit"</span>);

                        <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;
                        String line;
                        <span class="keyword">while</span>(!isDone &amp;&amp; in.hasNextLine()) {
                            line = in.nextLine();
                            out.println(<span class="string">"Echo: "</span> + line);
                            <span class="keyword">if</span>(line.trim().equalsIgnoreCase(EOF) || StringUtils.isEmpty(line.trim())) isDone = <span class="keyword">true</span>;
                        }
                    }
                }
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
            logger.info(Thread.currentThread().getName() + <span class="string">"'s connection is closed"</span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{
        <span class="keyword">while</span>(isDone.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {
            ThreadPoolHolder.executor.shutdownNow();
        }
    }
}
</code></pre><p>非阻塞IO实现：<br>（1）使用ServerSocketChannel，SocketChannel注册到Selector，由Selector轮询并通知执行对应的回调（订阅-分发模式）；<br>（2）设置Channel设置为（同步）非阻塞模式，提高IO效率，增加CPU的负载，适用于并发量大，数据量小的情形；</p>
<pre><code>public class <span class="type">NioServer</span> extends <span class="type">AbstractServer</span> {
    private <span class="keyword">static</span> final <span class="type">Logger</span> logger = <span class="type">LogManager</span>.getLogger();

    private final <span class="type">ServerSocketChannel</span> serverChannel;
    private final <span class="type">Selector</span> selector;
    private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">BufferSize</span> = <span class="number">4096</span>;
    private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">TIME_OUT</span> = <span class="number">3000</span>;

    public <span class="type">NioServer</span>(<span class="type">int</span> port, boolean isNIO) {
        super(port, isNIO);
        <span class="keyword">try</span> {
            selector = <span class="type">Selector</span>.open();
            serverChannel = <span class="type">ServerSocketChannel</span>.open();
            serverChannel.configureBlocking(!isNIO);
        } catch (<span class="type">IOException</span> e) {
            throw new <span class="type">RuntimeException</span>(<span class="string">"serverSocket created fail."</span>);
        }
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> start() throws <span class="type">IOException</span> {
        serverChannel.socket().<span class="keyword">bind</span>(new <span class="type">InetSocketAddress</span>(port));
        serverChannel.register(selector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span>);
        run();
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> close() throws <span class="type">Exception</span> {
        <span class="keyword">try</span> {
            serverChannel.close();
        } <span class="keyword">finally</span> {
            isDone.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);
        }
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> run() {
        <span class="type">Protocol</span> protocol = new <span class="type">NioTCPProtocol</span>(<span class="type">BufferSize</span>);
        <span class="keyword">while</span>(!isDone.get()) {
            <span class="type">Iterator</span>&lt;<span class="type">SelectionKey</span>&gt; <span class="keyword">iterator</span> = null;
            <span class="keyword">try</span> {
                <span class="keyword">if</span>(selector.select(<span class="type">TIME_OUT</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;

                <span class="type">Set</span>&lt;<span class="type">SelectionKey</span>&gt; selectionKeys = selector.selectedKeys();
                <span class="keyword">for</span>(<span class="keyword">iterator</span> = selectionKeys.<span class="keyword">iterator</span>(); <span class="keyword">iterator</span>.hasNext();) {
                    <span class="type">SelectionKey</span> key = <span class="keyword">iterator</span>.next();
                    <span class="keyword">if</span>(key.isAcceptable()) {
                        protocol.handleAccept(key);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable()) {
                        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"doSomething when be able to connect"</span>);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) {
                        protocol.handleRead(key);
                    } <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable()) {
                        protocol.handleWrite(key);
                    }
                    <span class="keyword">iterator</span>.remove(); //注意要从就绪集合中删除，下次就绪有selector添加
                }
            } catch (<span class="type">Exception</span> e) {
                logger.error(e);
                <span class="keyword">if</span>(<span class="keyword">iterator</span> != null)
                    <span class="keyword">iterator</span>.remove();
            }
        }
    }

}
</code></pre><p>处理对应Select事件：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();

    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> bufferSize; <span class="comment">//缓冲区大小</span>

    <span class="function"><span class="keyword">public</span> <span class="title">NioProtocol</span><span class="params">(<span class="keyword">int</span> bufferSize)</span> </span>{
        <span class="keyword">this</span>.bufferSize = bufferSize;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>{
        <span class="comment">//accept事件，由ServerSokcetChannel打开SocketChannel，并设置非阻塞和注册</span>
        SocketChannel channel = ((ServerSocketChannel)key.channel()).accept();
        channel.configureBlocking(<span class="keyword">false</span>);
        channel.register(key.selector(), SelectionKey.OP_READ,
                ByteBuffer.allocate(bufferSize));
        logger.info(channel.getRemoteAddress() + <span class="string">"'s connection is established."</span>);
    }

    <span class="comment">//客户端发送数据，通过Buffer从Channel中读取请求数据并返回</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>{
        SocketChannel channel = (SocketChannel) key.channel();
        <span class="comment">//创建缓冲区</span>
        ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
        buffer.clear();
        <span class="keyword">long</span> len = <span class="number">0</span>;
        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        Charset charset = Charset.forName(<span class="string">"UTF8"</span>);
        <span class="keyword">while</span> ((len = channel.read(buffer)) &gt; <span class="number">0</span>) {
            buffer.flip();
            sb.append(charset.decode(buffer).toString());
            buffer.clear();
        }
        logger.debug(sb.toString());
        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) {
            logger.info(channel.getRemoteAddress() + <span class="string">"'s connection is closed."</span>);
            channel.close();
        } <span class="keyword">else</span> {
            <span class="comment">//TODO 抽象出事件处理机制，类似Servlet的回调，分发给特定的处理点</span>
            <span class="keyword">byte</span>[] bytes = sb.toString().getBytes(<span class="string">"UTF8"</span>);
            ByteBuffer responseBuffer = ByteBuffer.allocate(bytes.length);
            responseBuffer.put(bytes);
            responseBuffer.flip();
            channel.write(responseBuffer);
            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>{

    }
}
</code></pre><h1 id="3-_URI，URL，URLConnection获取Web数据">3. URI，URL，URLConnection获取Web数据</h1><p>URI是统一资源标识符，起描述作用；<br>URL是统一资源定位符，起定位作用；URL是URI的特例；</p>
<p>URI的各个部分：<br>[scheme:][schemeSpecificPart][#fragment]<br>（1）绝对与相对：是否包含scheme部分；<br>（2）透明与不透明：schemeSpecificPart是否以”/“开头；<br>schemeSpecificPart又进一步分层：<br>[//authority][path][?query]<br>authority又可以分为：<br>[user-info@]host:[port]；</p>
<pre><code>URI uri = URI.create(<span class="string">"http://localhost:8080/example/servlets/servlet/空幻?author=空幻<span class="subst">#success</span>"</span>);
</code></pre><p>scheme：http；<br>schemeSpecificPart：localhost:8080/example/servlets/servlet/空幻?author=空幻；<br>fragment：success<br>authority：localhost:8080<br>path：/example/servlets/servlet/空幻<br>query：author=空幻<br>host：localhost<br>port：8080</p>
<p>对于Servlet规范来说这个URI可能是这样的：<br>getUri：/example/servlets/servlet/空幻，返回相对的；<br>Url：<a href="http://localhost:8080/example/servlets/servlet/空幻；" target="_blank" rel="external">http://localhost:8080/example/servlets/servlet/空幻；</a><br>ContextPath：example；<br>servletPath：/servlets/servlet<br>PathInfo：空幻<br>QueryString：author=空幻</p>
<h2 id="使用URLConnection">使用URLConnection</h2><p>（1）创建：</p>
<pre><code><span class="keyword">URL</span> url = new <span class="keyword">URL</span>(<span class="string">"http://localhost:8080/debug"</span>);
HttpURLConnection connection = (HttpURLConnection)url.openConnection();
</code></pre><p>（2）设置连接属性：</p>
<pre><code><span class="function">setOutput</span>(true); <span class="comment">//如果要写入必须设置</span>
<span class="function">setUseCaches</span>(boolean); <span class="comment">//URLConnection本身不提供缓存支持需要外部实现，如浏览器；</span>
<span class="function">setConnectionTimeout</span>(); <span class="comment">//连接超时时间</span>
<span class="function">setReadTimeout</span>(); <span class="comment">//读取超时时间</span>
</code></pre><p>使用HttpURLConnection时，使用post应该设置setContentLength；<br>（3）连接：</p>
<pre><code>connect()<span class="comment">;</span>
</code></pre><p>（4）获取响应属性：</p>
<pre><code><span class="function">getHeaderFields</span>();
<span class="function">getHeaderFieldKey</span>();
<span class="function">getHeaderField</span>();
<span class="function">getContentLength</span>();
<span class="function">getContentType</span>();
<span class="function">getContentEncoding</span>();
<span class="comment">//等等</span>
</code></pre><p>（5）获取响应数据：</p>
<pre><code><span class="function">getInputStream</span>();
<span class="function">getContent</span>(); <span class="comment">//不常用，需要MIME类型支持，对应的处理器处理</span>
</code></pre><p>补充：HttpURLConnection包含了一些额外方法，如：<br>setRequestMethod，getErrStream等；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java-Servlet-4-0-Specification解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/30/Java-Servlet-4-0-Specification解读/" class="article-date">
  	<time datetime="2015-11-30T09:34:47.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/Java-Servlet-4-0-Specification解读/">Java Servlet 4.0 Specification解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术更新/">技术更新</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-学习JVM的一点感想" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/30/学习JVM的一点感想/" class="article-date">
  	<time datetime="2015-11-30T06:05:27.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/学习JVM的一点感想/">学习JVM的一点感想</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="契子">契子</h1><p>最近一段时间，系统的学习整理了JVM的知识，很多在学习Java时在语言层面的困惑突然显得并没有复杂，在理解了JVM相关原理后这些困惑背后的原因显得很清晰，很简单。因此，我不由得想那些向JVM一样的基础知识，向操作系统，网络，甚至编码等等。在实际工作和学习中到底起着什么重要的作用呢，毕竟大多数人在学习这些知识的时候并没有那么的实际经验去结合起来考虑它们的实际作用。</p>
<h1 id="思考">思考</h1><p>由计算机组成的这个庞大系统性结构一个重要性质就是分层的，我们大多数人的大多数时间都是在一个抽象的层次上工作（比如用Java，Js，C++这样的高级语言），虽然层与层之间很多设计都做到是“透明”的，屏蔽了底层的细节，但是难免有一些耦合，由于“透明”的特性，我们难免会有一些困惑。很多前辈都强调建立“系统的知识体系”的重要，我想我在学习中也渐渐明白了这一点。</p>
<h2 id="说说我在实际中的一些困惑或者思考：">说说我在实际中的一些困惑或者思考：</h2><ol>
<li><p>在没有很好的掌握设计模式的时候，我觉得Java里的东西太多了，就拿字符串操作来说，光有String还不行，必须有StringBuffer和StringBuilder，在循环里使用+操作String会产生很多StringBuilder对象，为什么要这么麻烦。后来在看了一些东西后我明白字符串为了避免重复创建，它们是不可变的，故而可以共享，因此操作的时候会产生大量的字符串组合，所有需要StirngBuilder这个可变辅助类保存中间状态，并且它使用了生成器模式来接受大量的参数。正是因为理解了设计模式，我在去看Java和像Spirng这样复杂系统就可以发现其中的规律和设计思想，学会理解组件/类之间的关联和意义。</p>
</li>
<li><p>学习编码的时候，我知道了字顺，高位和低位，并且也知道了Java的字节码是以8字节为最小单位的Big-endian的字顺保存。因此，写一个将字节码int类型转换成byte数组的函数时我想到了这一点，我当时在想，如果我不知道Big-endian和Java字节码的字顺我是不是又得产生困惑了，然后搜一通了。</p>
</li>
<li><p>还有一个Java语言层面的例子，内部类中使用外围类方法的局部变量要加final，当时我觉得这个理解起来很抽象，去网上搜了一搜，很多人从作用域、生命周期等等角度分析，当时觉得很有道理，但是随着学习的深入，我觉得好像不是这么回事，看了JVM相关知识后，我动手查看了下外围类和内部类的字节码，清楚的看到了内部类实际上时间局部变量的值通过&lt;init&gt;方法传给了由Java编译器生成的final成员变量（它是局部变量的副本），在局部变量前加final是Java设计团队为了保证一致性的设计方案。</p>
</li>
</ol>
<p>例子很多。回头来说说自己的情况，本科的时候虽然也上了C++，计算机网络，数据结构等课，但是因为处在“计算机相关专业”课业的要求本身不高，一直主要靠自己，大一时接触HTML/CSS一系列东西，觉得很有趣，不停的自己动手做一些东西，到后来学习Java，Java Web，随着接触的东西越多，想的东西越多，越觉得基础的重要性。很多做东西产生的困惑，其实都是对基础概念的理解不深，不熟。很多相对底层的东西很简单，反映到高层就显得不那么明显。</p>
<p>所以我现在觉得，以前学数据结构，计算机网络等基础知识，一方面是知识本身，一方面是对整个由计算机构建起来的系统的理解，培养和训练自己学习和思考的方式。就像分析数据库性能瓶颈，应当使用“漏斗原则”，从IO效率最低磁盘处入手，这显然建立在对硬件系统的理解上。还有理解了编译的流程和动态类型语言和静态类型语言的差别，在学习一门语言时在宏观上就有了正确思路。</p>
<h2 id="小结">小结</h2><p>不知不觉写了很多，留在学校的日子算一算也没有多少了，剩下的时间很宝贵，我想工作后也难有这么多时间去做自己想做的事了。结合以前做的东西，写一写有些深度的代码，结合实际系统地好好巩固那些相对底层的知识是我紧迫要做的事情了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈-感悟/">杂谈/感悟</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Spring容器的启动和IoC容器原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/30/Spring容器的启动和IoC容器原理/" class="article-date">
  	<time datetime="2015-11-29T16:30:52.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/Spring容器的启动和IoC容器原理/">Spring容器的启动和IoC容器原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Spring配置的几种方式：">1. Spring配置的几种方式：</h1><p>目前最新的Spring一般有3种配置方式：<br>基于XML配置；<br>混合配置（XML配置+注解+XML配置扫描路径）；<br>基于代码配置（Spring3.1后，可以完全使用注解+WebApplicationInitializer）；<br>通过XML配置Spring的基本做法：</p>
<pre><code><span class="variable">&lt;!---①从类路径下加载spring配置文件-&gt;</span>
<span class="variable">&lt;context-param&gt;</span>
    <span class="variable">&lt;param-name&gt;</span>contextConfigLocation<span class="variable">&lt;/param-name&gt;</span>
    <span class="variable">&lt;param-value&gt;</span>
        classpath<span class="keyword">*</span>:config/spring/common/appcontext-<span class="keyword">*</span>.xml,
        classpath<span class="keyword">*</span>:config/spring/local/appcontext-<span class="keyword">*</span>.xml,
        classpath<span class="keyword">*</span>:/config/spring/abtest/appcontext-<span class="keyword">*</span>.xml,
        classpath<span class="keyword">*</span>:/config/spring/pagelet/appcontext-pagelet-core.xml
    <span class="variable">&lt;/param-value&gt;</span>
<span class="variable">&lt;/context-param&gt;</span>

<span class="variable">&lt;!--②负责启动spring容器的监听器，它将使用①处的上下文参数获得spring配置文件地址--&gt;</span>
<span class="variable">&lt;listener&gt;</span>
    <span class="variable">&lt;listener-class&gt;</span><span class="variable">&lt;span style="color:#ff0000;"&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="variable">&lt;/span&gt;</span><span class="variable">&lt;/listener-class&gt;</span>
<span class="variable">&lt;/listener&gt;</span>
</code></pre><p>通过<strong>WebApplicationInitializer</strong>的基本做法：</p>
<pre><code>@Override
<span class="keyword">public</span> <span class="keyword">void</span> onStartup(ServletContext <span class="keyword">container</span>) throws ServletException {
    logger.info(<span class="string">"Initializer startUp..."</span>);
    <span class="keyword">container</span>.getServletRegistration(<span class="string">"default"</span>).addMapping(<span class="string">"/resource/*"</span>);

    <span class="comment">//Use ContextLoaderListener to create a root context, it is father of contexts used in dispatcherServlet</span>
    AnnotationConfigWebApplicationContext rootContext = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();
    rootContext.register(RootContextConfiguration.class);
    &lt;span style=<span class="string">"color:#ff0000;"</span>&gt;<span class="keyword">container</span>.addListener(<span class="keyword">new</span> ContextLoaderListener(rootContext));&lt;/span&gt;
}
</code></pre><p>这里使用初始化器启动Spring，初始化器ServletContainerInitializer是Java EE6中一个新接口，它会在所有监听器启动之前调用它们的的onStartUp方法，并且它不需要通过web.xml部署描述符来定义，需要在/META-INF/services/javax.servlet.ServletContainerInitializer中列出具体的实现，Servlet容器在启动时会自动加载它们并调用onStartUp方法。</p>
<p>但是文件不能放在WAR文件的/META-INF/services中，而是需要放在JAR文件的/META-INF/services中，这样就很不方便。Spring Framework提供了一个桥接口，在Spring中SpringServletContainerInitializer类实现了ServletContainerInitializer接口，Spring的JAR中列出了SpringServletContainerInitializer，如下。在SpringServletContainerInitializer中会扫描所有WebApplicationInitializer的实现，调用它们的onStartUp方法，因此我们不必在劳神费心了。</p>
<p>通过XML和Java代码两种方式我们可以看到实际上Spring是通过ContextLoaderListener来启动的。基于Servlet容器启动的顺序应该有：Initializer—&gt;listener-&gt;filter-&gt;servlet。<br>因此我们来看看ContextLoaderListener作为ServletContextListener到底是如何启动Spring的。</p>
<p>#2. Spring的初始化和启动：</p>
<p>ContextLoaderListener的contextInitialized方法委托ContextLoader的initWebApplicationContext方法进行上文初始化，我们来看看一些关键步骤：<br>步骤一：创建上文对象实例：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="literal">null</span>) {
    <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);
}
</code></pre><p>在基于代码的配置中由于手动创建了AnnotationConfigWebApplication实例，因此此时context已经创建，如果通过XML配置，createWebApplicaitonContext方法会首先检查Servlet定义中有没有定义参数contextClass指明Context的类型，如果没有通过反射创建默认类型org.springframework.web.context.support.XmlWebApplicationContext的实例。</p>
<p>步骤二：开始配置刷新Spring上下文：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) {
                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;
                <span class="keyword">if</span> (!cwac.isActive()) {
                    <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span>
                    <span class="comment">// setting the parent context, setting the application context id, etc</span>
                    <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) {
                        <span class="comment">// The context instance was injected without an explicit parent -&gt;</span>
                        <span class="comment">// determine parent for root web application context, if any.</span>
                        ApplicationContext parent = loadParentContext(servletContext);
                        cwac.setParent(parent);
                    }
                    configureAndRefreshWebApplicationContext(cwac, servletContext);
                }
            }
</code></pre><p>因为AnnotationConfigWebApplication和XmlWebApplicationContext都是ConfigurableWebApplicationContext实现（实际的web项目中Context一般都是继承于AbstractRefreshableWebApplicationContext的），所以对上下文进行配置和刷新，关键在于configureAndRefreshWebApplicationContext方法，下面我们同样看看该方法的关键部分。</p>
<p>步骤三：加载重要初始化参数：</p>
<pre><code><span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) {
            <span class="comment">// The application context id is still set to its original default value</span>
            <span class="comment">// -&gt; assign a more useful id based on available information</span>
            <span class="built_in">String</span> idParam = sc.getInitParameter(CONTEXT_ID_PARAM);
            <span class="keyword">if</span> (idParam != <span class="literal">null</span>) {
                wac.setId(idParam);
            }
            <span class="keyword">else</span> {
                <span class="comment">// Generate default id...</span>
                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
                        ObjectUtils.getDisplayString(sc.getContextPath()));
            }
        }

        wac.setServletContext(sc);
        <span class="built_in">String</span> configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);
        <span class="keyword">if</span> (configLocationParam != <span class="literal">null</span>) {
            wac.setConfigLocation(configLocationParam);
        }

        <span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span>
        <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span>
        <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span>
        ConfigurableEnvironment env = wac.getEnvironment();
        <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) {
            ((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class="literal">null</span>);
        }
</code></pre><p>（1）首先加载contextId，同样检查有无配置，否则使用默认的；<br>（2）绑定ServletContext；<br>（3）绑定config文件的位置，这一步将我们在部署描述符中设置上下文参数contextConfigLocation指定的配置文件位置载入；<br>（4）绑定环境和profile；</p>
<p>步骤四：加载自定义上下文初始化器并按指定顺序执行初始化方法：</p>
<pre><code>customizeContext<span class="list">(<span class="keyword">sc</span>, wac)</span><span class="comment">;</span>
</code></pre><p>Spring提供了一个ApplicationContextInitializer接口，可以通过context-param和init-param指定类名，这里同样是通过反射创建实例，并根据Order注解大小排序，按序执行初始化方法；进行context一些值的设置比如说setAllowBeanDefinitionOverriding(false)；<br>步骤五：开始刷新Bean工厂构建Bean关系网：</p>
<p>configureAndRefreshWebApplication方法的最后一行也是最核心的一行：<br>wac.refresh();<br>这个方法完成了：<br>（1）构建BeanFactory；<br>（2）注册可能感兴趣的事件；<br>（3）创建Bean实例对象；<br>（4）触发被监听的事件；<br>“这个方法就是构建整个IoC容器过程的完整代码，了解了里面的每一行代码，基本上就了解大部分Spring的原理和功能”（摘自《深入理解Java Web技术内幕》）。这个方法的实现在AbstractApplicationContext中，让我们来看看它是如何工作：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>{
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) {
        <span class="comment">// Prepare this context for refreshing.</span>
        prepareRefresh();

        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span>
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        <span class="comment">// Prepare the bean factory for use in this context.</span>
        prepareBeanFactory(beanFactory);

        <span class="keyword">try</span> {
            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span>
            postProcessBeanFactory(beanFactory);

            <span class="comment">// Invoke factory processors registered as beans in the context.</span>
            invokeBeanFactoryPostProcessors(beanFactory);

            <span class="comment">// Register bean processors that intercept bean creation.</span>
            registerBeanPostProcessors(beanFactory);

            <span class="comment">// Initialize message source for this context.</span>
            initMessageSource();

            <span class="comment">// Initialize event multicaster for this context.</span>
            initApplicationEventMulticaster();

            <span class="comment">// Initialize other special beans in specific context subclasses.</span>
            onRefresh();

            <span class="comment">// Check for listener beans and register them.</span>
            registerListeners();

            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
            finishBeanFactoryInitialization(beanFactory);

            <span class="comment">// Last step: publish corresponding event.</span>
            finishRefresh();
        }

        <span class="keyword">catch</span> (BeansException ex) {
            logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, ex);

            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span>
            destroyBeans();

            <span class="comment">// Reset 'active' flag.</span>
            cancelRefresh(ex);

            <span class="comment">// Propagate exception to caller.</span>
            <span class="keyword">throw</span> ex;
        }

        <span class="keyword">finally</span> {
            <span class="comment">// Reset common introspection caches in Spring's core, since we</span>
            <span class="comment">// might not ever need metadata for singleton beans anymore...</span>
            resetCommonCaches();
        }
    }
}
</code></pre><p>接下来详细说明Spring是如何创建BeanFactory并构建包含事件监听的Bean关系网的：</p>
<p>步骤五-1：创建并准备BeanFactory：</p>
<p>核心的三行代码：</p>
<pre><code>// <span class="operator"><span class="keyword">Prepare</span> this <span class="keyword">context</span> <span class="keyword">for</span> refreshing.包括设置开始时间，活跃标志，初始化并验证environment属性集，初始化earlyApplicationEvents；
prepareRefresh();</span>

// Tell the subclass to refresh the internal bean factory.关键在于refreshBeanFactory
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

// <span class="operator"><span class="keyword">Prepare</span> the bean factory <span class="keyword">for</span> <span class="keyword">use</span> <span class="keyword">in</span> this <span class="keyword">context</span>.
prepareBeanFactory(beanFactory);</span>
</code></pre><p>刷新并创建BeanFactory的关键方法：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{
    <span class="keyword">if</span> (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    <span class="keyword">try</span> {
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory);
        loadBeanDefinitions(beanFactory);
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {
            <span class="keyword">this</span>.beanFactory = beanFactory;
        }
    }
    <span class="keyword">catch</span> (IOException ex) {
        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);
    }
}
</code></pre><p>（1）首先，如果当前上下文中如果已经存在BeanFactory，先删除所有缓存的Bean（使用LinkedHashSet缓存的单例，prototype的bean是不会缓存的），并将this.beanFactory置为null；<br>（2）创建DefaultListableBeanFactory，它继承了ConfigurableListableBeanFactory和AbstractAutowireCapableBeanFactory；因此它具有完整的BeanFactory功能；<br>（3）customizeBeanFactory将Context的两个配置项：allowBeanDefinitionOverriding和allowCircularReference传入BeanFactory中；<br>（4）loadBeanDefinition：查看类图可以看到还包括Bean的registry相关的类，在loadBeanDefinitions中很清除的展示了Registry接口的作用：读取用户对Bean定义，将其加载为BeanDefinition也就是IoC容器特定的数据结构；loadBeanDefinitions方法因此和读取方式有关，AnnotationWebApplicationContext和XmlWebApplicationContext有具体的实现；</p>
<p>执行完refreshBeanFactory之后，在refresh方法中的下一步是<strong>prepareBeanFactory</strong>，这一步对刚刚建立的BeanFactory设置了重要的属性：<br>（1）设置加载类的加载器，默认为当前线程上下文加载器；<br>（2）注册ApplicaitonContextAwareProcessor，并在BeanFactory中忽略ApplicationContextAwareProcessor已经处理的一些Aware接口：EnvironmentAware，MessageSourceAware，ApplicationContextAware，ApplicationEventPublisherAware，ResourceLoaderAware，这些接口通常由Bean实现，这些类型不应该使用自动装配注入，它们用于获取对应的实例，而实例对象我们已经看到是Bean的上下文，因此，ApplicationContextAwareProcessor会在postProcessorBeforeInitialization中调用这些接口的回调方法，将当前上下文对象注入；<br>（3）注册一些特殊的类型：BeanFactory，ApplicationContext，ApplicationEventPublisher，ResourceLoader，实例对象仍然是当前Context对象；<br>（4）织入处理器和特定的类加载器，Environment相关Bean注册；</p>
<p>AbstractApplicationContext的refresh方法接下来三行代码对Spring的扩展性起到了至关重要的作用，前两行是对已经创建的BeanFactory的配置做修改，扩展方式仍然是通过回调接口，这里是BeanFactoryPostProcessor，值得注意的是回调接口中使用的是onfigurableLIstableBeanFactory，通过这一“视图”可以防止一些不当的修改；；</p>
<pre><code><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span>
                <span class="function">postProcessBeanFactory</span>(beanFactory);

                <span class="comment">// Invoke factory processors registered as beans in the context.</span>
                <span class="function">invokeBeanFactoryPostProcessors</span>(beanFactory);

                <span class="comment">// Register bean processors that intercept bean creation.</span>
                <span class="function">registerBeanPostProcessors</span>(beanFactory);
</code></pre><p>步骤五-2：初始化事件多播器，注册事件监听：</p>
<pre><code><span class="comment">// Initialize message source for this context.</span>
<span class="function">initMessageSource</span>();

<span class="comment">// Initialize event multicaster for this context.</span>
<span class="function">initApplicationEventMulticaster</span>();

<span class="comment">// Initialize other special beans in specific context subclasses.</span>
<span class="function">onRefresh</span>();

<span class="comment">// Check for listener beans and register them.</span>
<span class="function">registerListeners</span>();
步骤五-3：创建Bean实例对象：

<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
<span class="function">finishBeanFactoryInitialization</span>(beanFactory);
</code></pre><p>在finishBeanFactoryInitialization方法将完成Bean的初始化工作：</p>
<pre><code>protected <span class="keyword">void</span> finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    <span class="comment">// Initialize conversion service for this context.</span>
    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.<span class="keyword">class</span>)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.<span class="keyword">class</span>));
    }

    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span>
    <span class="built_in">String</span>[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.<span class="keyword">class</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);
    <span class="keyword">for</span> (<span class="built_in">String</span> weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span>
    beanFactory.setTempClassLoader(<span class="keyword">null</span>);

    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span>
    beanFactory.freezeConfiguration();

    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
    beanFactory.preInstantiateSingletons();
}
</code></pre><p>这里首先初始化了使用织入的Bean，之后就停止使用暂时的Classloader了，并锁定了BeanFactory不允许修改；在preInstantiateSingletons方法中，将开始创建Bean实例的工作。</p>
<p><strong>Mark：</strong>未完待续</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java中的final参数-变量-匿名内部类" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/Java中的final参数-变量-匿名内部类/" class="article-date">
  	<time datetime="2015-11-29T13:50:42.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/Java中的final参数-变量-匿名内部类/">Java中的final参数/变量+匿名内部类的字节码分析，以及Java 8中的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java 8之前一个常识就是如果要在方法中定义一个匿名内部类并使用该方法内的局部变量（包括参数），需要使用final关键字修饰。网上也有很多对这种机制的解释和说明，但是大部分都是一种抽象的认识。如果能够分析一下字节码，这个问题其实很清楚。</p>
<p>显然的一个事实是局部变量（称为变量a）是保存在栈帧的局部变量表中的（引用或基本类型），这里把定义匿名内部类的方法称为方法A，匿名内部类的中使用这个局部变量的方法（称为方法B）经过编译后保存在class文件的方法表中，方法体保存在Code属性中。运行时经过类加载，验证存储到方法区中。在执行匿名内部类中，JVM创建的是方法B的栈帧。它显然和方法A的栈帧没有直接的关系，甚至方法B执行时，方法A的栈帧已经被回收了，那JVM如何保证方法B能够正确的使用变量a指向的值呢？</p>
<p>下面就通过查看字节码来看看Java编译器和JVM是如何做到这一点的，基于Oracle JDK8编译；</p>
<p>#1. 字节码分析：</p>
<p>外围类：FinalParameter<br>定义一个派生自A的匿名内部类，其中使用方法testFinal的局部变量a和参数bytes；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalParameter</span> </span>{
    <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>{
        <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testFinal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] bytes)</span> </span>{
        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;
        <span class="keyword">new</span> A() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{
                System.out.println(a + <span class="string">" "</span> + bytes.length);
            }
        };
    }
}
</code></pre><p>根据内部类命名规则我们知道这个匿名内部类的类名是FinalParameter$1；<br>使用javap -verbose FinalParameter\$1，查看该类的字节码，Unix环境下注意不要忘了转义”\$”。<br>我截取了字段表部分：</p>
<pre><code>final int val<span class="variable">$a</span>;
  descriptor: I
  flags: ACC_FINAL, ACC_SYNTHETIC

final byte[] val<span class="variable">$bytes</span>;
  descriptor: [B
  flags: ACC_FINAL, ACC_SYNTHETIC

final com.jvm.showByteCode.FinalParameter this<span class="variable">$0</span>;
  descriptor: Lcom/jvm/showByteCode/FinalParameter;
  flags: ACC_FINAL, ACC_SYNTHETIC
</code></pre><p>可以看到编译器为我们添加了3个字段，分别是：<br><strong>val\$a，val\$bytes，this\$0；</strong><br>其中this\$0是指向外围类对象实例的引用，而前两个正是从外围类方法局部变量bytes和a生成而来的，并且它们是final的。<br>再来看看FinalParameter\$1类的<init>()方法：<br>描述符：</init></p>
<pre><code><span class="label">descriptor:</span> (Lcom/jvm/showByteCode/FinalParameter<span class="comment">;I[B)V</span>
</code></pre><p><strong>Code属性（方法实现）</strong>：</p>
<pre><code>Code:
      <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">4</span>
         <span class="number">0</span>: aload_0
         <span class="number">1</span>: aload_1
         <span class="number">2</span>: putfield      <span class="preprocessor">#<span class="number">1</span>                  <span class="comment">// Field this$0:Lcom/jvm/showByteCode/FinalParameter;</span></span>
         <span class="number">5</span>: aload_0
         <span class="number">6</span>: iload_2
         <span class="number">7</span>: putfield      <span class="preprocessor">#<span class="number">2</span>                  <span class="comment">// Field val$a:I</span></span>
        <span class="number">10</span>: aload_0
        <span class="number">11</span>: aload_3
        <span class="number">12</span>: putfield      <span class="preprocessor">#<span class="number">3</span>                  <span class="comment">// Field val$bytes:[B</span></span>
        <span class="number">15</span>: aload_0
        <span class="number">16</span>: invokespecial <span class="preprocessor">#<span class="number">4</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span>
        <span class="number">19</span>: <span class="keyword">return</span>
</code></pre><p>外围类中testFinal方法中调用匿名内部类的部分：</p>
<pre><code><span class="number">10</span>: invokespecial <span class="preprocessor">#<span class="number">3</span>                  <span class="comment">// Method com/jvm/showByteCode/FinalParameter$1."&lt;init&gt;":(Lcom/jvm/showByteCode/FinalParameter;I[B)V</span></span>
</code></pre><p>这里我们就可以清楚看到以下事实：<br><strong>（1）<init>方法有4个参数，其中第一个是this，另外三个分别类型分别FinalParameter，int，byte数组；<br>（2）它们参数被赋值给了对应的final字段（this$0，val$a，val$bytes）；<br>（3）外围类将当前实例对象引用，a数值，bytes数组引用传递给了FinalParameter$1的<init>()方法；</init></init></strong></p>
<p>因此，我们可以知道，在匿名内部类中使用外围类方法的局部变量，实际上是使用对应值（引用）的final成员变量。<br>内部类中使用的是该局部变量的<strong>副本</strong>，因此如果要在语义上保证<strong>局部变量和副本的一致性</strong>，就应当使<strong>用final来保证该局部变量不变</strong>。</p>
<p>#2. Java 8中“改进”：</p>
<p>下段代码通过了基于JDK8的编译，但是如果将注释去掉，仍然不能通过编译，看来只是在写法上“省力”了。<br>也就是说，Java中对于内部类使用局部变量的设计思想还要要保证这两个变量（一是局部变量，而是内部类的成员变量）一致性；<br>如果你不想保证这样的一致性，我觉得可以有以下方案：<br><strong>（1）可以创建一个抽象类，添加一个构造器，通过构造器传入局部变量的值；<br>（2）编写一个一个工厂方法（或工厂类），局部变量传入工厂方法（工厂方法的对应参数是final的）返回一个内部类实例；</strong><br>这样你就不用给局部变量设置为final；<br>因此，Java设计团队的设计思想是程序员在内部类中使用了局部变量，这种情况应该默认为需要保持两个变量的一致性。</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">testFinal</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>{
        <span class="keyword">int</span> a = <span class="number">10</span>;
        <span class="keyword">new</span> A() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{
                System.out.println(a + <span class="string">" "</span> + bytes.length);
            }
        };
<span class="comment">//        a = 11;</span>
<span class="comment">//        bytes = null;</span>
    }
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2015-11-28-Java基础知识总结（三）——类和接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/2015-11-28-Java基础知识总结（三）——类和接口/" class="article-date">
  	<time datetime="2015-11-29T08:42:04.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/2015-11-28-Java基础知识总结（三）——类和接口/">Java基础知识总结（三）——类和接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>更新</strong>：<br>2015/11/28更新：增加多态中向上转型，方法重载，动态绑定有关编译/类加载/分派相关知识整理；</p>
<hr>
<p>主要是从面向对象的几个特性：封装、继承（复用）、多态的顺序总结Java有关的基础知识，它们的核心目的就是解耦和复用。<br><strong>从接口和实现分离的角度</strong>：<br><strong>封装</strong>：定义了“什么可以做和什么不可做”；<br><strong>继承和组合</strong>：提供了复用的两种手段；<br><strong>多态</strong>：定义了“做什么和怎么做”；<br><strong>接口和内部类</strong>：使得接口和实现分离更加结构化，都是是Java实现多重继承的变种手段；</p>
<h1 id="1-_访问控制权限：">1. 访问控制权限：</h1><h2 id="1-1_访问控制权限的种类：">1.1 访问控制权限的种类：</h2><p>私有：private，default-private（包访问权限）；<br>保护：protected，protected也给予了包访问权限；<br>公有：public；</p>
<h2 id="1-2_为什么要访问控制权限：">1.2 为什么要访问控制权限：</h2><p>信息隐藏：私有权限可以增强内聚性，便于之后的版本更新；公有权限说明对外界的承诺，必须兼容。</p>
<h2 id="1-3_重要概念：">1.3 重要概念：</h2><p>编译单元：一个Java源代码文件，最多顶层可以有一个public类，该类的名称必须与文件名相同；<br>封装：具体实现的隐藏。把数据和方法包装进类中，以及具体的实现隐藏，共同称为封装；<br>接口和实现：将访问控制的界限放在类的内部是为了（1）控制客户端程序员的访问；（2）接口和实现的分离；</p>
<h2 id="1-2_最小化访问权限的要点：">1.2 最小化访问权限的要点：</h2><p>（1）只用一个类使用的顶层类，可以变成嵌套类；<br>（2）Serializable可以导致意外的“信息泄漏”；<br>（3）公有类的protected声明也是一种对外的承诺，必须保证兼容；<br>（4）子类不能降低父类成员和方法的权限，父类的方法/域如果是protected的子类可以提升为public，如果是父类中是private的，子类中同签名方法是一个新方法而不是重写；<br>（5）接口的方法是public的，域是public static final的；</p>
<h2 id="1-3_不应该公开的域：公开会导致多线程环境下的不安全和漏洞：">1.3 不应该公开的域：公开会导致多线程环境下的不安全和漏洞：</h2><p>（1）实例域；<br>（2）静态域（除了一些全局final变量）；<br>（3）final域中不应该包含非final的引用；<br>（4）引用数组域不应该公开，即使数组是final的，数组元素也不是（使用保护性拷贝，Collections.unmodifiableList等，返回clone数组等）；</p>
<p>PS：在公有类中使用访问方法而不是公有域；</p>
<hr>
<h1 id="2-_每个类都有的方法：">2. 每个类都有的方法：</h1><p>共有9个方法：equals，hashCode，clone，getclass，toString，wait（3个重载版本），notify，notifyAll，finalize；</p>
<h2 id="2-1_覆盖equals的通用约定：">2.1 覆盖equals的通用约定：</h2><h3 id="2-1-1_不需要覆盖得到有意义的equals的情况：">2.1.1 不需要覆盖得到有意义的equals的情况：</h3><p>（1）类的每个实例本质上是唯一的（包括全局唯一单例，枚举等）；<br>（2）不关心类是否提供了“逻辑相等”的测试功能；<br>（3）超类已经覆盖了equals，从超类继承equals方法也是合适的；<br>（4）类是私有或包级私有的，可以 确定它的equals永远不会被调用，可以覆盖它抛出异常；</p>
<h3 id="2-1-2_等价关系：">2.1.2 等价关系：</h3><p>（1）自反性；<br>（2）对称性：在子类覆盖equals时，如果增加的了新的属性比较，父类调用equals为true时，子类调用可能就会为false；<br>（3）传递性：如果在上面的情况保证对称性，传递性可能就无法保证；<br>（4）一致性：只要不修改，多次调用结果一致；<br>（5）非空性：对于任何非null引用x，x.equals(null)必须返回false；</p>
<h3 id="2-1-3_覆盖equals的注意：">2.1.3 覆盖equals的注意：</h3><p>（1）无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定；<br>（2）使用getClass来代替instanceof的方法，也限制了在扩展新子类的情况下，保证一些父类的功能；<br>（3）使用复合代替继承，或者使用抽象父类；<br>（4）java.sql.TimeStamp违反了对称性，不要在Set中混合使用TimeStamp和Date（jdk1.7及以上没有这个问题因为在TimeStamp中getTime计算了nanos的值）；<br>（5）java.net.URL的equals依赖对URL中主机IP的比较，而主机名和IP需要DNS，可能造成不确定的结果；</p>
<h3 id="2-1-4_覆盖equals的好做法：">2.1.4 覆盖equals的好做法：</h3><p>（1）覆盖equals时总要覆盖hasCode，以免equals相等而hashCode不相等，导致HashMap/Set等不能正常工作；<br>（2）对float和double进行特殊处理，因为存在Float.NaN，-0.0f等情况；</p>
<h2 id="2-2_覆盖hashCode方法：">2.2 覆盖hashCode方法：</h2><h3 id="2-2-1_Object规范中hashCode的约定：">2.2.1 Object规范中hashCode的约定：</h3><p>（1）如果两个对象equals为true，hashCode返回的结果必须相等；<br>（2）如果两个对象equals为false，hashCode返回的结果不一定要不同，但是不同可以提高散列性能；<br>（3）一致性：如果涉及的值没有修改，返回值必须一致；</p>
<h3 id="2-2-2_好的散列函数：为不相等的对象产生不相等的散列值">2.2.2 好的散列函数：为不相等的对象产生不相等的散列值</h3><p>（1）引用域递归调用hashCode方法；<br>（2）使用31作为系数，一是奇素数防止偶数乘法溢出信息丢失，二是编译器会优化成(i&lt;&lt;5) - i；<br>（3）不可变类的hashCode计算一次可以缓存；</p>
<h2 id="2-3覆盖clone方法：">2.3覆盖clone方法：</h2><p>Object虽然提供了clone方法，但是没有实现Cloneable接口，它让需要的子类去实现，如果一个类没有实现Cloneable接口就调用clone方法，会抛出CloneNotSupportedException异常；<br>覆盖clone方法注意：<br>（1）super.clone()是原始对象的复制，复制的是基本类型和引用值，也就是浅拷贝；<br>（2）通过JDK1.5提供的协变返回类型，可以将clone的返回修改为具体的类型；<br>（3）数组需要调用它的clone方法进行递归的复制，并且编译器会将array.clone()方法类型转换成我们需要的；<br>（4）对于链表结构的对象，需要自己实现深拷贝方法，使用迭代优于递归；<br>（5）不要在clone方法中调用任何可被覆盖的方法；<br>（6）专门为了继承而设计的类，不要实现Cloneable接口，由子类决定；</p>
<p>PS：拷贝工厂和拷贝构造器提供另一种选择；</p>
<h2 id="2-4_实现Comparable接口：">2.4 实现Comparable接口：</h2><p>comparable的行为和特定和equals等价关系很像。<br>注意：<br>（1）comparable结果为0,equals结果为true是约定，但是不一定实现，BigDecimal类，就违反了这个约定，new BigDecimal(“1.0”)和new BigDecimal(“1.00”)的equals结果为false，但是使用TreeSet而不是HashSet就会发现，它们是相等；<br>（2）CompareTo方法依赖与参数化，而不是类型检查；<br>（3）对于整型可以用&gt;,&lt;，浮点型应该用Double.compare和Float.compare方法；<br>（4）注意在使用差值计算比较大小时可能出现的溢出问题（正数减负数）；</p>
<hr>
<h1 id="3-_复用类（组合，has-a和继承，is-a）：">3. 复用类（组合，has-a和继承，is-a）：</h1><h2 id="3-1_复用与初始化：">3.1 复用与初始化：</h2><p>（1）组合：主要有4种初始化形式：<br>a.在定义处进行初始化，在构造器调用前就会进行初始化；<br>b.实例初始化；<br>c.惰性初始化；<br>d.构造器中进行初始化；</p>
<p>（2）继承与初始化：<br>构造器调用链（栈）：先调用基类的构造器；<br>因此在子类的构造器中需要在其他所有语句前显调用父类的构造器，如果是默认构造器，编译器会自动补上；</p>
<h2 id="3-2_复用与清理：">3.2 复用与清理：</h2><p>继承中的清理：<br>finalize方法会显调用子类的再调用父类的（如果覆盖了的话），但它不能保证资源被及时释放；<br>使用自定义dispose()方法时，要注意调用父类的super.close/dispose方法，调用顺序保证和finalize相同；</p>
<h2 id="3-3_继承中的方法覆盖和重载：">3.3 继承中的方法覆盖和重载：</h2><p>（1）子类中可以覆盖和重载父类的非私有方法（C++并不是这样）；<br>（2）继承的类和接口之间，接口和接口之间有相同的方法，签名一致，返回类型一致，可以“共用”一个方法；</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseClass</span> </span>{
    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>{
        <span class="function"><span class="keyword">void</span> <span class="title">i</span><span class="params">()</span></span>;
    }

    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">R</span> </span>{
        <span class="function"><span class="keyword">void</span> <span class="title">i</span><span class="params">()</span></span>;
    }

    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{
        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span></span>;
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">I</span>, <span class="title">R</span> </span>{
        <span class="comment">//可以用内部类来模拟多重继承解决意外的“重名”</span>
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>{

        }
    }
}
</code></pre><p>（3）继承的类和接口之间，接口和接口之间有相同的方法，签名一致，返回类型不一致，会产生冲突，可以通过组合和内部类解决；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RI</span> </span>{
        <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>{
            <span class="function"><span class="keyword">void</span> <span class="title">i</span><span class="params">()</span></span>;
        }

        <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">R</span> </span>{
            <span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">()</span></span>;
        }

        <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{
            <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span></span>;
        }

        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">RI</span>.<span class="title">A</span> <span class="keyword">implements</span> <span class="title">RI</span>.<span class="title">I</span> </span>{
            <span class="comment">//可以用内部类来模拟多重继承解决意外的“重名”</span>
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>{
            }

            <span class="keyword">public</span> RI.<span class="function">R <span class="title">makeR</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> <span class="keyword">new</span> RI.R() {
                    <span class="annotation">@Override</span>
                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">i</span><span class="params">()</span> </span>{
                        <span class="keyword">return</span> <span class="number">0</span>;
                    }
                };
            }
        }
    }
</code></pre><h2 id="3-4_向上转型：">3.4 向上转型：</h2><p>向上转型一般是安全，导出类是基类的超集；</p>
<h2 id="3-5_final关键字：使可变性最小化（典型的：String类）">3.5 final关键字：使可变性最小化（典型的：String类）</h2><h3 id="3-5-1_final使用情况：">3.5.1 final使用情况：</h3><p>（1）final域：注意必须要在使用前进行初始化（实例初始化器或构造器）；<br>（2）final参数；<br>（3）final方法：<br>方法锁定，防止继承修改；<br>不要用它来优化效率；<br>所有的private方法隐式地是final的（子类的同名方法不是Override是一个新方法）；<br>（4）final类：防止继承，所有的方法都是隐式final的；</p>
<h3 id="3-5-2_不可变创建的准则：">3.5.2 不可变创建的准则：</h3><p>（1）不要提供任何会修改状态的方法；<br>（2）保证类不被扩展（private和final声明）；<br>（3）所有域是final的；<br>（4）所有域是私有的（private和包级私有）；<br>（5）保证对任何可变组件的互斥访问，如果存在非final引用，确保客户端程序不能获取它（保护性拷贝）；</p>
<h3 id="3-5-3_不可变对象的创建：">3.5.3 不可变对象的创建：</h3><p>（1）通过构造器注入可变对象来初始化，一定要进行保护性拷贝；<br>（2）如果域之间存在约束条件，在创建前进行检查，创建之后状态不变，保证约束条件不变；<br>（3）通过静态工厂valueOf+享元模式，可以减少新对象的创建（比如，Integer等的valueOf，Integer的享元通过数组保存对象引用，字符串常量池等）；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> String a;
    <span class="keyword">private</span> Inner inner;
    <span class="comment">//通过实例初始化赋值final域</span>
    {
        a = <span class="string">"final"</span>;
    }
    <span class="comment">//这是不安全的做法，客户端可以在外部修改inner</span>
<span class="comment">//    public FinalTest(Inner inner) {</span>
<span class="comment">//        this.inner = inner;</span>
<span class="comment">//    }</span>
    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(Inner inner)</span> </span>{
        <span class="comment">//Inner是非final类，调用它的clone方法并不安全，因为可被子类覆盖</span>
<span class="comment">//        this.inner = inner.clone();</span>
        <span class="comment">//这是一个安全的做法，因为我们使用了明确的构造器</span>
        <span class="keyword">this</span>.inner = <span class="keyword">new</span> Inner(inner.a);
    }

    <span class="comment">//对于没有实现cloneable接口的类，调用clone方法会抛出异常（Object中的clone是protected和native的）</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{
        <span class="keyword">private</span> <span class="keyword">int</span> a;

        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{
            <span class="keyword">this</span>.a = a;
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> Inner <span class="title">clone</span><span class="params">()</span> </span>{
            Inner inner = <span class="keyword">null</span>;
            <span class="keyword">try</span> {
                inner = (Inner)<span class="keyword">super</span>.clone();
                inner.a = a;
            } <span class="keyword">catch</span> (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            <span class="keyword">return</span> inner;
        }
    }
}
</code></pre><h3 id="3-5-4_不可变对象的优点：">3.5.4 不可变对象的优点：</h3><p>（1）线程安全的，可以安全的共享；<br>（2）不用实现clone方法，可以直接使用；<br>（3）内部信息可以共享，比如String的substring方法返回的是指向同一final数组的新String对象引用；<br>（4）hashCode值可以计算一次缓存起来；</p>
<h3 id="3-5-5_不可变对象的缺点：">3.5.5 不可变对象的缺点：</h3><p><strong>问题1</strong>：[真正意义的缺点]由于不能修改，在一些变值的操作中可能产生大量的对象；<br><strong>解决</strong>：提供配套类进行操作，使用享元模式缓存（字符串常量池等），比如StringBuilder于String；<br><strong>问题2</strong>：不可变类如果包含一个或多个可变对象的域在序列化时并不安全（伪字节流攻击，内部域盗用）；<br><strong>解决</strong>：<br>（1）提供保护性拷贝的readObject方法：<br>必须提供一个readObject方法；<br>在readObject中进行保护性拷贝，并检查约束条件，不满足则抛出InvalidObjectException；<br>注意使用readObject中的保护性拷贝，域的final的关键字要去掉；<br>（2）readResolve方法和枚举类型：<br>因为单例模式中我们也经常使用private static final；<br>无论使用默认的序列化形式，还是自定义序列化形式，是否提供readObject无关，都会创建新的实例，违反了“单例”的要求；<br>a.使用readResolve方法，直接返回单例引用，新建的引用丢弃：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadResolveWrapper</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReadResolveWrapper SINGLETON = <span class="keyword">new</span> ReadResolveWrapper();
    <span class="comment">//所有的域都应该是transient的</span>
    <span class="keyword">private</span> <span class="keyword">transient</span> A a = <span class="keyword">new</span> A();

    <span class="function"><span class="keyword">private</span> <span class="title">ReadResolveWrapper</span><span class="params">()</span> </span>{}

    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> SINGLETON;
    }
}
</code></pre><p>b.使用枚举类型来实现单例；<br>（3）序列化代理代替序列化实例（静态内部类，性能比保护性readObject要高，但是可以使用final关键字，更加稳定）：<br>序列化代理的默认序列化形式是外围类最好的序列化形式：<br>局限：一是不能与可以被客户端扩展的类兼容；二是不能与对象图中包含循环的某些类相兼容；</p>
<p>##3.6 继承与类加载和初始化：</p>
<p>过程概述（下面说的子类是代码中的直接使用类，相对于它的父类）：<br>（1）[类加载]：先检查是否有基类，直到检查到一个尚未被加载的根基类。先加载根基类基类，再加载其子类，依次类推，类加载的过程是先父后子的；<br>（2）[类初始化]：如果访问一个子类，如果父类没有初始化，会先初始化父类；<br>（3）[实例初始化和构造器]：先进行父类的实例初始化并调用构造器，再进行子类的实例初始化并调用子类的构造器器；</p>
<h1 id="4-_多态（向上转型，方法重载和动态绑定）：">4. 多态（向上转型，方法重载和动态绑定）：</h1><p>多态是什么：<br>多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行；<br>多态的作用：<br>接口和实现分离的另一角度的设计，之前已经提到通过访问控制权限来封装进行接口和实现的分离。<br>消除类型之间的耦合关系，使得程序代码获得了可扩展性。<br>多态建立在继承或者接口实现，重写等机制的基础上，接口和实现的分离，主要的方式之一就是向上转型和动态绑定；</p>
<p>PS：下面会概括的解释向上转型，方法重载和动态绑定在编译，类加载或运行时的实现原理，其中编译时验证和类加载时的验证都是必要，类加载时的验证是为了避免伪造的字节码，因为Java是基于开放来源的二进制字节流的Class文件可能来自于网络等。</p>
<hr>
<h2 id="4-1_向上转型：">4.1 向上转型：</h2><p>把某个对象的引用作为对其基类的引用；<br>注意：<br>（1）子类以父类的身份出现；<br>（2）子类在工作时，有自己的代码实现；<br>（3）子类以父类的身份出现时，子类特有的方法和属性不能使用；</p>
<p>实现和保证：<br>（1）编译时，在语义分析阶段，在Attr标注检查阶段，委托com.sun.tools.javac.comp.Check来检查方法返回类型与接受的引用类型之间是否匹配；<br>（2）类加载时，在字节码验证阶段，检查方法体中的类型转换是否有效，子类对象赋值给父类数据类型是安全的，父类对象赋值给子类数据类型是不合法的；<br>（3）数据流验证具有复杂性，JDK1.6后通过Code属性表的“stackMapTable”属性，它描述了方法体中基本块本地变量表和操作栈的应用状态，通过类型检查而不是类型推导效率更高。</p>
<h2 id="4-2_方法重载（静态分派/解析）：">4.2 方法重载（静态分派/解析）：</h2><p>方法重载是编译/解析时确定的，因此有些人不认为它属于“多态”，不过这里还是一起联系讨论一下。<br>形如SuperClass subClass = new SubClass();<br>SuperClass是subClass的静态类型，SubClass是其动态类型；</p>
<p>实现和保证：<br>编译时，编译器根据调用方法的简单名称和参数数量以及参数的静态类型，根据优先级决定使用哪一个版本，将方法的符号引用写到invoke～指令的参数中；</p>
<p>重载的优先级：以静态类型为char的变量为例，优先级与转型相关<br>（1）char类型本身，如f(char)；<br>（2）宽化转型类型，顺序char,int,long,float,double，f(int)等；<br>（3）自动装箱类型：Character；<br>（4）父类/实现接口：如Serializable，同理在没有f(SubClass)是subClass（静态类型为SubClass）可以匹配f(SuperClass)；<br>类/接口实现体系中越往上层，优先级越低，存在同一优先级具有模糊性，编译会报错。<br>（5）可变参数列表：如f(char…c)优先级最低；</p>
<p>PS：实际中不应该设计如此复杂的重载版本方法；</p>
<h2 id="4-3_动态绑定（动态分派）：">4.3 动态绑定（动态分派）：</h2><p>实现多态的原理就是动态绑定（后期绑定，运行时绑定），区别与编译时进行的静态绑定，动态绑定通过对象中的类型信息在运行的时候决定具体的调用方法。</p>
<p>Java中哪些是动态绑定的：<br>非final（包括private）方法的实例方法都属于动态绑定的，也就是通过invokevirtual和invokeinterface两个指令处理的调用；</p>
<p>Java中哪些不是动态绑定的：<br>域（成员变量），static方法，private方法（private是隐式final的）都是前期绑定的，也就是编译的时候进行绑定，它们不存在多态行为；<br>因此前面提过的private方法在子类中定义同名的方法，并非是“覆盖”而是一个新的方法，JVM不会用invokevirtual指令来处理它，而是invokespeical指令；<br>对于final方法，final虽然通过invokevirtual指令调用，但是它是非虚方法，在类解析阶段就可以确定调用方法版本。</p>
<p>实现和保证（invokevirtual指令的多态查找，基于Hotspot实现）：<br>（1）取得操作数栈栈顶元素（直接引用）所指向的对象的实际类型，记作C；Hotspot过程是通过直接引用找到堆中的实例数据，根据对象头中的类型指针找到方法区中Class对象；<br>（2）如果在类型C中找到与常量池中的描述符和简单名称都相符的方法，进行符号引用验证，检查访问权限，成功，返回方法的直接引用查找结束，失败，抛出java.lang.IllegalAccessError；<br>（3）如果没有在类型C中找到，按照继承关系从下往上对C的各个父类进行第2步的查找过程；<br>（4）如果最后没有找到合适的方法，抛出java.lang.AbstractMethodError；</p>
<p>JVM动态分派实现：<br>优化的必要性：虚方法调用是最为频繁的，因此如果每次调用同一个方法都按照继承链查找效率太低；<br>解决方法：虚方法表/接口方法表<br>（1）子类如果没有实现某个方法，同样会包含父类方法的地址入口等信息；<br>（2）具有相同签名的方法，在父类、子类的虚方法表中具有一样的索引序号，在类型转换时按索引转换出所需的入口地址；<br>（3）初始化，在类加载的连接阶段（包括验证，准备，解析）进行初始化方法表，准备（准备阶段）类的变量初始值后，虚拟机将该类的方法表也初始化完毕；<br>PS：另外还有内联缓存，守护内联两种非稳定的优化手段。</p>
<h2 id="4-4_实例初始化和多态：">4.4 实例初始化和多态：</h2><p>在构造器，clone方法，readObject方法中不要使用可覆盖的方法；原因在于可覆盖方法在构造时通过invokevirtual会使用对象在继承树中最低类型的方法实现，如果依赖于子类的成员变量，可能不能得到正确的初始化而产生错误。</p>
<h2 id="4-5_协变返回类型：">4.5 协变返回类型：</h2><p>导出类的被覆盖方法可以返回基类方法返回类型的某个派生类型；</p>
<h2 id="4-6_用继承进行设计：">4.6 用继承进行设计：</h2><h3 id="4-6-1_什么时候使用继承：">4.6.1 什么时候使用继承：</h3><p>存在明确“is-a”关系时才使用继承；<br>明确需要使用“向上转型”的情况需要使用继承；<br>用继承表达行为间的差异，用字段（组合）表达状态上的变化；<br>（1）为继承而设计的类要编写文档说明（包括方法间的依赖关系）；<br>（2）不要在构造器，clone，readObject中调用可被覆盖的方法，也就是说在这些方法中使用动态绑定并不安全；<br>（3）回调框架不适合使用组合；</p>
<p>PS：禁止类实例化，（1）private构造器；（2）abstract声明类；</p>
<p>“is-like-a”关系：<br>继承中除了向上转型，即使存在“is-a”关系软件开发的需求的变化使得需要依赖派生类型的特性成为可能。<br>Java中对象是带有类型信息的，通过运行时类型识别（反射），判断或者转换为具体的派生类。<br>Java所有的转型都是经过判断的，通过checkcast指令，错误抛出ClassCastException；</p>
<h3 id="4-6-2_组合（复合）优于继承：">4.6.2 组合（复合）优于继承：</h3><p>如果同一个包中使用继承没有什么问题；<br>跨包继承可能出现的问题：<br>（1）破坏了封装性，子类随着超类的改变可能不安全；<br>比如，HashSet中addAll通过add方法实现的，这种关系可能带来子类的不正确的行为，而这种可覆盖方法间的关系并不是“承诺”而是具体实现；<br>（2）超类中添加了新的方法，可能会破坏子类的一些约束条件；<br>（3）子类中添加了新的方法，可能因为父类之后添加新的同名（返回类型不同）方法而出错；<br>（4）单继承限制了子类的扩展能力；</p>
<hr>
<h1 id="5-_接口：">5. 接口：</h1><h2 id="5-1_抽象类和抽象方法：">5.1 抽象类和抽象方法：</h2><p>防止类实例化，abstract方法必须包含abstract类；<br>抽象类和重构：<br>抽象类是很有用的重构工具，当发现存在公共方法时，可以将它上移放到抽象类中，这也是模板方法模式的体现；</p>
<h2 id="5-2_接口：">5.2 接口：</h2><p>接口本身可以选择public，默认包权限，private，protected；<br>接口中的域是public static final的；<br>接口中的方法是public的，实现接口时只能将接口方法实现为public的，因为Java编译器不允许降低访问权限；</p>
<h2 id="5-3_完全解耦，接口优于抽象类：">5.3 完全解耦，接口优于抽象类：</h2><p>（1）Java中类之间只允许单继承，如果在方法参数等地方使用类，那只能限制于这个类及其子类对象传入，使用接口可以避免耦合于类型；<br>（2）单继承的另一个问题是导致“类的组合爆炸”，如果方法要接受两种类体系的类，必须提供一个要增加一个公共的祖先，而通过接口，让需要传入的对象，实现这个接口就可以了；</p>
<p>在客户端代码中使用依赖于接口，而不是类，进一步增强可扩展性和复用性；</p>
<p>抽象类和接口的结合使用：<br>（1）结合接口和抽象类，在提供接口体系的同时，通过AbstractInterface提供骨架类，提供一些基本的实现；<br>（2）抽象类往往位于接口体系的“底层”，因为这样功能体系基本稳定，而且抽象类专为继承实现，而且只提供最核心和基础的共同的实现，典型的例子Java Collections Framework，Spring BeanFactory Framework；</p>
<h2 id="5-4_接口与多重继承：">5.4 接口与多重继承：</h2><h3 id="5-4-1_通过继承扩展接口：">5.4.1 通过继承扩展接口：</h3><p>用接口层次代替类层次；</p>
<h3 id="5-4-2_接口和类“多重继承中”名称冲突：">5.4.2 接口和类“多重继承中”名称冲突：</h3><p>（1）如果要实现的接口或者类中，用方法签名相同（名称和参数列表），但返回类型不同的，无法直接同时实现/继承；<br>（2）即使返回类型相同，也不能保证两个接口/类的同名方法应该用同一个实现而没有问题；<br>（3）对于包含同名方法的接口，使用组合而不是实现/继承，用内部类实现接口/类，通过返回一个内部类的实例（闭包）来避免名称冲突；</p>
<h2 id="5-5_接口域与初始化：">5.5 接口域与初始化：</h2><p>（1）接口中的域是public static final的；<br>（2）接口只用来只用来定义类型，用接口存放常量是一种反模式；<br>（3）接口中域的初始化发生在该接口中某个域被一次访问时；<br>（4）接口的初始化与类不同，子接口的初始化不会导致先初始化父接口；</p>
<h2 id="5-6_嵌套接口：">5.6 嵌套接口：</h2><p>（1）接口中不能嵌套包含private接口；<br>（2）接口中也可以嵌套包含class，是public static的；<br>（3）接口中的方法是public的，域是public static final的，接口和类是public static的；<br>（4）class中可以包含private接口，这样可以防止向外部返回它的任何实现；</p>
<hr>
<h1 id="6-_内部类：">6. 内部类：</h1><h2 id="6-1_内部类的种类：">6.1 内部类的种类：</h2><p>（1）静态成员类；<br>（2）非静态成员类；<br>（3）局部内部类：任何可以定义局部变量的地方都可以定义局部内部类，主要用于复用；<br>（4）匿名内部类；</p>
<h2 id="6-2_内部类与闭包的实现：">6.2 内部类与闭包的实现：</h2><p>通过接口+私有内部类，可以创建“闭包”，客户端代码无法访问到具体的类型，同时私有内部类可以获取到外围类对象的状态；<br>Java中使用这种闭包的例子：<br>List等集合类中的Iterator的实现；</p>
<h2 id="6-3_4种内部类的要点：">6.3 4种内部类的要点：</h2><h3 id="6-3-1_非静态成员类：">6.3.1 非静态成员类：</h3><p>（1）创建：.new，在外部创建一个外围类C的内部类用：c.new关键字；；<br>（2）构造器：经过编译器编译获取了外围类的this指针作为内部类的成员变量：this$0；</p>
<p>编译器为非静态内部类生成一个带有外围类类型的参数，用来注入外围类的引用；</p>
<h3 id="6-3-2_匿名内部类：">6.3.2 匿名内部类：</h3><p>（1）匿名内部类的创建：可以用类，抽象类，接口来定义匿名内部类，匿名内部类其实是它们的派生类；<br>（2）匿名内部类的构造器：不能手动定义构造器，Java编译器会根据使用的基类的构造器，为匿名内部类生成一个带有基类类型的参数的构造器，同时为匿名类添加一个基类类型的成员变量，通过构造器设置这个变量包含外围类的引用；<br>虽然不能创建构造器，但是可以使用实例化器；<br>（3）匿名内部类的名称：默认是基类名称$n，n是调用类中第n个匿名内部类，这是一种编译器的内部机制，尽管可以通过这个名称使用反射获取指定构造器来创建匿名内部类对象，但这不是匿名内部类应该有的用法；<br>（4）匿名内部类不能再进行扩展；</p>
<h3 id="6-3-3_静态成员类：">6.3.3 静态成员类：</h3><p>（1）类初始化：与外围类没有直接关系，类初始化的触发条件仍然和普通类一样，5点；<br>（2）实例化：与外围类没有直接关系；<br>（3）不能从静态成员类内部访问外围类的非静态成员和方法；</p>
<h3 id="6-3-4_局部内部类：">6.3.4 局部内部类：</h3><p>主要是为了复用和局部使用需要一个重载的构造器，否则一般不会用；<br>只要能定义局部变量的地方就可一定义；<br>它的“作用域”和局部变量一样；<br>不能有访问修饰符；<br>可以访问外围的成员和代码块的常量；</p>
<h2 id="6-4_内部类的作用：">6.4 内部类的作用：</h2><p>（1）多重继承：<br>内部类和接口是解决Java多重继承的方案；<br>接口可以在设计的时候，将一些通用的功能设计成接口，但是对于系统中已经有的类，想要多重继承多个类，只能使用内部类的方式实现；<br>使用内部类可以解决接口/类继承时的名称冲突；</p>
<p>（2）闭包和回调：<br>由于内部类可以访问外围的所用状态（包括private的），因此实际上它是一个“闭包”；<br>Java中没有函数指针，因此回调，通过“函数对象”实现，闭包可以作为回调对象传递给调用者；<br>类似的用法：Thread+runnable（命令模式），事件监听（观察者模式）等等；</p>
<h2 id="6-5_内部类的继承：">6.5 内部类的继承：</h2><p>构造器的实现：<br>继承一个非静态内部类时，外围类.super()并不是在调用外围类的基类构造器，而是要继承的内部类的构造器，这是一种特殊的语法，相同的还有“外围类.new”想到这.new应该就不会对”.super”过于纠结了吧。<br>外围类实现：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>
    <span class="type">A</span>() {
        <span class="type">System</span>.out.println(<span class="string">"A"</span>);
    }
}

public <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">A</span> {</span>
    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> {</span>
        public <span class="type">Inner</span>(int x) {

        }
    }
}
</code></pre><p>继承内部类：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">InnerExtend</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">InnerClassTest</span>.<span class="title">Inner</span> {</span>
    public <span class="type">InnerExtend</span>(<span class="type">InnerClassTest</span> test, int x) {
        test.<span class="keyword">super</span>(x);
    }

    public static void main(<span class="type">String</span>[] args) {
        <span class="keyword">new</span> <span class="type">InnerExtend</span>(<span class="keyword">new</span> <span class="type">InnerClassTest</span>(), <span class="number">1</span>);
    }
}
</code></pre><p>PS 内部类不可以被“覆盖”<br>内部类不可以被覆盖，继承一个外围类时，即使提供一个同名的内部类也不是覆盖，查看编译之后的class文件可以发现实际上，这个内部类类名是“外围类$内部类”，外围类只是内部类的“命名空间”；</p>
<p><strong>参考资料</strong>：<br>[1] Java编程思想 第4版；<br>[2] Effective Java；<br>[3] 深入Java Web技术内幕；<br>[4] 深入理解Java虚拟机；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础知识/">Java基础知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2015-08-08-我学JVM——对JVM的理解和JVM内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/2015-08-08-我学JVM——对JVM的理解和JVM内存管理/" class="article-date">
  	<time datetime="2015-11-29T08:42:04.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/2015-08-08-我学JVM——对JVM的理解和JVM内存管理/">对JVM的理解和JVM体系结构详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java虚拟机是Java运行的平台和基础。通过字节码技术和JVM才有了Java平台无关性的实现。Java虚拟机是Java运行的平台和基础。通过字节码技术和JVM才有了Java平台无关性的实现。一个Java进程是一个JVM实例，它本身建立在操作系统和磁盘，内存中的堆栈，本地CPU和指令集基础之上，但是Java进程所占的资源又被抽象成了JVM，Java字节码指令（JIT除外）正是。</p>
<h1 id="1-_对JVM的理解">1. 对JVM的理解</h1><p>JVM，顾名思义，它是对计算机的抽象。<br>现代计算机的计算功能有：<strong>指令集，计算单元，存储单元，寻址方式，寄存器</strong>定义组成。对应于JVM，也有自己的指令集，同样有自己的内存布局（存储单元），执行引擎（计算单元和寄存器），通过引用（符号引用和直接引用）来定位资源。</p>
<p>JVM同样具有<strong>公有设计和私有实现</strong>的特性：JVM规范定义了公有的必须实现的规范，各个厂商可以在此规范下具体的实现，每一个Java进程基于一个JVM实例。</p>
<h2 id="1-2_JVM的体系架构">1.2 JVM的体系架构</h2><p>JVM的体系架构包括4个部分：</p>
<ol>
<li><strong>类加载器</strong>；</li>
<li><strong>执行引擎</strong>；</li>
<li><strong>内存区域：运行时数据区域</strong>；</li>
<li><strong>本地方法调用</strong>；</li>
</ol>
<p><img src="https://zerohuan.github.io/images/jvm-memory-structure.png" alt="JVM"></p>
<h3 id="1-2-1_运行时常量池">1.2.1 运行时常量池</h3><p>JVM内存划分几个不同的部分，类加载和线程都是动态分配内存的；类加载器加载class文件（广义上的二进制字节码流）经过加载，连接（验证，准备，解析），类型信息及Class对象到了<strong>方法区</strong>，对象实例到了<strong>堆</strong>，常量到了<strong>运行时常量池（在方法区中）</strong>，线程对应一个执行引擎的实例分配一个<strong>虚拟机栈</strong>，每个方法对一个<strong>栈帧</strong>，每个栈都包含一个<strong>PC寄存器</strong>，本地方法对应<strong>本地方法栈</strong>，而对象实例则保存到了<strong>堆</strong>中。</p>
<p><strong>（1）PC寄存器（PC Register）</strong>：<br>每个线程有自己的PC寄存器。<br>PC寄存器指向下一行字节码指令的地址（这个地址是基于方法Code属性的行号，一个方法的Code_length是u4，实际不能超过65535；还是内存的虚拟地址）。<br>方法调用/返回的关系：<br>（1）方法正常返回时，调用者方法的寄存器值可以作为被调用者的方法返回地址，被调用者正常返回时，栈帧回收，返回值压入被调用者栈帧的操作数栈，PC寄存器可以用这个返回地址恢复到指向调用者方法的下一个字节码指令地址；<br>（2）方法异常返回时，返回地址通过异常表确定。<br>（3）如果是调用natvie方法，PC寄存器中保存值为空（undefined）；</p>
<p><strong>（2）Java虚拟机栈</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Zerohuan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>