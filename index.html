<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Zerohuan的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从CSDN迁徙而来">
<meta property="og:type" content="website">
<meta property="og:title" content="Zerohuan的博客">
<meta property="og:url" content="http://blog.zerohuan.com/index.html">
<meta property="og:site_name" content="Zerohuan的博客">
<meta property="og:description" content="从CSDN迁徙而来">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zerohuan的博客">
<meta name="twitter:description" content="从CSDN迁徙而来">
  
    <link rel="alternative" href="/atom.xml" title="Zerohuan的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zerohuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Talk is cheap, show me the code!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/Java-8集合框架源码/" style="font-size: 14px;">Java 8集合框架源码</a> <a href="/tags/Java基础知识/" style="font-size: 20px;">Java基础知识</a> <a href="/tags/Java并发/" style="font-size: 16px;">Java并发</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 12px;">TCP/IP</a> <a href="/tags/java-web/" style="font-size: 12px;">java web</a> <a href="/tags/思考和求解/" style="font-size: 18px;">思考和求解</a> <a href="/tags/技术更新/" style="font-size: 10px;">技术更新</a> <a href="/tags/杂谈-感悟/" style="font-size: 10px;">杂谈/感悟</a> <a href="/tags/算法和数据结构/" style="font-size: 10px;">算法和数据结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">现南京大学研究生一枚，目前专注于Java Web方向。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Zerohuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Zerohuan</h1>
			</hgroup>
			
			<p class="header-subtitle">Talk is cheap, show me the code!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post- Servlet &amp; Spring对Multipart数据请求的支持" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/13/ Servlet & Spring对Multipart数据请求的支持/" class="article-date">
  	<time datetime="2016-01-13T06:19:44.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/ Servlet & Spring对Multipart数据请求的支持/">Servlet &amp; Spring对Multipart数据请求的支持</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考资料：<br>（1）<a href="http://www.ietf.org/rfc/rfc1867" target="_blank" rel="external">RFC 1867</a><br>（2）Java Servlet Specification 3.1；<br>（3）《Java Web高级编程》；</p>
<h1 id="1-_Multipart_FormData">1. Multipart FormData</h1><p>Multipart是HTML中表单文件上传的基本格式，一般通过如下方法可以通过HTTP上传文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"_URL_"</span> <span class="attribute">method</span>=<span class="value">"POST"</span> <span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"username"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">name</span>=<span class="value">"userfile1"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">value</span>=<span class="value">"submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>有两个地方是使用Multipart的关键：<br>（1）对于POST请求来说，enctype的默认值是application/x-www-form-urlencoded，而这里要是用<code>multipart/form-data</code>；<br>（2）<code>&lt;input /&gt;</code>的type设置为<code>file</code>；</p>
<h2 id="1-1_Multipart的数据格式">1.1 Multipart的数据格式</h2><p>基于Multipart，请求的每个部分都有指定的边界分隔开，都有一个值为form-data的<strong>Content-Disposition</strong>和匹配表单输入名称的<strong>name</strong>。<br>如果是文件类型字段，还将有<strong>filename</strong>，匹配MIME类型的<strong>Content-Type</strong>；<br>使用下面的表单提交单个文件和其他文本域：</p>
<h4 id="测试1：单文件上传">测试1：单文件上传</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"/s/upload/1"</span> <span class="attribute">method</span>=<span class="value">"post"</span> <span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">fieldset</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">legend</span>&gt;</span>测试1：单文件上传<span class="tag">&lt;/<span class="title">legend</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"name"</span>&gt;</span>名称 <span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"name"</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"name"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"files"</span>&gt;</span>文件 <span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"files"</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">name</span>=<span class="value">"files"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"location"</span>&gt;</span>地区 <span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"location"</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"location"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">fieldset</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请求数据内容：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">------WebKitFormBoundaryBDujyAl87MaTQd9J</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">串个沙</span><br><span class="line"><span class="comment">------WebKitFormBoundaryBDujyAl87MaTQd9J</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"files"</span>; filename=<span class="string">"说明.txt"</span></span><br><span class="line">Content-Type: <span class="type">text</span>/plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">------WebKitFormBoundaryBDujyAl87MaTQd9J</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"location"</span></span><br><span class="line"></span><br><span class="line">地球</span><br><span class="line"><span class="comment">------WebKitFormBoundaryBDujyAl87MaTQd9J--</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到每个部分有边界像分隔，这个边界值由客户端决定，是随机生成的（这里我使用chrome做的实验，因此可以看到“WebKit”）。</p>
<h4 id="测试2：多文件上传">测试2：多文件上传</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"/s/upload/1"</span> <span class="attribute">method</span>=<span class="value">"post"</span> <span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">fieldset</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">legend</span>&gt;</span>测试2：多文件上传<span class="tag">&lt;/<span class="title">legend</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"name"</span>&gt;</span>名称 <span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"name1"</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"name"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"files"</span>&gt;</span>文件 <span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"files1"</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">name</span>=<span class="value">"files1"</span> <span class="attribute">multiple</span>=<span class="value">"multiple"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"location"</span>&gt;</span>地区 <span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"location1"</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"location"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">fieldset</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请求头Content-Type：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Content</span>-<span class="constant">Type</span><span class="symbol">:multipart/form-data</span>; boundary=----<span class="constant">WebKitFormBoundaryZGDkB6nM3LvHX0KI</span></span><br></pre></td></tr></table></figure></p>
<p>请求数据内容：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">------WebKitFormBoundaryLnO8YOO2DPoP3M6y</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"name"</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>个文件</span><br><span class="line"><span class="comment">------WebKitFormBoundaryLnO8YOO2DPoP3M6y</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"files1"</span>; filename=<span class="string">"说明.txt"</span></span><br><span class="line">Content-Type: <span class="type">text</span>/plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">------WebKitFormBoundaryLnO8YOO2DPoP3M6y</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"files1"</span>; filename=<span class="string">"说明 (copy).txt"</span></span><br><span class="line">Content-Type: <span class="type">text</span>/plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">------WebKitFormBoundaryLnO8YOO2DPoP3M6y</span></span><br><span class="line">Content-Disposition: form-data; <span class="property">name</span>=<span class="string">"location"</span></span><br><span class="line"></span><br><span class="line">中国</span><br><span class="line"><span class="comment">------WebKitFormBoundaryLnO8YOO2DPoP3M6y--</span></span><br></pre></td></tr></table></figure></p>
<p>基于chrome得到的结果，没有出现一个Content-type为<code>multipart/mixed</code>的嵌套部分，而是用多个文件字段部分表示。</p>
<h1 id="2-_Servlet_3-0对Multipart的支持">2. Servlet 3.0对Multipart的支持</h1><p>在Servlet3.0之前对于文件上传的支持，可以通过Commons FileUpload等第三方工具来实现。Java EE 6中Servlet 3.0新增了对它的支持，这样可以不再依赖第三方库。主要通过HttpServletRequest的<code>getParts()</code>和<code>getPart()</code>方法。<br>结合前面的测试表单，我用一个Servlet和Jsp来演示处理的具体方法：<br>UploadServlet2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@WebServlet</span> (</span><br><span class="line">        name = <span class="string">"uploadServlet2"</span>,</span><br><span class="line">        urlPatterns = <span class="string">"/upload2"</span>,</span><br><span class="line">        loadOnStartup = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="annotation">@MultipartConfig</span> (</span><br><span class="line">        fileSizeThreshold = <span class="number">5_242_880</span>,</span><br><span class="line">        maxFileSize = <span class="number">20_971_520L</span>,</span><br><span class="line">        maxRequestSize = <span class="number">41_943_040L</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">"/p/upload/upload.jsp"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Collection&lt;Part&gt; parts = req.getParts();</span><br><span class="line">        logger.debug(<span class="string">"uploading..."</span>);</span><br><span class="line">        req.setAttribute(<span class="string">"parts"</span>, parts);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">"/p/upload/resolvePart.jsp"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过ServletContainerInitializer配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">       logger.info(<span class="string">"ServletContextListener invoked"</span>);</span><br><span class="line">       <span class="comment">//获取ServletContext对象</span></span><br><span class="line">       ServletContext servletContext = sce.getServletContext();</span><br><span class="line">       <span class="comment">//添加Servlet</span></span><br><span class="line">       ServletRegistration.Dynamic uploadRegistration = servletContext.addServlet(<span class="string">"uploadServlet"</span>, UploadServlet.class);</span><br><span class="line">       uploadRegistration.addMapping(<span class="string">"/upload/*"</span>);</span><br><span class="line">       uploadRegistration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">       MultipartConfigElement configElement = <span class="keyword">new</span> MultipartConfigElement(<span class="string">"."</span>, <span class="number">52428800</span>,</span><br><span class="line">               <span class="number">52428800</span>, <span class="number">0</span>);</span><br><span class="line">       uploadRegistration.setMultipartConfig(configElement);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>必须启用multipart支持，配置一样有三种方法：注解，编程（ServletContextListener/ServletContainerInitializer），XML，但是基本的配置项是一样的：<br><code>location</code>：临时文件目录，一般可以使用默认的由服务器软件决定；<br><code>fileSizehreshold</code>：超过这个阈值放入临时文件目录，否则在内存中有垃圾回收处理；<br><code>maxFileSize</code>和<code>maxRequestSize</code>；</p>
<p>location的配置需要注意，Servlet规范中的说明：</p>
<blockquote>
<p>location元被解析为一个绝对路径且默认为 javax.servlet.context.tempdir。如果指定了相对地址，它将是相对于 tempdir 位置。绝对路径与相对地址的测试必须使用 java.io.File.isAbsolute。</p>
</blockquote>
<h1 id="3-_Spring对Multipart的支持">3. Spring对Multipart的支持</h1><p>服务端主要就是解析Multipart数据。</p>
<p>启用Multipart，这里通过Spring的WebApplicationInitializer初始化器进行配置，本质是通过ServletContainerInitializer。启用指定DispatcherServlet的Multipart支持。还是通过<code>Registration</code>配置的和上面的ServletContextListener一样。这里配置了自定义的临时目录，如果指定的目录不存在或是无法访问，通过”.”配置，因为前面引用的Serlvet规范已经说明了，相对目录是基于容器的临时目录的。</p>
<p>Spring同时兼容了基于Commons FileUpload和Servlet 3.0标准API两种方式的解析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrap</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 略 */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">/* 略 */</span></span><br><span class="line">        DispatcherServlet dispatcherServlet = <span class="keyword">new</span> DispatcherServlet(cgContext);</span><br><span class="line">        dispatcherServlet.setThrowExceptionIfNoHandlerFound(<span class="keyword">true</span>);</span><br><span class="line">        ServletRegistration.Dynamic dispatcherCG = container.addServlet(<span class="string">"cgServlet"</span>,</span><br><span class="line">                dispatcherServlet);</span><br><span class="line">        dispatcherCG.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//文件上传支持</span></span><br><span class="line">        <span class="comment">//设置临时文件目录</span></span><br><span class="line">        File path = <span class="keyword">new</span> File(container.getRealPath(<span class="string">"/tmp/web_yjh_files/"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(path.exists() || path.mkdirs()) &#123;</span><br><span class="line">            dispatcherCG.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">                    path.getAbsolutePath(), <span class="number">200_971_520L</span>, <span class="number">401_943_040L</span>, <span class="number">0</span></span><br><span class="line">            ));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatcherCG.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">                    <span class="string">"."</span>, <span class="number">200_971_520L</span>, <span class="number">401_943_040L</span>, <span class="number">0</span></span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 略 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring提供了一个Multipart的解析器：MultipartResolver，因此在<code>@Configuration</code>类中添加一个Bean，有两种选择<strong>CommonsMultipartResolver</strong>和<strong>StandardServletMultipartResolver</strong>，分别基于Commons File Upload和Servlet 3.0标准API；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>编写Controller method，使用Spring的<code>MultipartFile</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span>(value = <span class="string">"upload"</span>, method = RequestMethod.POST, produces = <span class="string">"text/html"</span>)</span><br><span class="line">   <span class="annotation">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(String username,</span><br><span class="line">                        @RequestParam(value = <span class="string">"attachment"</span>)</span> MultipartFile parts) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success "</span> +</span><br><span class="line">               <span class="string">"name:"</span> + parts.getName() +</span><br><span class="line">               <span class="string">"size:"</span> + parts.getSize() +</span><br><span class="line">               <span class="string">"contentType:"</span> + parts.getContentType() +</span><br><span class="line">               (parts.getContentType() == <span class="keyword">null</span> ? <span class="string">""</span> : (<span class="string">"filename"</span> + parts.getOriginalFilename())) +</span><br><span class="line">               <span class="string">""</span> + IOUtils.toString(parts.getInputStream()) +</span><br><span class="line">               <span class="string">"size:"</span> + parts.getSize();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Part_API：">使用Part API：</h2><p>Serlvet Part的标准API包括：<br>（1）<strong>name</strong>：表单字段名；<br>（2）<strong>size</strong>：Part数据内容的大小；<br>（3）<strong>submittedFileName</strong>：Servlet 3.1新增方法，获取文件名，之前必须通过<code>getHeader(&quot;content-disposition&quot;)</code>解析；<br>（4）<strong>contentType</strong>：如果<code>&lt;input&gt;</code>类型是type这个值是<code>null</code>，如果是文件，可以获得它的MIME类型；<br>（5）<strong>getHeader</strong>：获取指定头；<br>（6）<strong>getInputStream</strong>：获取输入流；</p>
<blockquote>
<p>对于表单数据的 Content-Disposition,即使没有文件名,也可使用 part 的名称通过 HttpServletRequest 的<br>getParameter 和 getParameterValues 方法得到 part 的字符串值。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Multipart解析<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">c:forEach</span> <span class="attribute">items</span>=<span class="value">"$&#123;parts&#125;"</span> <span class="attribute">var</span>=<span class="value">"part"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">h3</span>&gt;</span>Part: $&#123;part.name&#125;<span class="tag">&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">span</span>&gt;</span>Size: $&#123;part.size&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">span</span>&gt;</span>SubmittedFileName: $&#123;part.submittedFileName&#125;，Servlet 3.1新增方法<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">span</span>&gt;</span>ContentType: $&#123;part.contentType&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">c:choose</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">c:when</span> <span class="attribute">test</span>=<span class="value">"$&#123;part.contentType == null || part.contentType eq 'text/plain'&#125;"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">               $&#123;IOUtils.toString(part.inputStream)&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="title">c:when</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">c:when</span> <span class="attribute">test</span>=<span class="value">"$&#123;part.contentType eq 'application/octet-stream'&#125;"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">               $&#123;part.getHeader("content-disposition")&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="title">c:when</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">c:choose</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">c:forEach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">c:import</span> <span class="attribute">url</span>=<span class="value">"upload.jsp"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-web/">java web</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Servlet-Spring对Multipart数据请求的支持" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/13/Servlet-Spring对Multipart数据请求的支持/" class="article-date">
  	<time datetime="2016-01-13T06:19:44.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/Servlet-Spring对Multipart数据请求的支持/">Servlet &amp; Spring对Multipart数据请求的支持</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构的理解和应用——红黑树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/15/数据结构的理解和应用——红黑树/" class="article-date">
  	<time datetime="2015-12-14T18:31:50.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/数据结构的理解和应用——红黑树/">数据结构的理解和应用——红黑树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>心得：看了《数据结构和算法分析》，《算法导论》以及《算法》上关于红黑树的章节，总算把红黑树的实现和操作给理解了一边。虽然插入和删除的情况有些复杂，因为1,2年前看过一次，后来就忘了，感觉还是当时没有真正理解。</p>
<p>因此记住插入和删除的形式是不行的，关键是结合红黑树的5个特点，<strong>理解插入和删除中循环不变式的以及终止条件</strong>。这样才能知道为什么要弄一个“一重额外的黑色”才能知道为什么红黑树一次更新可以在O(1)中完成调整等等。</p>
<p>之后能够在脑海中演练，画画图，理解和AVL的异同要比把代码背下来有价值多了。</p>
<p>PS：《数据结构和算法分析》着重讲解了递归实现，但迭代应该更好一些，Java集合框架中采用的是parent引用+迭代的实现方式。</p>
<h2 id="背景">背景</h2><h3 id="2-3树和2-3-4树">2-3树和2-3-4树</h3><p>B树具有<strong>有序性</strong>和<strong>完美平衡性</strong>，但是插入和删除判断的情况太多了，还且需要额外的开销。通过将2-3树转换成左偏红黑树，2-3-4树转换成完全红黑树，可以用一点代价用更简单的方式处理：<br>以2-3树的转变为例：<br>2-3树中每个键值变为一个独立节点，一个3节点变为两个节点，中间中红色链接相连；<br>条件：<br>（1）红色链接均为左链接；<br>（2）没有任何节点同时和两个红色链接相连，很显然红色节点是一个3-节点分裂的；<br>（3）完美黑平衡（性质5）；<br>相对的2-3-4树红色连接可以左右链接，但是同样不能有上下相邻的两个红色链接。将链接颜色转变为节点的属性，因此可以也就不能有相邻的红色节点（性质4），这条性质很重要，可以保持2-3-4树中4的阶数限制，这是便于操作和O(lgn)操作的保证；</p>
<h2 id="1-_红黑树的基本条件">1. 红黑树的基本条件</h2><p>（1）节点不是黑的就是红的；<br>（2）根节点是黑色的；<br>（3）每个叶节点NIL是黑色的；<br>（4）红色节点的儿子必须是黑色的；<br>（5）每个节点到后代叶节点的简单路径上，均包含相同数目的黑色节点；</p>
<h2 id="2-_红黑树的性能">2. 红黑树的性能</h2><p>一棵有n个内部节点的红黑树的高度至多为2lg(n+1)；</p>
<p>（1）在查找，插入，删除操作的性能都是稳定O(log n)的，插入和删除操作中的上滤会执行O(lgn)次；<br>（2）任何不平衡都会在O(1)次（插入最多2次，删除最多三次）旋转之内解决；</p>
<h2 id="3-_与AVL树的比较">3. 与AVL树的比较</h2><p>（1）时间复杂度与AVL树相同，但统计性能比AVL树更高；<br>（2）如果插入和删除操作比较多，应当选用红黑树，AVL表现较差；<br>（3）如果数据分布较好可以采用AVL树；<br>（4）红黑树每次更新操作的旋转次数为O(1)（不超过3次），适合实现持久化的搜索树；</p>
<h2 id="5-_结构和操作">5. 结构和操作</h2><h3 id="5-1_结构">5.1 结构</h3><p>（1）使用一个共同的NIL叶节点，不过也可以直接直接使用NULL，Java中的实现就没有使用空对象，而是直接的null；<br>（2）5条特性；<br>（3）包含：parent引用，red（boolean），left，right，四个核心域；</p>
<h3 id="5-2_旋转操作">5.2 旋转操作</h3><p>基于p节点的左旋或右旋，主要是3组节点之间指针的调整（以左旋为例）：<br>（1）p节点和其右儿子之间；<br>（2）p的右儿子的左儿子和p之间；<br>（3）p的右儿子和p的父节点之间；</p>
<h3 id="5-3_插入操作（关键在于叔父节点的颜色和x的位置，变色+旋转）">5.3 插入操作（关键在于叔父节点的颜色和x的位置，变色+旋转）</h3><p>插入操作和二叉搜索树一样在叶节点处插入新的节点x，但这个插入节点一开始是红色的，因此可能破坏性质（2）或性质（4）；</p>
<p><strong>被破坏的性质：</strong><br>破坏性质（2）时，x是根节点，直接变为黑色，到所有路径黑高+1，就ok了；<br>破坏性质（4）时，x的父节点xp也是红色的，因此要想办法通过旋转“将一个多余的红色节点转过去”，那么x的叔父节点的颜色就很关键：</p>
<p><strong>修复红黑树平衡条件</strong>：<br><strong>从2-3-4树角度分析，叔父节点是黑色，保证上面是一个3节点，情形一正是因为这时一个4节点，因此要继续上滤；</strong><br>之所以要修复是因为x所在路径上有两个相邻的红色节点（x和xp），那么要想办法通过将一个红色节点（xp）变成黑色。<br>多出来一个黑色怎么办，这样就破坏性质（5）了，需要一次旋转，将祖父节点变成红色（祖父节点原来肯定是黑色，因为父节点是红色），父节点变为黑色旋转成为新的子树根，这样性质（5）保持，x和xp的颜色也正常了。但有个问题，祖父点变为了红色，因此只有在叔父节点是黑色时这样做才可行（否则又多一组相邻的红色节点）。<br>因此要分3种情况来处理，以<strong>xp为祖父节点的左儿子情形</strong>为例（还有一组对称的情形）：<br>PS：x为“新插入节点”，xp为x的父节点，xpp为祖父节点，xppr为x的叔父节点；<br><img src="http://blog.zerohuan.com/images/rbt-insertion.png" alt="插入"></p>
<p><strong>情形1：叔父节点是红色：</strong><br>正如前面说的，这里无法解决问题，只好上滤，将xp和叔父节点变化黑色，祖父节点变成新的x；<br>实际上，可以对应2-3-4树中，xp，xpp，xppr是一个4节点，这时要分裂这个4节点，中键节点（xp节点）上移，xp变为黑色也就是分裂出来和x节点组成一个3节点，xppr变为黑色，变为一个2节点；</p>
<p><strong>情形2：叔父节点是黑色，x是xp的右儿子：</strong><br>前面说了，解决相邻的两个红色节点在于“变色+旋转”，关键是旋转之后，x变成了xpp的左儿子，x是红色，xpp也被变成了红色，因此x是xp右儿子时，也不能直接旋转。</p>
<p>通过一次左旋，将xp变成x的左儿子，这时x指向xp，那么就转化成了情形3；<br>对应一个2-3-4树，2和11节点对应一个3节点，7节点上滤要插入这个3节点，但是颜色分布不对，因此要通过一个左旋，变成情形3，再通过一次右旋更改颜色，这样2,7,11就组成了一个4节点；</p>
<p><strong>情形3：叔父节点是黑色，x是xp的左儿子：</strong><br>xp变为黑色，xpp变为红色，基于xpp一次右旋，这样两个相邻红色节点就隔开了，同时也没破坏别的性质。</p>
<p><strong>因此情形1和情形2都是为了转换为情形3才最终解决问题。</strong></p>
<h3 id="5-4_删除操作">5.4 删除操作</h3><p><strong>删除逻辑（删除节点p）：</strong><br>（1）如果p没有儿子节点，为红色，直接删掉，为黑色，需要调整，x就是p节点，调整完再删除p，删除一个红色节点相当于删除3-节点和4-节点中的非中间元素，不会破坏平衡性；<br>（2）如果p只有一个儿子节点，儿子节点代替p的位置，p不论颜色直接删掉，如果p为黑色，x就是儿子节点，进行调整；<br>（3）如果p有两个儿子节点，可以查找右子树中最左的节点或者左子树中最右节点（设为s），s的值和p的值交换，这个s就成了要删除的节点，而它最多只可能有一个儿子节点，适用于上面两种情况之一。</p>
<h4 id="5-4-1_删除调整">5.4.1 删除调整</h4><p>本质上来说就是2-3-4树，分裂3-节点或4-节点，补充减少的黑高。<br><strong>循环不变式：</strong><br>按照算法导论上的设计，x所在路径少一个黑色，我们可以假设给它增加一重额外的黑色，这样在删除中同样保持一个性质就是<strong>黑高</strong>不变。这是一种概念上的设计。<br>如果x不是叶节点，以x为根的子树始终满足性质（5）；</p>
<p><strong>终止条件：</strong><br>（1）x为红色节点，赋值为黑色，黑高将保持；<br>（2）x指向根节点，x都是根节点了剩下的黑高肯定一样了；<br>（3）满足情形4的条件，通过变色+旋转，””补上了””x所在路径的黑高；</p>
<p><img src="http://blog.zerohuan.com/images/red-black-tree.png" alt="删除的四种情形"></p>
<p>这张图是算法导论中的，算法导论中使用NIL一个共享的单例哨兵，但这里还是使用null而不是哨兵，因此这里图中<strong>x不为null</strong>。<br>PS：在算法导论中这个x可以是NIL节点，结合书中的删除算法，x节点不为NIL就是红色节点。实际上如果删除一个没有儿子节点的元素，这里的x就是这个元素（可以为黑色）。</p>
<p>PS：xp为父节点，w为兄弟节点，wr为兄弟的右儿子，wl为兄弟的左儿子，count(x)表示x的黑高。</p>
<p><strong>以x是xp的左儿子为例</strong>：<br><strong>情形四：兄弟节点为黑色，它的右儿子是红色的：</strong><br>首先分析情形四是因为我觉得另外三种情形只是在向情形四转变。通过一次左旋+变色，x这边路径终于增加了一个黑色节点，而wr从红色变成黑色，因此黑高也没有减少，故而解决了问题，对应B树的操作就是分裂了兄弟节点，兄弟节点的中键节点（D节点），上移，B下移成为独立节点。而图中B和C节点原来的颜色是什么，无关紧要，不影响结果，这大大简化了2-3-4树删除操作。</p>
<p><strong>情形一：兄弟节点是红色：</strong><br>兄弟节点w是红色，首先它一定会有两个黑色儿子节点。因为红黑树是完美黑平衡，因此有count(w) = count(x) + 1，而w是红色，那它必有两个黑色的儿子。这时通过一次在xp父亲节点上的左旋，x就可以得到一个黑色的兄弟节点。</p>
<p><strong>情形二：兄弟节点为黑色，它的两个儿子是黑色：</strong><br>如果C和E都是黑色或者为null，那么兄弟节点没有红色可以分裂出来，就继续上滤；兄弟节点w变成红色（黑高减一），x指向xp，因为x添加了额外一重黑色，因此实际路径黑高未减少；</p>
<p><strong>情形三：兄弟节点为黑色，右儿子是黑色，左儿子是红色：</strong><br>这种情况可以直接转化为情形四，通过一次在w节点上的右旋，C变为黑色，D变为红色，黑高保持不变，此时x的兄弟节点为黑色并且有红色的右儿子了。</p>
<h1 id="6-_应用">6. 应用</h1><p>（1）在Java中， TreeMap，Java 8中HashMap中TreeNode节点都采用了红黑树实现。<br>（2）C++中，STL的map和set也应用了红黑树；<br>（3）Linux进程调度Completely Fair Scheduler；<br>（4）用红黑树管理进程控制块epoll在内核中的实现，用红黑树管理事件块；<br>（5）Nginx中，用红黑树管理timer等；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法和数据结构/">算法和数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Servlet深入学习，规范，理解和实现（上）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Servlet深入学习，规范，理解和实现（上）/" class="article-date">
  	<time datetime="2015-12-12T06:48:41.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/12/Servlet深入学习，规范，理解和实现（上）/">Servlet深入学习，规范，理解和实现（上）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>学习参考资料</strong>：<br>（1）Servet 3.1 final 规范；<br>（2）《Java Web高级编程》；<br>（3）《深入分析Java Web技术内幕》（第2版）；</p>
<p><strong>心得</strong>：虽然现在是实际工作中很少直接使用Servlet，但了解Servlet规范中对不同组件（Servlet，Filter，Listener等等）以及Servlet容器的实现对于基于Servlet的Java EE应用的理解也是大有益处的。因此基于上面3个资料的学习所得以及我自己阅读Tomcat 8相关部分源码的一些收获在这里总结记录一下。</p>
<h1 id="1-_Servlet容器">1. Servlet容器</h1><p>Servlet 容器是 web server 或 application server 的一部分，提供基于请求/响应发送模型的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器也包含了管理 Servlet 生命周期。</p>
<h1 id="2-_Servlet">2. Servlet</h1><p>Servlet 是基于 Java 技术的 web 组件，被容器所托管的，用于生成动态内容。像其他基于 Java 的组件技术一样，Servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 web server 动态加载并运行。</p>
<h2 id="2-1_Servlet的数量">2.1 Servlet的数量</h2><p>Servlet默认是线程不安全的，一个容器中只有每个servlet一个实例，但是如果实现了<code>SingleThreadModule</code>接口，容器将实现多个servlet实例<br><code>SingleThreadModule</code>也不能保证线程安全，它只能保证任意两个线程不会使用同一个Servlet实例（可能由一个对象池来维护），servlet2.4已经将这个接口已经标注为<strong>已过时</strong>了；</p>
<blockquote>
<p>我查看了Tomcat 8.0中StandardWrapper源码，这个类负责Servlet的创建，其中SingleThreadModule模式下创建的实例数不能超过20个，也就是同时只能支持20个线程访问这个Serlvet，因此，这种对象池的设计会进一步限制并发能力和可伸缩性。</p>
</blockquote>
<h2 id="2-2_servlet的生命周期">2.2 servlet的生命周期</h2><p>加载和实例化：servlet容器负责加载和实例化Servlet，在容器启动时根据设置决定是在启动时初始化（loadOnStartup大于等于0在容器启动时进行初始化，值越小优先级越高），还是延迟初始化致第一次请求前；</p>
<h3 id="初始化：">初始化：</h3><p><code>init()</code>，执行一些一次性的动作，可以通过ServletConfig配置对象，获取初始化参数，访问ServletContext上下文环境；<br>初始化时可能发生错误，UnavailableException和ServletException，那么servlet不应放置活动服务中，未成功初始化，destroy方法也应被调用</p>
<h3 id="请求处理：">请求处理：</h3><p>servlet容器封装Request和Response对象传给对应的servlet的service方法，对于HttpServlet，就是HttpServletRequest和HttpServletResponse；<br>HttpServlet中使用<strong>模板方法模式</strong>，<code>service</code>方法根据HTTP请求方法进一步分派到doGet，doPost等不同的方法来进行处理；</p>
<blockquote>
<p>对于HTTP请求的处理，只有重写了支持HTTP方法的对应HTTP servlet方法（doGet），才可以支持，否则放回405（Method Not Allowed）。</p>
</blockquote>
<p><strong>线程不安全</strong><br>servlet中默认线程不安全，单例多线程，因此对于共享的数据（静态变量，堆中的对象实例等）自己维护进行同步控制，不要在service方法或doGet等由service分派出去的方法，直接使用synchronized方法，很显然要根据业务控制同步控制块的大小进行细粒度的控制，将不影响线程安全的耗时操作移出同步控制块；</p>
<p><strong>异常</strong><br>请求处理时同样可能抛出异常，UnavailableException和ServletException；<br>UnavailableException表示不可用，永久不可用状态返回404；暂时不可用返回503（服务不可用），标注Retry-After头；</p>
<h3 id="异步处理：">异步处理：</h3><p>在<strong>Servlet中等待</strong>是一个低效的操作，因为这是阻塞操作。<br>异步处理请求能力，使线程可以返回到容器，从而执行更多的任务。当开始异步处理请求时，<strong>另一个线程或回调</strong>可以（1）产生响应；或者，（2）请求分派；或者，（3）调用完成；</p>
<h4 id="关键方法：">关键方法：</h4><p><strong>启用</strong>：让servlet支持异步支持：asyncSupported=true；</p>
<p><strong>启动</strong>：AsyncContextasyncContext=req.startAsyncContext();或startAsyncContext(req,resp);</p>
<p><strong>完成</strong>：asyncContext.complete();必须在startAsync调用之后，分派进行之前调用；同一个AsyncContext不能同时调用dispatch和complete</p>
<p><strong>分派</strong>：asyncContext.dispatch();dispatch(Stringpath);dispatch(ServletContextcontext,Stringpath);<br>不能在complete之后调用；<br>从一个同步servlet分派到异步servlet是非法的；</p>
<p><strong>超时</strong>：asyncContext.setTimeout(millis);<br>超时之后，将不能通过asyncContext进行操作，但是可以执行其他耗时操作；<br>在异步周期开始后，容器启动的分派已经返回后，调用该方法抛出IllegalStateException；如果设置成0或小于0就表示notimeout；<br>超时表示HTTP连接已经结束，HTTP已经关闭，请求已经结束了。</p>
<p><strong>启动新线程</strong><br>通过<code>AsyncCOntext.start(Runnable)</code>方法，向<strong>线程池</strong>提交一个任务，其中可以使用AsyncContext（未超时前）；</p>
<p><strong>事件监听</strong>：addListener(newAsyncListener{…})；<br>    <strong>onComplete</strong>：完成时回调，如果进行了分派，onComplete方法将延迟到分派返回容器后进行调用；<br>    <strong>onError</strong>：可以通过AsyncEvent.getThrowable获取异常；<br>    <strong>onTimeout</strong>：超时进行回调；<br>    <strong>onStartAsync</strong>：在该AsyncContext中启动一个新的异步周期（调用startAsyncContext）时，进行回调；</p>
<p><strong>超时和异常处理</strong>，步骤：<br>（1）调用所有注册的AsyncListener实例的onTimeout/onError；<br>（2）如果没有任何AsyncListener调用AsyncContext.complete()或AsyncContext.dispatch()，执行一个状态码为HttpServletResponse<br>.SC_INTERNAL_SERVER_ERROR出错分派；<br>（3）如果没有找到错误页面或者错误页面没有调用AsyncContext.complete()/dispatch()，容器要调用complete方法；</p>
<h3 id="终止：">终止：</h3><p>servlet容器确定从服务中移除servlet时，可以通过调用<code>destroy()</code>方法将释放servlet占用的任何资源和保存的持久化状态等。调用destroy方法之前必须保证当前所有正在执行service方法的线程执行完成或者超时；<br>之后servlet实例可以被垃圾回收，当然什么时候回收并不确定，因此destroy方法是是否必要的。</p>
<h2 id="2-3_Servlet（Filter）中的url-pattern">2.3 Servlet（Filter）中的url-pattern</h2><p>Serlvet和Filter有三种不同的匹配规则：<br>（1）精确匹配：/foo；<br>（2）路径匹配：/foo/<em>；<br>（3）后缀匹配：</em>.html；<br>Serlvet的匹配顺序是：<br>首先进行精确匹配；如果不存在精确匹配的进行路径匹配；最后根据后缀进行匹配；一次请求只会匹配一个Servlet；（Filter是只要匹配成功就添加到FilterChain）</p>
<p>PS：其他写法（/foo/，/<em>.html，</em>/foo）都不对；“/foo*”不能匹配/foo，/foox；</p>
<h1 id="3-_Request">3. Request</h1><h2 id="3-1_HTTP协议参数">3.1 HTTP协议参数</h2><p>通过HttpServletRequest对象获取Http参数：<br>getParameter，getParameterNames，getParameterValues，getParameterMap；</p>
<blockquote>
<p>这些方法从getRequestURI方法或getPathInfo方法返回的字符串值中解析，如果是POST方法，也是在第一次调用getParameter方法时候进行解码获取到参数集合当中，因此要在调用这些方法之前设置编解码方式，否则可能导致乱码；</p>
<p>POST表单数据也会被汇总到请求参数集合中，但要满足：<br>（1）Content-Type必须是application/x-www-form-urlencoded；<br>（2）进行getParameter调用；<br>如果不满足获取POST参数的条件，servlet可以通过request对象的输入流得到POST数据；相反如果满足条件，输入流中也不再可以读取POST数据（因为已经读取过了）；</p>
</blockquote>
<h2 id="3-2_文件上传">3.2 文件上传</h2><p>数据以multipart/form-data格式发送，servlet支持文件上传；<br>通过    <code>HttpServletRequest</code>的：<br><code>public Collection&lt;Part&gt; getParts()</code>；<br><code>public Part getPart(String name)</code>；</p>
<p>每个Part类代表从multipart/form-data格式的POST请求中接受的一个部分或表单项，每个Part可以通过<code>Part.getInputStream</code>方法访问头部，内容类型和内容；</p>
<p>对于表单数据的Content-Disposition，即使没有文件名，也可使用part的名称通过HttpServletRequest的getParameter和getParameterValues得到part的字符串值；</p>
<h2 id="3-3_属性：">3.3 属性：</h2><p>属性的作用域与请求相关；<br>getAttribute/getAttributeNames/setAttribute；</p>
<h2 id="3-4_请求路径元素">3.4 请求路径元素</h2><p>对于这样的请求各个部分是怎样的：<a href="http://localhost:8080/example/servlets/servlet/空幻?author=空幻#success" target="_blank" rel="external">http://localhost:8080/example/servlets/servlet/空幻?author=空幻#success</a></p>
<p><strong>Context Path</strong>：ServletContext关联路径，<code>getContextPath</code>，“/example”；<br><strong>Servlet Path</strong>：getServletPath，“/servlets/servlet”，请求“/<em>”与“”模式匹配对应的servlet path是空字符串；<br><strong>PathInfo</strong>：请求路径一部分，不属于Content Path或Servlet Path，“/空幻”，要么为null，要么为以“/”开头的字符串；<br><strong>Request URI</strong>：getRequestURI，等于contetPath + servletPath + pathInfo；<br><strong>QueryString</strong>：getQueryString，“author=空幻”；<br><em>*Request URL</em></em>：<a href="http://localhost:8080/example/servlets/servlet/空幻；" target="_blank" rel="external">http://localhost:8080/example/servlets/servlet/空幻；</a></p>
<h3 id="路径转换方法">路径转换方法</h3><p><code>ServletContext.getRealPath</code>；<br><code>HttpServletRequest.getPathTranslated</code>；<br>比如：<br>（1）“<a href="http://localhost:8080/s/request/pathinfo”" target="_blank" rel="external">http://localhost:8080/s/request/pathinfo”</a>, 在我的机器上<code>`getPathTranslated()</code>返回“/home/yjh/wks/workspace/ServletTest/target/servletTest/pathinfo”；<br>其中”/request”是serlvet path，“servletTest”是项目根目录名；这两个方法都是基于项目根目录返回的；</p>
<h2 id="3-5_Servlet_3-1新特性，非阻塞I/O">3.5 Servlet 3.1新特性，非阻塞I/O</h2><p>非阻塞I/O只能用在Serlvet和Filter的<strong>异步请求处理</strong>和<strong>升级处理</strong>中； 否则设置时抛出IllegalStateException；</p>
<p>Request——ServletInputStream——ReadListener；<br>Response——ServletOutputStream——WriterListener；</p>
<p>ReadListener：<br>（1）<strong>onDataAvailable</strong>：当可以从传入请求流中读取数据，onDataAvailable将被调用，和<code>ServletInputStream.isReady</code>相关；<br>（2）<strong>onAllDataRead</strong>：读取完成ServletRequest的所有数据时调用onAllDataRead方法，和ServletInputStream.isFinished()相关；<br>（3）<strong>onError</strong>(Throwable)；</p>
<h2 id="3-6_请求数据编码">3.6 请求数据编码</h2><blockquote>
<p>getParameter等参数获取方法会将参数部分从流中读取出来，因此一定要在getParameter调用前设置编解码方式：</p>
</blockquote>
<p>Request：<br><code>setCharacterEncoding()</code>；</p>
<p>Response：<br><code>setCharacterEncoding()</code>；<br><code>setHead()</code>；<br><code>setContentType()</code>；</p>
<h2 id="3-7_Request_对象的生命周期">3.7 Request 对象的生命周期</h2><p>每个Request对象在Servlet的service（这就包括JSP的表达式，脚本，声明），Filter的doFilter的作用域中有效；</p>
<p>启用了异步处理后，request对象将到AsyncContext的complete调用时；</p>
<h1 id="4-_ServletContext接口">4. ServletContext接口</h1><p>每个基于Servlet的Web应用都有自己的ServletContext保存和维护自己的上下文信息，包括：初始化参数，Servlet，Filter，Listener配置，容器属性等等。</p>
<h2 id="4-1_配置">4.1 配置</h2><p>主要有3种方式：<br>（1）Web.xml部署描述符；<br>（2）注解；<br>（3）通过ServletContextListener/ServletContainerInitializer使用Servlet/Filter的Registration配置；</p>
<h2 id="4-2_上下文属性">4.2 上下文属性</h2><p>容器也有自己的属性，这里提一下是因为这涉及到：<br>（1）EL表达式的<strong>隐式变量</strong>及<strong>作用域</strong>：applicationScope包含所有绑定到ServletContext的特性；EL表达式中变量的作用域也是一层层查找的，最后一层查找范围就是ServletContext的特性；<br>（2）同样JSP中的隐式变量application也是ServletContext实例；</p>
<h2 id="4-3_资源">4.3 资源</h2><p>获取Web应用下的资源：<br><code>getResource</code>和<code>getResourceAsStream</code>；<br>传入path，必须要以“/”开头，相对与两个目录：<strong>上下文的根目录</strong>和<strong>web应用的WEB-INF/lib中的JAR文件中的META-INF/resources目录</strong>。依次查找这两个地方；</p>
<blockquote>
<p>这两个方法不能获取<strong>动态内容</strong>，比如jsp，获取的是jsp文件源码而不是处理后的响应；</p>
</blockquote>
<h2 id="4-4_临时工作目录">4.4 临时工作目录</h2><blockquote>
<p>Servlet容器必须为每一个servlet上下文提供一个私有的临时目录，并将通过javax.servlet.context.tempdir上下文属性使其可用，该属性关联的是java.io.File。<br>这个目录也是Multipart处理中临时目录的默认目录，并且location如果是相对路径也是基于它的。</p>
</blockquote>
<h1 id="5-_Response">5. Response</h1><blockquote>
<p>Response的<code>getWriter</code>和<code>getOutputStream</code>在同一次请求中不能同时被调用。调用了一个之后在调用另一个会抛出IllegalStateException；</p>
</blockquote>
<h1 id="5-1_缓冲">5.1 缓冲</h1><p><strong>获取和设置缓冲区大小</strong>：getBufferSize和setBufferSize，不能在缓冲区写入内容之后设置缓冲区大小调用setBufferSize；</p>
<p>PS：tomcat 8中缓冲区大小为8192</p>
<p><strong>是否提交到客户端</strong>：isCommitted；</p>
<p><strong>刷新缓冲区</strong>：flushBuffer，也可以通过getWriter/getOutputStream调用输出流的flush；</p>
<p><strong>重置缓冲区</strong>：reset和resetBuffer，不能在响应提交后调用，否则抛出IllegalStateException，响应及关联的缓冲区不变；</p>
<h2 id="5-2_重定向和设置Error">5.2 重定向和设置Error</h2><p><code>sendRedirect</code>和<code>sendError</code>；<br>这两方法有一些相似性：<br>（1）如果在调用前已有响应<strong>提交</strong>到客户端，调用它们将抛出IllegalStateException；<br>（2）如果没有响应提交，sendRedirect和sendError将<strong>重置缓冲区</strong>，舍弃原来缓冲区中的旧数据，Servlet中之后的输出也是无效的（将被忽略）；</p>
<h2 id="5-3_Response编码和国际化">5.3 Response编码和国际化</h2><p>同样需要在响应未提交或resp.getWriter()之前进行设置，否则将无效（面向字符的输出已经设置默认编码）；</p>
<p><strong>国际化配置</strong><br>在部署描述符中配置，如果没有配置将使用容器依赖的mapping等配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">locale-encoding-mapping-list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">locale-encoding-mapping</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">locale</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="title">locale</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">locale-encoding-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">locale-encoding-mapping-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>setLocale也可以设置编码，在<code>setContentType</code>和<code>setCharacterEncoding</code>之前，调用<code>setLocale</code>设置编码，使用上面配置中的编码；但是这并不会设置HTTP响应头的content-type等头，因此浏览器/客户端将使用默认的解码方式来解码这可能导致乱码；</p>
<p>PS：setLocale将通过<code>Content-Language</code>响应头来传递；但是编码方式如果没有指定Content-Type，是不能通过HTTP header传递的；</p>
<p>因此，应该在getWriter方法被调用或响应被提交之前通过<code>setContentType</code>或<code>setCharacterEncoding</code>或<code>addHeader</code>设置编码方式，否则将使用默认编码：ISO-8859-1；</p>
<p><strong>setCharacterEncoding</strong>：这个方法可以覆盖<code>setLocale</code>和<code>setContentType</code>设置的编码方式，但不会设置Content-Type头；</p>
<blockquote>
<p><code>setLocale</code>，<code>setCaracterEncoding</code>和<code>setContentType</code>都可以设置编码方式，但是要通过<code>setContentType</code>和<code>addHeader</code>设置<code>Content-Type</code>响应头，并且它们都要在<code>getWriter</code>调用前或响应提交前设置；</p>
</blockquote>
<h2 id="5-4_结束响应对象">5.4 结束响应对象</h2><p>以下时间表明servlet满足了请求且响应对象即将关闭“<br>（1）servlet的service方法终止；<br>（2）响应的<code>setContentLength</code>或<code>setContentLong</code>制定了大于零的内容量，且已经写入到响应；<br>（3）<code>sendError</code>方法或<code>sendRedirect</code>方法已调用；<br>（4）AsyncContext的<code>compelete</code>方法已调用；</p>
<blockquote>
<p><code>setContentLength</code>和<code>setContentLengthLong</code>方法一般有Web容器在响应完成后负责调用，后者是Servlet3.1的新方法；</p>
</blockquote>
<h2 id="5-5_Response生命周期">5.5 Response生命周期</h2><p>和Request相似，在servlet的service方法和Filter的doFilter方法内有效，如果启动异步处理，知道complete方法被调用有效。</p>
<h1 id="6-_Filter">6. Filter</h1><h2 id="6-1_对Filter的理解">6.1 对Filter的理解</h2><p><strong>Filter</strong>和<strong>Servlet/其他Web资源（包括静态资源）</strong>组合起来使用，实现了一个职责链模式的请求处理调用栈，<strong>Servlet/Web资源</strong>是最后一个“入栈的节点”（当然Filter可以阻止请求到达Servlet/Web资源，）。Filter可以在servlet调用前和调用后进行一些额外的处理过程（比如，验证，日志，压缩等等）。</p>
<blockquote>
<p><code>FilterChain.doFilter(req, resp)</code>调用前后，正分别是调用栈“入栈”和“出栈”之时，做相应的处理。</p>
<p>每个Filter配置对应的每个JVM的容器仅实例化一个实例。</p>
</blockquote>
<h2 id="6-2_Filter的生命周期">6.2 Filter的生命周期</h2><p>（1）<code>init()/init(FilterConfig filterConfig)</code>：和Servlet一样可能抛出UnavaliableException（暂时不可用/永久不可用）；<code>init()</code>方法总是在应用程序启动时调用（ServletContextListener初始化之后，Servlet初始化之前）；<br>（2）<code>doFilter()</code>：服务中，处理传入请求和返回响应：可以进行检查请求头，修改请求头/数据，修改响应头等等；</p>
<blockquote>
<p>Filter可以调用chain.doFilter()方法调用过滤器链中下一个实体；也可以不调用来阻止请求；</p>
<p>doFilter过程中也可能抛出UnavailableException，容器负责停止处理剩下的过滤器链，若不是永久不可用，可以选择稍后重试整个链。</p>
</blockquote>
<p>（3）<code>destroy()</code>：容器把服务中的Filter实例移除前，先调用它的destroy方法，进行释放资源等清理工作；</p>
<h2 id="6-3_Filter的类型">6.3 Filter的类型</h2><p>Servlet容器中，存在多种分派方式，Servlet2.4之后，可以对不同的请求分派进行过滤：<br>（1）<strong>普通请求</strong>；<br>（2）<strong>转发请求</strong>：<code>RequestDispatcher.forward()</code>或<code>&lt;jsp:forward&gt;</code>触发的请求，这种转发，本质上是服务器应用内部的方法调用；<br>（3）<strong>包含请求</strong>：<code>RequestDispatcher.include()</code>或<code>&lt;jsp:include&gt;</code>，注意这种是包含输出和<code>&lt;%@ inlcude %&gt;</code>静态导入的区别；<br>（4）<strong>错误资源请求</strong>：发生异常，请求错误页面；<br>（5）<strong>异步请求</strong>：如果要结合异步处理的Servlet使用，Filter同样也要开启支持异步处理。这里异步请求指的是有<code>AsyncContext</code>派发的请求，实现异步过滤器要注意可能被单个异步请求调用多次（潜在的多个不同线程）；</p>
<p>在部署描述符中，通过<code>&lt;dispatcher&gt;</code>元素中可以选择Filter支持的请求类型。</p>
<h2 id="6-4_Filter的配置">6.4 Filter的配置</h2><p><strong>初始化参数的设置</strong>；<br>同样Filter也可以通过<strong>编程</strong>，<strong>注解</strong>和<strong>XML</strong>三种方式配置；</p>
<blockquote>
<p>到Serlvet 3.1，注解配置Filter不能保证设置顺序。</p>
</blockquote>
<p><strong>Filter的顺序</strong>：<br>（1）基本顺序：<br><strong>首先</strong>，<code>&lt;url-pattern&gt;</code>匹配，按照Filter在部署描述符中<strong>出现的顺序</strong>匹配过滤器映射；<br><strong>其次</strong>再按照<code>&lt;serlvet-name&gt;</code>出现的顺序匹配；<br>（2）编程设置Filter顺序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registration.addMappingForUrlPatterns(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="string">"/foo"</span>, <span class="string">"bar/*"</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二个参数表示<strong>是否在部署描述符之后的Filter之后</strong>；</p>
<h2 id="6-5_Servlet，Filter和UnavailableException">6.5 Servlet，Filter和UnavailableException</h2><p><code>UnavailableException</code>表示Servlet或Filter不可用，这种情况一般Servlet容器负责处理，重试或者返回响应；<br>UnavailableException的分为两种：<br>（1）<strong>永久不可用</strong>：比如servlet配置不正确或者Filter状态异常。<br>（2）<strong>暂时不可用</strong>：可能由于一些system-wide的问题导致请求无法处理，比如第三方服务不可用，内存和磁盘不足等等；可以在稍后重试；</p>
<h1 id="7-_Servlet及其容器的工作原理（Tomcat_8-0为例）">7. Servlet及其容器的工作原理（Tomcat 8.0为例）</h1><p>Tomcat分为4层结构：Container容器-&gt;Engine容器-&gt;Host容器-&gt;Servlet容器；</p>
<p>一个请求，根据它的URL，Tomcat将根据它的Host，Context一层层将其转发到合适的Servlet（对于很多MVC是映射到一个Servlet，在根据之后的pathinfo解析分派到对应的处理函数）。</p>
<p>一个Context对应一个Web工程：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Context</span> <span class="attribute">path</span>=<span class="value">"/projectOne"</span> <span class="attribute">docBase</span>=<span class="value">"/home/xxx/xxx"</span> <span class="attribute">reloadable</span>=<span class="value">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="7-1_Servlet容器的启动">7.1 Servlet容器的启动</h2><p>这里的config也是通过<code>addWebApp</code>的重载版本中调用构造器创建的，传入该方法进行设置；contextPath和docBase分别对应Web应用的<strong>访问路径</strong>和<strong>物理路径</strong>。<br>（1）新增Web应用，设置访问路径，工作目录监听器，创建注入ContextConfig对象；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">addWebapp</span><span class="params">(Host host, String contextPath, String docBase, ContextConfig config)</span> </span>&#123;</span><br><span class="line">       silence(host, contextPath);</span><br><span class="line"></span><br><span class="line">       Context ctx = createContext(host, contextPath);</span><br><span class="line">       <span class="comment">//设置访问路径</span></span><br><span class="line">       ctx.setPath(contextPath);</span><br><span class="line">       <span class="comment">//设置物理工作目录 </span></span><br><span class="line">       ctx.setDocBase(docBase);</span><br><span class="line">       <span class="comment">//添加监听器</span></span><br><span class="line">       ctx.addLifecycleListener(<span class="keyword">new</span> DefaultWebXmlListener());</span><br><span class="line">       ctx.setConfigFile(getWebappConfigFile(docBase, contextPath));</span><br><span class="line">	<span class="comment">//ContextConfig也同样实现了监听接口</span></span><br><span class="line">       ctx.addLifecycleListener(config);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// prevent it from looking ( if it finds one - it'll have dup error )</span></span><br><span class="line">       config.setDefaultWebXml(noDefaultWebXmlPath());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将Servlet容器（Context）添加到Host下</span></span><br><span class="line">       <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">           getHost().addChild(ctx);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           host.addChild(ctx);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ctx;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）Tomcat启动<code>Tomcat.start()</code>：<br>Tomcat中启动中使用了观察者设计模式，所有容器实现了LifeCycle接口（也就是Observable），所有修改和状态变化由容器通知已注册的Observer（Listener）。</p>
<p>（3）Context容器初始化：<br>当Context容器初始化状态为init时，ContextConfig实现了LifeCycleListener接口，之前在<code>addWebApp()</code>已经将其注册到了Context中，这时会被调用。ContextConfig负责整个Web应用配置文件的<strong>解析工作</strong>，在<code>ContextConfig.init()</code>方法中（包括/conf目录下的context.xml，默认HOST配置文件/server.xml，Context自身的配置文件）。</p>
<p>（4）配置文件解析完成后调用<code>Context.startInternal</code>：这个方法十分重要，包含很多工作，之后要涉及的比如<strong>Web应用初始化</strong>，<strong>servlet的创建初始化</strong>（loadOnStartup的），<strong>Filter的创建和初始化</strong>等等都是这个方法子环节：</p>
<p>创建读取资源文件的对象；<br><strong>创建ClassLoader对象</strong>（WepAppClassLoader，加载Web应用目录lib下的jar包中的类，不同Web应用这里相互隔离）；<br>设置应用的工作目录‘；<br>启动相关的辅助类（logger，realm，resources等）；<br>修改启动状态，通知感兴趣的观察者；<br>子容器的初始化；<br>获取ServletContext并设置必要的参数；<br><strong>创建并初始化Filter</strong>；<br><strong>初始化LoadOnStartup的Servlet</strong>；</p>
<p>（5）Web应用初始化：<br>在上面说过<code>Context.startInternal</code>方法中会“修改启动状态，通知感兴趣的观察者”，查看该方法源码可以发现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个方法通知注册对于<code>CONFIGURE_START_EVENT</code>感兴趣的监听器，就包括<code>ContextConfig</code>，这时<code>ContextConfig</code>调用<code>configureStart</code>方法开始Web应用的初始化工作，主要的工作就是web.xml文件的解析（包括全局的web.xml，应用自己的web.xml，jar包中META-INF/web-fragment.xml，注解的读取，解析，合并）。</p>
<p>这些web.xml部署描述符和注解是依据Serlvet规范的，WebXml对象将它们抽象组装成StandardWapper，Tomcat容器内部的表示方法，而不是直接强耦合于Serlvet规范。</p>
<p>这个过程将我们熟悉的Serlvet，Filter，Multipart配置抽象包装成StandardWrapper对象，作为子容器添加到Context中，Context容器是真正运行Servlet的Servlet容器，一个Web应用一个Context容器。</p>
<h2 id="7-2_创建Servlet实例">7.2 创建Servlet实例</h2><p>这个工作是在<code>Context.startInternal()</code>中开始的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loadOnStartup(findChildren())) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.servletFail"</span>));</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>StandardContext.loadOnStartup</code>对loadOnstartup值大于等于0的StandardWrapper调用其<code>load</code>方法，开始创建和初始化Servlet对象。</p>
<p>/conf/web.xml全局的部署描述符中定义两个Servlet：<br><code>org.apache.catalina.servlets.DefaultServlet</code>和<code>org.apache.jasper.servlet.JspServlet</code>（loadOnStartup分别是1和3）；根据/conf/web.xml总的定义我们可以知道它们分别是处理静态资源和jsp文件请求的Servlet。</p>
<h3 id="7-2-1_创建Servlet对象：Servlet创建中的单例模式（synchronized+反射创建）">7.2.1 创建Servlet对象：Servlet创建中的单例模式（synchronized+反射创建）</h3><p>之前在介绍Servlet规范时，我们提及了Servlet是单例的，这里就看看Tomcat是怎样支持这一规范要求的。</p>
<p>首先，根据前面的知识，已经知道我们在部署描述符中定义的每个Servlet会被解析组装成对应一个StandardWrapper对象，也正是这个对象负责创建Servlet；创建就在<code>StandardWrapper.loadServlet</code>方法中，下面来看看这个方法的一些关键步骤：</p>
<p>（1）基于synchronized同步控制，保证create-if-not的原子性/内存可见性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Servlet <span class="title">loadServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br></pre></td></tr></table></figure></p>
<p>这里到没有DCL，静态内部类，枚举等丰富多彩的单例模式实现方法，其中也没有什么比较特别耗时的操作；但是这也说明了Serlvet使用LoadOnStartup可以避免在Web应用运行的时候因为创建Servlet的一些同步开销。</p>
<p>（2）如果单例已存在，直接返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nothing to do if we already have an 			instance or an instance pool</span></span><br><span class="line">        <span class="keyword">if</span> (!singleThreadModel &amp;&amp; (instance != <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br></pre></td></tr></table></figure></p>
<p>singleThreadModel（以下简称STM）前面已经说过使用对象池来保证不会有两个线程使用同一个Servlet实例（但这不是一个好办法）。</p>
<p>（3）获取InstatnceManager实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();</span><br></pre></td></tr></table></figure></p>
<p>（4）InstanceManager通过反射创建servlet实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">             servlet = (Servlet) instanceManager.newInstance(servletClass);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">             <span class="comment">/* 略 */</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             <span class="comment">/* 略 */</span></span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）开始初始化Servlet，初始化完成后通知执行回调：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initServlet(servlet);</span><br><span class="line">fireContainerEvent(<span class="string">"load"</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-2_初始化Servlet">7.2.2 初始化Servlet</h3><p>在上面一小节的<code>StandardWrapper.loadServlet</code>的结尾开始进行Servlet的初始化工作（根据StandardWrapper的源码，<code>initServlet</code>方法一般会在loadServlet调用后，检查如果没有完成初始化就进行调用，因为loadServlet可能因为一些异常，比如UnavailableException等原因中途退出而没有完成初始化）。</p>
<p><code>initServlet</code>方法中有大量的回调事件通知：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">InstanceEvent</span><span class="class">.BEFORE_INIT_EVENT</span></span><br><span class="line"><span class="comment">/* servlet.init(facade)*/</span></span><br><span class="line"><span class="tag">InstanceEvent</span><span class="class">.AFTER_INIT_EVENT</span></span><br></pre></td></tr></table></figure></p>
<p>（1）基于synchronized关键字的同步控制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initServlet</span><span class="params">(Servlet servlet)</span></span><br><span class="line">           <span class="keyword">throws</span> ServletException</span></span><br></pre></td></tr></table></figure></p>
<p>（2）如果已经初始化过了或者不是STM模式直接返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instanceInitialized &amp;&amp; !singleThreadModel) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></p>
<p>（3）将StandardWrapper包装成<code>StandardWrapperFacade</code>作为ServletConfig传给Servlet，调用<code>Servlet.init(facade)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">             <span class="comment">/* 略：SecurityUtil.doAsPrivilege方法调用 */</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             servlet.init(facade);</span><br><span class="line">         &#125;</span><br><span class="line">         instanceInitialized = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>（4）<code>GenericServlet</code>（HttpServlet，JspServlet基类）的<code>init</code>注入保存了ServletConfig对象。<br>如果Servlet是<code>JspServlet</code>，需要编译这个JSP文件为类，并初始化这个类。</p>
<h2 id="7-3_Serlvet核心结构和门面设计模式">7.3 Serlvet核心结构和门面设计模式</h2><p>Servet直接相关的几个类：ServletConfig，ServletReuqest，ServletResponse。</p>
<p>Tomcat容器中使用内部的表示方法，通过门面设计模式将Facade对象传递给Servlet：<br><img src="http://blog.zerohuan.com/images/tomcat-servlet-structure.png" alt="Tomcat-Servlet体系结构"><br>从这个类图中，我们可以看到ServletConfig和ServletContext与Servlet的关系，以及Tomcat对它们的实现：<br>（1）一个ServletContext对应多个Servlet，Tomcat中的实现类型是ApplicationContext，ApplicationContextFacade是它的门面类；<br>（2）一个ServletConfig对应一个Servlet，Tomcat中的实现类型是StandardWrapper，StandardWrapperFacade是其门面类；<br>（3）ServletConfig是Servlet配置集合，ServletContext是容器内所有Servlet的“交易环境”；<br>（4）Servlet桶构<code>init</code>方法获取ServletConfig（实际上是StandardWrapperFacade对象）；<br>（5）ApplicationContext和StandardWrapper都是在StandardContext中创建的。</p>
<p><strong>Request</strong>和<strong>Response</strong>：<br><img src="http://blog.zerohuan.com/images/tomcat-request-response.png" alt="Tomcat-Request-Response体系结构"><br>Tomcat同样使用<strong>内部表示</strong>&lt;—&gt;<strong>门面类</strong>&lt;—&gt;传入Servlet；</p>
<p>（1）Tomcat接收到请求后创建<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Resposne</code>，这两个类是轻量级的类，对象很小；这是有Tomcat内部工作线程创建的；<br>（2）将<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Resposne</code>传递给用户线程，创建<code>org.apache.catalina.connector.Request</code>和<code>org.apache.catalina.connector.Resposne</code>，这两个对象一直整个Servlet容器直到要传给Servlet；<br>（3）创建门面类<code>RequestFacade</code>和<code>ResponseFacade</code>给Servlet；</p>
<h2 id="7-3_请求和映射/分派">7.3 请求和映射/分派</h2><p>Tomcat8通过<code>org.apache.catalina.mapper</code>（和Tomcat7位置有差别）保存容器中所有子容器的信息，在<code>org.apache.catalina.connector.Request</code>进入Container容器前，Mapper会根据这次请求的hostname和contextPath将host和context容器设置到Request的<code>mappingData</code>属性中。</p>
<p>这里同样使用观察者模式，<code>MappingListener</code>注册到Engine，Host各级容器上，容器状态发生变化就通知它变化更新到Mapper中。</p>
<p>根据Mapper可以确定将请求分派到哪个Host和哪个Servlet容器上以及哪个Servlet上，在传到Servlet前，通过Filter链并在这个过程中调用可能的Listener，最终执行Servlet的service方法。<br><img src="http://blog.zerohuan.com/images/tomcat-mapper.png" alt="Tomcat-Mapper结构"></p>
<h2 id="7-4_Listener的体系结构和创建">7.4 Listener的体系结构和创建</h2><p>Servlet规范中定义了很多监听器，基于观察者模式将主要流程的控制/管理和事件的响应处理分离。主要分为两类：<br>（1）<strong>LifeCycleListener</strong>：ServletContextListener，HttpSessionListener；监听目标对象的创建和销毁事件；<br>（2）<strong>EventListener</strong>：ServletContextAttributeListener，ServletRequestAttributeListener，ServletRequestListener，HttpSessionAttributeListener等等；</p>
<p>PS：ServletContextListeer在容器启动之后不能在添加新的，因为容器启动这个事件不会再次发生；我们可以在ServletContainerInitializer中创建配置它。</p>
<h3 id="Listener的创建">Listener的创建</h3><p>再次回到<code>StandardContext.startInternal</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!listenerStart()) &#123;</span><br><span class="line">          log.error(sm.getString(<span class="string">"standardContext.listenerFail"</span>));</span><br><span class="line">          ok = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的关键还是<code>listenerStart方法</code>，该方法在<code>StandardContext.filterStart</code>之前，我们来看一看这个方法的关键步骤：<br>（1）反射创建所有Listener：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiate the required listeners</span></span><br><span class="line">String listeners[] = findApplicationListeners();</span><br><span class="line">Object results[] = <span class="keyword">new</span> Object[listeners.length];</span><br><span class="line"><span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">	<span class="comment">/* 略 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String listener = listeners[i];</span><br><span class="line">        results[i] = getInstanceManager().newInstance(listener);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">/* 略 */</span></span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）将监听器整理为eventListeners和lifecycleListeners两类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort listeners in two arrays</span></span><br><span class="line">ArrayList&lt;Object&gt; eventListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Object&gt; lifecycleListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((results[i] <span class="keyword">instanceof</span> ServletContextAttributeListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> ServletRequestAttributeListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> ServletRequestListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> HttpSessionIdListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> HttpSessionAttributeListener)) &#123;</span><br><span class="line">        eventListeners.add(results[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((results[i] <span class="keyword">instanceof</span> ServletContextListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> HttpSessionListener)) &#123;</span><br><span class="line">        lifecycleListeners.add(results[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）将Intializers或其他通过编程方式添加的监听添加到位：<br>这里就不一定是反射创建的了，在<code>ServletContainerInitializer.onStratup</code>中我们可以通过构造器来创建指定的listener；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listener instances may have been added directly to this Context by</span></span><br><span class="line">        <span class="comment">// ServletContextInitializers and other code via the pluggability APIs.</span></span><br><span class="line">        <span class="comment">// Put them these listeners after the ones defined in web.xml and/or</span></span><br><span class="line">        <span class="comment">// annotations then overwrite the list of instances with the new, full</span></span><br><span class="line">        <span class="comment">// list.</span></span><br><span class="line">        <span class="keyword">for</span> (Object eventListener: getApplicationEventListeners()) &#123;</span><br><span class="line">            eventListeners.add(eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">        setApplicationEventListeners(eventListeners.toArray());</span><br><span class="line">        <span class="keyword">for</span> (Object lifecycleListener: getApplicationLifecycleListeners()) &#123;</span><br><span class="line">            lifecycleListeners.add(lifecycleListener);</span><br><span class="line">            <span class="keyword">if</span> (lifecycleListener <span class="keyword">instanceof</span> ServletContextListener) &#123;</span><br><span class="line">                noPluggabilityListeners.add(lifecycleListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setApplicationLifecycleListeners(lifecycleListeners.toArray());</span><br></pre></td></tr></table></figure></p>
<p>（4）调用ServletContextListener的<code>contextInitialized</code>；</p>
<h2 id="7-5_Filter的创建，初始化和使用">7.5 Filter的创建，初始化和使用</h2><h3 id="Filter的创建">Filter的创建</h3><p>回到<code>StandardContext.startInternal</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure and call application filters</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!filterStart()) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.filterFail"</span>));</span><br><span class="line">              ok = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>StandardContext.filterStart</code>中将根据配置创建所有的<code>ApplicationFilterConfig</code>以及根据FilterClass反射创建爱Filter实例，实际上还是通过（<strong>synchronized</strong>+反射创建保证<strong>单例</strong>），该方法在<code>StandardContext.loadOnStartup</code>之前调用。</p>
<h3 id="Filter链的结构和调用过程">Filter链的结构和调用过程</h3><p>上面我们根据Servlet规范介绍了Filter的基本情况。这里结合Tomcat 8具体介绍下Filter的创建，初始和相关细节。<br><img src="http://blog.zerohuan.com/images/tomcat-filter.png" alt="Tomcat-Filter结构"></p>
<p>Tomcat容器主要通过<code>ApplicationFilterChain</code>管理和执行过滤器链。它通过一个数组保存所有Filter的FilterConfig对象，在Tomcat中是<code>ApplicationFilterConfig</code>（每个FilterConfig包含一个Filter引用）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationFilterConfig[] filters =</span><br><span class="line">       <span class="keyword">new</span> ApplicationFilterConfig[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<p>该数组是一个大小动态增长的数组（每次增长10）。处理请求时通过<code>ApplicationFilterChain.doFilter</code>该方法会调用数组中每个<code>Filter.doFilter</code>。</p>
<h2 id="7-6_Initializer，Listener，Filter，Servlet的创建/初始化，销毁顺序">7.6 Initializer，Listener，Filter，Servlet的创建/初始化，销毁顺序</h2><p>Listener，Filter，Servlet的创建和初始化上面已经结合Tomcat 8的实现进行了总结说明。它们都是在<code>StandardContext.startInternal</code>这一生命周期方法中进行的。加上Initializer顺序依次是：<br>Initaializer—&gt;Listener—&gt;Filter—&gt;Servlet（loadOnstart）；</p>
<p>因为前面没有提及Intializer的相关知识，我们在这里介绍下：<br>ServletContainInitalizer是Java EE 6中Servlet 3.0的新增接口；它的<code>onStartup</code>方法是一个web应用中我们的代码可以控制到的最早时间点。</p>
<p>它不需要通过web.xml部署描述符来定义，需要在/META-INF/services/javax.servlet.ServletContainerInitializer中列出具体的实现，Servlet容器在启动时会自动扫描加载它们并调用onStartUp方法。但是文件不能放在WAR文件的/META-INF/services中，而是需要放在JAR文件的/META-INF/services中，这样就很不方便。如果你使用Spring的话，Spring Framework提供了一个桥接口，在Spring中SpringServletContainerInitializer类实现了ServletContainerInitializer接口，Spring的JAR中列出了SpringServletContainerInitializer，如下。在SpringServletContainerInitializer中会扫描所有WebApplicationInitializer的实现，调用它们的onStartUp方法，因此我们不必在劳神费心了。</p>
<h3 id="Initializer的调用">Initializer的调用</h3><p><code>StandardContext.startInternal</code>中在lislistener，filter，servlet（loadOnStartup）之前对所有的ServletContainerInitializers进行调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call ServletContainerInitializers</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">    initializers.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                getServletContext());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.sciFail"</span>), e);</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，我们可以看到，根据规范结合实现，Initializer中可以配置servlets，filters和listeners；在ServletContextListener可以配置其他的listener（因此<code>listenerStart</code>中分了两步加载），filters和servlets；而Filter链在Servlet之前调用。因此我们能看到这样一个顺序：<br>Initaializer—&gt;Listener—&gt;Filter—&gt;Servlet（loadOnstart）；</p>
<h3 id="销毁顺序">销毁顺序</h3><p>和C++构造&amp;析构等等这类东西很相似，它们的销毁顺序和加载/初始化顺序是相反的。</p>
<p>结合Servlet规范中一些定义，我们也能看到上述初始化和销毁顺序，这也是必须要理解明白的重要知识点。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-web/">java web</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java 8集合框架源码学习——HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Java 8集合框架源码学习——HashMap/" class="article-date">
  	<time datetime="2015-12-12T06:06:52.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/12/Java 8集合框架源码学习——HashMap/">Java 8集合框架源码学习——HashMap</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>心得</strong>：相较于JDK 1.7，Java 8中的HashMap有了较大的性能提升。修改了hash和resize方式，增加了红黑树的支持。</p>
<p><strong>学习参考资料</strong>：<br>（1）<a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：Java HashMap的死循环</a>；</p>
<h1 id="1-_HashMap要点">1. HashMap要点</h1><p><strong>（1）结构特点</strong>：Java中的HashMap是基于“数组+链表”的方式（链表法解决冲突），到了Java 8，应该是“数组+链表/红黑树”的方式。<br><strong>（2）线程安全</strong>：HashMap是不安全，Collections Framework中有两种线程安全的实现：Collections.synchronizedMap(new java.util.HashMap&lt;&gt;());和ConcurrentHashMap，前者是锁整个表，后者是16个分段锁：<br>学习参考资料（1），展示了Java 7中，并发出现“死循环”的一种情形，就是在resize过程中，迁移Entry到新桶中是产生了一个有环的链表造成的，Java 7中resize的transfer是在链表头部插入新节点，Java 8中的新节点的插入是尾部；<br>对于Java 8中resize一个桶中的如果是链表的话，会被分两个链表一个保留在原来索引位置上，一个在（oldCap + oldIndex）位置，因为是在尾部插入，所以它们相对位置不变，但HashMap还是线程不安全的；<br><strong>（3）性能特点</strong>：HashMap可以在常数时间内增加，删除，查找元素，但这也是一种平均情况，使用load factor装载因子计算阈值就是为了减少冲突过多，带来的性能退化；<br><strong>（4）Java 8相对于Java 7中HashMap的区别和优化</strong>：；<br>（1）计算hash值的方法：Java 7中会基于一个随机种子计算hash值，这样每次resize如果得到不同的随机种子，那么原来一个桶中的元素，会被“随机”散列到桶数组中，Java 8放弃了这种做法，基于key的hashCode（通过异或计算综合高位和地位），旧桶的元素如上面所说只可能散列到两个确定位置的桶中，基于好的hashCode计算，这也是随机分布的，这样可以简化了计算并且省去了随机种子的计算；<br>（2）红黑树的应用：当桶的数量超过MIN_TREEIFY_CAPACITY时，向一个元素数达到TREEIFY_THRESHOLD的桶中插入节点时会将桶中的链表转化为红黑树实现，也就是变O(n)的查找转变为O(log n)；<br><strong>（5）HashMap中优化性能的设计</strong>：<br>（1）何时进行resize：和ArrayList一次扩展为原大小的3/2类似，HashMap的桶数组一次扩展为原数组的2倍，控制扩展和移动的次数；<br>（2）桶数组的容量是2的幂次方，这样设计有三个好处，一是2的幂次方减1正好可以得到一个计算index的掩码，二是扩展大小时一次位运算（&lt;&lt;）既可以计算出新的容量同时有保持了2的幂次方这一特点，三是进行迁移旧桶元素时，可以方便计算出元素新桶数组中两个位置；<br><strong>（6）HashMap的应用</strong>：<br>根据HashMap特点，可以知道它可以实现常数时间的精确查找，插入和删除，可以通过它建立在内存中一些简单的运行时缓存数据；<br>但是显然哈希表不支持很好的范围查找，另外的对于过多的数据在Java 7中可能造成退化成链表的情形，因此一个好的hashCode实现是十分重要的，当然过大的数据也不太可能到放在内存里（内存泄漏，HashMap中有大量过期数据是个需要注意的问题，当然我们可以使用WeakHashMap）；</p>
<p>PS：覆盖了equals，一定要覆盖hashCode函数，否则equals相等，hashCode不相等就扯淡了。</p>
<h1 id="2-_结构">2. 结构</h1><h2 id="2-1_重要的值">2.1 重要的值</h2><h3 id="容量：">容量：</h3><pre><code><span class="comment">//默认初始化容量，HashMap容量必须是2的幂次方</span>
<span class="keyword">static</span> final <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 16</span>
<span class="comment">//最大容量不得超过1&lt;&lt;30</span>
<span class="keyword">static</span> final <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;
</code></pre><h3 id="扩展：">扩展：</h3><p>（1）容量 × 装载因子：超过这个阈值，将进行resize扩展为原来大小的2倍；<br>（2）桶中元素树结构化（用红黑树代替链表）：桶中元素数超过TREEIFY_THRESHOLD并且桶的数量超过MIN_TREEIFY_CAPACITY会进行树结构化，否则超过TREEIFY_THRESHOLD使用resize扩展桶容量；</p>
<pre><code><span class="comment">//默认装载因子，0.75是权衡空间和时间开销之后的综合考虑</span>
<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;
<span class="comment">//超过这个阈值将使用红黑树组织桶中的结点，而不是链表</span>
<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;
<span class="comment">//只有表的大小超过这个阈值，桶才可以被转换成树而不是链表（为超过这个值时，应该使用resize）</span>
<span class="comment">//这个值是TREEIFY_THRESHOLD的4倍，以便resizing和treeification之间产生冲突</span>
<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;
</code></pre><h2 id="2-2_重要的属性">2.2 重要的属性</h2><p>（1）桶数组（table）：延迟加载，第一次插入数据前分配内存，<strong>桶的大小是2的幂次方</strong>，好处是便于快速计算hash值和扩展；<br>（2）阈值和装载因子（threshold，loadFactor）：有capacity × load factor，用一个变量保存它是因为每次put新键值对都要检查它，显然不能每次都计算；<br>（3）键值对数量（size）；<br>（4）修改计数器：fail-fast机制，这个机制不能用于维护正确性，只能用于调试bug；<br>（5）视图（entrySet，keySet，values）：键值对的保存方式使用“数组+链表/红黑树”，这三个视图基于这个实现采用集合方式返回数据，主要用于遍历；</p>
<pre><code><span class="comment">//延迟加载，长度总为2的幂次方</span>
<span class="keyword">transient</span> Node&lt;K,V&gt;[] table;
<span class="comment">//键值对数量</span>
<span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;

<span class="comment">//fail-fast</span>
<span class="keyword">transient</span> <span class="keyword">int</span> modCount;

<span class="comment">//下一次resize的阈值 (capacity * load factor)</span>
<span class="keyword">int</span> threshold;
<span class="comment">//装载因子</span>
<span class="keyword">final</span> <span class="keyword">float</span> loadFactor;

<span class="comment">//视图</span>
<span class="comment">//键值对缓存，它们的映射关系集合保存在entrySet中，即使Key在外部修改导致hashCode变化，缓存中还可以找到映射关系</span>
<span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
<span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt;        keySet;
<span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values;
</code></pre><h2 id="2-3_构造器">2.3 构造器</h2><p>构造器重载版本：<br>（1）指定初始容量和装载因子：不指定是使用默认的值，延迟初始化到第一次添加键值对；<br>（2）拷贝构造器：使用默认装载因子，容量大小是<strong>不小于DEFAULT_INITIAL_CAPACITY的</strong>，<strong>最小的</strong>，<strong>超过传入键值对数量的</strong>的<strong>2的幂次方；</strong></p>
<pre><code><span class="comment">//传入指定初始化容量，将计算好threshold的值，第一次放入元素时分配threshold大小的数组</span>
<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{
    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +
                initialCapacity);
    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +
                loadFactor);
    <span class="keyword">this</span>.loadFactor = loadFactor;
    <span class="comment">//此时table还未分配到内存，threshold就是将要分配的数组大小</span>
    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);
}
<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);
}
<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span>
}
<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>{
    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, <span class="keyword">false</span>);
}
</code></pre><h2 id="3-_操作">3. 操作</h2><h2 id="3-1_核心内部操作">3.1 核心内部操作</h2><h4 id="计算容量，hash值，索引值：">计算容量，hash值，索引值：</h4><p>（1）计算容量：<code>tableSizeFor()</code>方法，使用位运算快速计算；<br>（2）hash值的计算：因为容量最小是16，而计算索引值的时候用（容量-1）作为掩码的，<strong>那可能因为hash值的高位不会被计算而导致冲突的概率增加</strong>；<br>（3）计算索引值：JDK 7中有一个indexFor方法计算索引值，Java 8中去掉了，但是逻辑没有变，比如在putVal方法中<code>p = tab[i = (n - 1) &amp; hash]</code>；</p>
<pre><code><span class="comment">//找到最小的大于等于cap的2的幂次方，二进制位运算</span>
<span class="function"><span class="keyword">static</span> final <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>{
    <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">//减1是为了排除“100000”这种情况</span>
    n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//这里位运算就是在用最高位的1“铺满所有位”</span>
    n |= n &gt;&gt;&gt; <span class="number">2</span>;
    n |= n &gt;&gt;&gt; <span class="number">4</span>;
    n |= n &gt;&gt;&gt; <span class="number">8</span>;
    n |= n &gt;&gt;&gt; <span class="number">16</span>;
    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;
}

<span class="comment">//计算key的hash值，这里在hashCode基础上做了一次“高位向低位传播”</span>
<span class="comment">//因为计算索引值是(cap - 1) &amp; hash，当cap小于等于16时高位将无法起作用</span>
<span class="function"><span class="keyword">static</span> final <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>{
    <span class="keyword">int</span> h;
    <span class="keyword">return</span> (key == null) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);
}
</code></pre><h4 id="重新分配桶数组（resize方法，三步：先确定桶的大小，再创建数组对象，最后给旧桶中元素搬家）">重新分配桶数组（resize方法，三步：先确定桶的大小，再创建数组对象，最后给旧桶中元素搬家）</h4><p>（1）桶数组不为空，扩展为原大小两倍<code>(newCap = oldCap &lt;&lt; 1)</code>，<strong>2倍扩展+阈值是一个重要的分配优化策略，这样可以大大减少分配数组对象并复制元素的次数</strong>：</p>
<pre><code><span class="comment">//一，原数组不为空</span>
<span class="keyword">if</span>(oldCap &gt; <span class="number">0</span>) {
    <span class="comment">//如果oldCap已经为最大容量</span>
    <span class="keyword">if</span>(oldCap &gt;= MAXIMUM_<span class="built_in">CAPACITY</span>) {
        threshold = MAXIMUM_<span class="built_in">CAPACITY</span>;
        <span class="keyword">return</span> oldTab;
    } <span class="keyword">else</span> <span class="keyword">if</span>((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt;= MAXIMUM_<span class="built_in">CAPACITY</span> &amp;&amp;
            oldCap &gt; DEFAULT_INITIAL_<span class="built_in">CAPACITY</span>)
        threshold = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//增加阈值</span>
}
</code></pre><p>（2）桶数组为空，第一次分配，结合不同构造器的情况细节稍有不同：</p>
<pre><code><span class="comment">//重新创建table数组</span>
<span class="comment">//原数组为空，oldThr不为空，扩展为oldThr大小</span>
<span class="keyword">else</span> <span class="keyword">if</span>(oldThr &gt; <span class="number">0</span>)
    newCap = oldThr;
<span class="comment">//原数组为空，oldThr为空，全部使用默认值</span>
<span class="keyword">else</span> {
    <span class="comment">//全部使用默认值</span>
    newCap = DEFAULT_INITIAL_<span class="built_in">CAPACITY</span>;
    newThr = (<span class="keyword">int</span>)(DEFAULT_INITIAL_<span class="built_in">CAPACITY</span> * loadFactor);
}
</code></pre><p>（3）分配新内存：</p>
<pre><code>//<span class="keyword">Node</span><span class="identifier"></span><span class="title">[]不具备类型检查的能力，因此要通过强制类型转换
//另外，不能创建参数化类型的数组
@SuppressWarnings</span>({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})
<span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt;[] newTab = (<span class="keyword">Node</span><span class="identifier"></span><span class="title">&lt;K</span>,V&gt;[])new <span class="keyword">Node</span><span class="identifier"></span><span class="title">[newCap</span>];
table = newTab;
</code></pre><p>将元素“移动”到新桶中也分几种情况：<br>（4）桶中只有一个元素：</p>
<pre><code><span class="keyword">if</span>(<span class="keyword">e</span>.next == null)
    <span class="comment">//桶中只有一个元素，不可能是TreeNode直接放入新表的指定位置</span>
    newTab[<span class="keyword">e</span>.hash &amp; (newCap - 1)] = <span class="keyword">e</span>;
</code></pre><p> （5）第一个元素是红黑树节点：</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> TreeNode) {
   e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="variable">key</span>, value);
}
</code></pre><p> （6）桶中存放的是链表：<br> 相对与Java 7这里也有优化：<br> 不存在rehash重新计算的可能，由于hash值不变，容量是直接×2的，因此旧桶中的一个链表实际上最多会被分成两个链表一个在原来的索引位置（oldIndex）上，另一个就在oldIndex+oldCap位置上。</p>
<pre><code><span class="comment">/*
桶中存在一个链表，需要将链表重新整理到新表当中，因为newCap是oldCap的两倍所以原节点的索引值要么和原来一样，要么就是原(索引+oldCap)和JDK 1.7中实现不同这里不存在rehash，直接使用原hash值JDK 1.7中resize过程是在链表头插入，这里是在链表尾插入
*/</span>
Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;
Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;
<span class="keyword">do</span> {
    <span class="keyword">if</span>((e.hash &amp; oldCap) == <span class="number">0</span>) {
        <span class="comment">//和原索引值一样</span>
        <span class="keyword">if</span>(loTail == <span class="keyword">null</span>)
            loHead = e;
        <span class="keyword">else</span>
            loTail.<span class="keyword">next</span> = e;
        loTail = e;
    } <span class="keyword">else</span> {
        <span class="keyword">if</span>(hiTail == <span class="keyword">null</span>)
            hiHead = e;
        <span class="keyword">else</span>
            hiTail.<span class="keyword">next</span> = e;
        hiTail = e;
    }
} <span class="keyword">while</span> ((e = e.<span class="keyword">next</span>) != <span class="keyword">null</span>);
<span class="keyword">if</span>(loTail != <span class="keyword">null</span>) {
    loTail.<span class="keyword">next</span> = <span class="keyword">null</span>;
    newTab[j] = loHead;
}
<span class="keyword">if</span>(hiTail != <span class="keyword">null</span>) {
    hiTail.<span class="keyword">next</span> = <span class="keyword">null</span>;
    newTab[j + oldCap] = hiHead;
}
</code></pre><h3 id="添加键值对">添加键值对</h3><p>（1）第一次插入或桶是空的：</p>
<pre><code><span class="comment">//如果是第一次添加元素</span>
<span class="keyword">if</span>((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || (<span class="keyword">n</span> = <span class="keyword">tab</span>.length) == 0)
    <span class="keyword">n</span> = (<span class="keyword">tab</span> = resize()).length;
<span class="comment">//对应索引位置的桶是空的，直接创建新节点填入</span>
<span class="keyword">if</span>((p = <span class="keyword">tab</span>[(i = (<span class="keyword">n</span> - 1) &amp; hash)]) == null)
    <span class="keyword">tab</span>[i] = newNode(hash, key, value, null);
</code></pre><p>（2）桶中有元素，首先检查第一个元素，因为树结构必须大于2个节点，再分类型检查；</p>
<pre><code><span class="comment">//首先检查第一个节点</span>
<span class="keyword">if</span>(p.hash == hash &amp;&amp;
    ((k = p.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
    e = p;
</code></pre><p>（3）桶中是红黑树：</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)
    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="variable">key</span>, value);
</code></pre><p>（4）桶中是链表，添加新节点，如果达到了TREEIFY_THRESHOLD，需要检查是否要转换为红黑树结构，<code>treeifyBin()</code>会检查桶数组的大小是否超过MIN_TREEIFY_CAPACITY（64），不超过只是进行resize扩展，否则才转换树：</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> binCount = <span class="number">0</span><span class="comment">; ; ++binCount) {</span>
    if <span class="list">(<span class="list">(<span class="keyword">e</span> = p.next)</span> == null)</span> {
        p.next = newNode<span class="list">(<span class="keyword">hash</span>, key, value, null)</span><span class="comment">;</span>
        if <span class="list">(<span class="keyword">binCount</span> &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span> // <span class="number">-1</span> for <span class="number">1</span>st
            treeifyBin<span class="list">(<span class="keyword">tab</span>, hash)</span><span class="comment">;</span>
        break<span class="comment">;</span>
    }
    if <span class="list">(<span class="keyword">e</span>.hash == hash <span class="keyword">&amp;&amp;</span>
        <span class="list">(<span class="list">(<span class="keyword">k</span> = e.key)</span> == key || <span class="list">(<span class="keyword">key</span> != null <span class="keyword">&amp;&amp;</span> key.equals<span class="list">(<span class="keyword">k</span>)</span>)</span>)</span>)</span>
        break<span class="comment">;</span>
    p = e<span class="comment">;</span>
}</span>
</code></pre><h3 id="查找键值对（根据hash值和key查找）">查找键值对（根据hash值和key查找）</h3><p>这里hash值有两个作用：<br>一是根据hash确定桶的位置，基于良好的hashCode实现，这一步正式HashMap常数操作时间的保证。<br>（2）hash和key本质上是key的hashCode和equals方法的应用，hashCode不相等，equals必然不相等，hashCode相等再检查equals是否相等。反映到程序上就是一个短路优化。</p>
<p>如果桶数组不为空，而且对应的桶（hash &amp; (table.length - 1)）中有节点：<br>（1）首先检查桶中第一个节点：</p>
<pre><code><span class="comment">//总是检查第一个节点的原因：无论是树结构还是链表，都可以方便的检查第一个节点，树结构的节点数必然大于1</span>
<span class="comment">//先检查hash，利用好短路特性</span>
if(<span class="built_in">first</span>.hash == hash &amp;&amp;
    ((k = <span class="built_in">first</span>.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))
    return <span class="built_in">first</span>;
</code></pre><p>（2）多于一个节点，检查类型，分别处理：</p>
<pre><code><span class="comment">//多于一个节点，继续检查</span>
    <span class="keyword">if</span>((e = first.next) != <span class="keyword">null</span>) {
        <span class="keyword">if</span>(first <span class="keyword">instanceof</span> TreeNode)
            <span class="keyword">return</span> (TreeNode)first.getTreeNode(hast, <span class="variable">key</span>);
        do {
            <span class="keyword">if</span>(e.hash == hash &amp;&amp;
                    ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k))))
                <span class="keyword">return</span> e;
        } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);
    }
</code></pre><h3 id="删除键值对">删除键值对</h3><p>基本的操作和添加大致相同，另外</p>
<p>如果桶数组不为空，而且对应的桶（hash &amp; (table.length - 1)）中有节点：<br>（1）检查桶中第一个节点：</p>
<pre><code>if <span class="list">(<span class="keyword">p</span>.hash == hash <span class="keyword">&amp;&amp;</span>
            <span class="list">(<span class="list">(<span class="keyword">k</span> = p.key)</span> == key || <span class="list">(<span class="keyword">key</span> != null <span class="keyword">&amp;&amp;</span> key.equals<span class="list">(<span class="keyword">k</span>)</span>)</span>)</span>)</span>
            node = p<span class="comment">;</span>
</code></pre><p>（2）多于一个节点，检查类型，分别处理：</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) {
    <span class="comment">//桶中是红黑树</span>
    <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)
        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, <span class="variable">key</span>);
    <span class="keyword">else</span> {
    <span class="comment">//桶中是链表</span>
        do {
            <span class="keyword">if</span> (e.hash == hash &amp;&amp;
                ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> ||
                 (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k)))) {
                node = e;
                <span class="keyword">break</span>;
            }
            p = e;
        } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);
    }
}
</code></pre><p>（3）找了要删除的节点之后，：</p>
<pre><code>if (<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span> &amp;&amp; (!matchValue || (v = <span class="keyword">node</span>.<span class="identifier"></span><span class="title">value</span>) == value || (value != null &amp;&amp; value.equals(v)))) {
    //如果是红黑树，删除要保持完美黑平衡
    if (<span class="keyword">node</span><span class="identifier"> </span><span class="title">instanceof</span> TreeNode)
        ((TreeNode<span class="tag">&lt;K,V&gt;</span>)<span class="keyword">node</span><span class="identifier"></span><span class="title">).removeTreeNode</span>(this, tab, movable);
    //如果删除的是链表第一个节点
    else if (<span class="keyword">node</span><span class="identifier"> </span><span class="title">== p</span>)
        tab[index] = <span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>;
    //删除非表头节点
    else
        p.next = <span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>;
    ++modCount;
    --size;
    afterNodeRemoval(<span class="keyword">node</span><span class="identifier"></span><span class="title">);
    return</span> <span class="keyword">node</span><span class="identifier"></span><span class="title">;
}</span>
</code></pre><h3 id="清除（clear方法）">清除（clear方法）</h3><p>清除所有节点，这里只是将“桶给清空了”，链表或者红黑树本身并没有置空操作；</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>() {
    Node&lt;K,V&gt;[] tab;
    modCount++;
    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; <span class="built_in">size</span> &gt; <span class="number">0</span>) {
        <span class="built_in">size</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)
            tab[i] = <span class="keyword">null</span>;
    }
}
</code></pre><h3 id="视图操作">视图操作</h3><p>HashMap本身是数组加链表的关系，但如果需要遍历的话以Set接口来遍历显然是一种很统一的设计。</p>
<p>因此Map接口提供了Set视图，基于HashMap的存储方式，实现了对<strong>键值对集合</strong>，<strong>键集合</strong>，<strong>值集合</strong>视图访问。</p>
<p>Set的遍历关键一点是Iterator的实现：</p>
<h4 id="HashIterator">HashIterator</h4><p>依据HashMap“数组+链表/红黑树”的存储特点，HashMap包含一个骨架类：<strong>HashIterator</strong><br>PS：HashMap中红黑树的实现，TreeNode维护了next节点，可以通过next以类似链表的方式遍历；<br>HashIterator的迭代方式，是沿着桶数组找到一个非空的，迭代这个链表/红黑树，迭代完之后，找到下一个非空的桶继续遍历；</p>
<h4 id="视图迭代器的实现：">视图迭代器的实现：</h4><pre><code><span class="comment">//键集合迭代器</span>
<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator</span>
</span>    implements <span class="type">Iterator</span>&lt;<span class="type">K</span>&gt; {
    public <span class="keyword">final</span> <span class="type">K</span> next() { <span class="keyword">return</span> nextNode().key; }
}

<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator</span>
</span>    implements <span class="type">Iterator</span>&lt;<span class="type">V</span>&gt; {
    public <span class="keyword">final</span> <span class="type">V</span> next() { <span class="keyword">return</span> nextNode().value; }
}

<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator</span>
</span>    implements <span class="type">Iterator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;&gt; {
    public <span class="keyword">final</span> <span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next() { <span class="keyword">return</span> nextNode(); }
}
</code></pre><h4 id="视图集合实现：">视图集合实现：</h4><p>首先一个共同的特点是不能基于视图Set以及它们的迭代器执行添加操作；<br>remove，clear，contains基于HashMap对应方法实现的。</p>
<h1 id="3-_HashMap的“树化”">3. HashMap的“树化”</h1><p>前面说过当桶的数量大于MIN_TREEIFY_CAPACITY（64）并且一个桶中的元素数超过TREEIFY_THRESHOLD时就会将这个桶中的链表变成红黑树结构，但是在树化的同时，这个红黑树保持了节点之间的“next”链接关系，使得可以向链表一样遍历，这在迭代其中十分有用，那它是如何保持的呢？</p>
<h3 id="TreeNode的结构：">TreeNode的结构：</h3><p>和普通的红黑树节点相比，TreeNode多了两个引用变量：next和prev，这说明它同时保持了一个双向链表的结构，之所以要是双向链表是因为，在添加，删除是用使用红黑树的操作，但是为了支持链表同时也要维护链表链接，显然再遍历一边找到前序节点就又退化成链表了，故而使用双向链表。</p>
<pre><code>TreeNode&lt;K,V&gt; parent;  // <span class="keyword">red</span>-black tree links
TreeNode&lt;K,V&gt; <span class="keyword">left</span>;
TreeNode&lt;K,V&gt; <span class="keyword">right</span>;
TreeNode&lt;K,V&gt; <span class="keyword">prev</span>;    // needed <span class="keyword">to</span> unlink <span class="keyword">next</span> upon deletion
boolean <span class="keyword">red</span>;
</code></pre><h3 id="树化过程（treeifyBin()方法）：">树化过程（treeifyBin()方法）：</h3><p>（1）当小于MIN_TREEIFY_CAPACITY，不要树化，通过resize扩展桶数组：</p>
<pre><code>if <span class="list">(<span class="keyword">tab</span> == null || <span class="list">(<span class="keyword">n</span> = tab.length)</span> &lt; MIN_TREEIFY_CAPACITY)</span>
        resize<span class="list">()</span><span class="comment">;</span>
</code></pre><p>（2）超过MIN_TREEIFY_CAPACITY，开始树化，首先是替换链表节点对象（Node）为TreeNode节点，建立双向链表。在从头开始进行树化。</p>
<pre><code><span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) {
        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span><span class="comment">;</span>
        <span class="keyword">do</span> {
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>)<span class="comment">;</span>
            <span class="keyword">if</span> (tl == <span class="literal">null</span>)
                hd = p<span class="comment">;</span>
            <span class="keyword">else</span> {
                p.prev = tl<span class="comment">;</span>
                tl.<span class="keyword">next</span> = p<span class="comment">;</span>
            }
            tl = p<span class="comment">;</span>
        } <span class="keyword">while</span> ((e = e.<span class="keyword">next</span>) != <span class="literal">null</span>)<span class="comment">;</span>
        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)
            hd.treeify(tab)<span class="comment">;</span>
    }
</code></pre><p>（3）树化中的节点顺序问题，红黑树是搜索树，因此需要节点是有序的，但是HashMap的类型参数没有Comparable的限定，因此当key对象类型未实现Comparable接口，将使用这个对象的<strong>原始hashCode</strong>（即Object的hashCode，<strong>无论有没有覆盖hashCode方法</strong>，null的hashCode为0）进行比较；</p>
<pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>{
        <span class="keyword">int</span> d;
        <span class="keyword">if</span> (a == null || b == null ||
            (d = a.getClass().getName().
             compareTo(b.getClass().getName())) == <span class="number">0</span>)
            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?
                 -<span class="number">1</span> : <span class="number">1</span>);
        <span class="keyword">return</span> d;
    }
</code></pre><p>（4）基于此树化中的两个疑问就弄清了：一是如何保持链表结构，二是有序性的获得，TreeNode.treeify这个方法的工作就是从这个节点开始遍历链表插入每个节点到红黑树中，每次插入之后修补黑平衡性这已经是很熟悉的内容了；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-8集合框架源码/">Java 8集合框架源码</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-TCP-IP学习笔记（二）——链路层" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/TCP-IP学习笔记（二）——链路层/" class="article-date">
  	<time datetime="2015-12-11T17:20:19.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/12/TCP-IP学习笔记（二）——链路层/">TCP/IP学习笔记（二）——链路层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>心得：看过以太网封装，SLIP封装，PPP封装这3个主要的链路层封装格式，可以明白链路层有哪些问题需要解决：<br>（1）物理地址定位：以太网的MAC地址，而SLIP每端必须知道对方的地址，PPP协议提供了地址字段；<br>（2）类型表示：实际中链路层可以有多种类型的封装格式，因此需要类型来标识，SLIP没有类型标识，所以只能独占使用信道；<br>（3）校验：校验是每一层的都需要考虑的问题，SLIP没有校验机制，那就依赖上层的机制；<br>（4）控制响应时间：MTU；<br>（5）链路层基于不同的硬件，提供<strong>点到点</strong>的传输任务，封装IP，ARP请求/应答，RARP请求/应答；</p>
<h2 id="1-_3种封装格式（以太网封装，SLIP，PPP）">1. 3种封装格式（以太网封装，SLIP，PPP）</h2><h3 id="1-1_以太网封装格式">1.1 以太网封装格式</h3><p>以太网一般基于CSMA/CD，但是有两种常用的封装格式（RFC894和RFC1024），我总结了下这两种格式的异同：<br><strong>相同：</strong><br>（1）都具有48位地址，包括目的地址和源地址，也就是MAC地址，ARP和RARP就是用来解析MAC地址和IP地址映射的；<br>（2）都具有类型标识，<strong>以太网可能包含IP数据报，ARP请求应答，RARP应答</strong>；<br>（3）CRC尾部校验；<br>（4）它们整个帧的长度最少为64位，这是CSMA/CD的机制决定的；<br><strong>不同：</strong><br>（1）RFC1024的头更为详细，包括LLC（逻辑链路控制）等内容；</p>
<h3 id="1-2_SLIP和压缩的SLIP">1.2 SLIP和压缩的SLIP</h3><p>Serial Line IP，一种简单的对IP数据报的封装形式，需要注意End字符的转义；</p>
<p><strong>SLIP的缺陷：</strong><br>（1）每一个端必须知道对方的IP地址；<br>（2）数据帧中没有字段类型字段（而以太网有），如果一条串行线路用于SLIP，就不能同时使用其他协议。<br>（3）没有校验和，依赖上层协议发现错误；</p>
<p>串行线路的速率很低，通信经常是交互式的，因此数据的<strong>传输效率很重要</strong>；</p>
<p>使用CSLIP（压缩的SLIP）可以将40个字节压缩到3,5字节；</p>
<h3 id="1-3_PPP，点对点协议">1.3 PPP，点对点协议</h3><p>修改了SLIP的所有缺陷：<br>（1）提供了校验机制；<br>（2）提供了网络控制协议，因此可以支持多种类型的协议；<br>（3）提供了链路控制协议，允许双方进行通信协商，因此传输自己的IP给对方；</p>
<h2 id="2-_其他重要概念">2. 其他重要概念</h2><h3 id="2-1_MTU和路径MTU">2.1 MTU和路径MTU</h3><p>MTU的存在主要是为了有足够快的响应速度；<br>两台主机进行通信，最重要的事通信路径的最小MTU，（我想起了计算最大流量的最小割定理，短板效应嘛）；</p>
<h3 id="2-2_串行线路吞吐量计算">2.2 串行线路吞吐量计算</h3><p>线路速率（带宽，单位：字节/秒）；<br>等待发送时间：如果使用一个SLIP和一个其他协议应用混用，需要有等待时间，SLIP没有类型标识，因此，其他协议使用时和SLIP之间要相互等待，这里的等待时间是<strong>平均时间</strong>。</p>
<p><strong>问题一：为什么以太网帧最小64字节（数据长度最少46字节）？</strong><br>分析：以太网是基于CSMA/CD（带冲突检测的载波侦听多路接入），这是一种争用型的介质访问控制，而不是可靠的，有连接的，主要是为了效率。</p>
<p>一台主机发送数据前要先监听网络是空闲的才能发送，那么A主机发送后，数据还未达到B主机，B主机监听网络是空闲的，它也开始发送数据，这就产生了碰撞，因此B就会发送碰撞信号告诉A发送了错误，如果A的数据收到碰撞信号后，发送错误的数据帧已经发送完就无法知道要重传哪一帧。因此必须要保证在一帧发送完之前发送主机能够收到碰撞信号。</p>
<p>IEEE规定一个碰撞域内，最远的两台机器之间的round-trip time 要小于512bit time.(来回时间小于512位时，所谓位时就是传输一个比特需要的时间）。这也是我们常说的一个碰撞域的直径。因此以太网帧最小为64字节。</p>
<p>重传的开销：以太网的重传是微秒级，而传输层的重传，如TCP的重传达到毫秒级，应用层的重传更达到秒级，我们可以看到越底层的重传，速度越快，所以对于以太网错误，以太网必须有重传机制。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java 8集合源码学习——ArrayList" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/11/Java 8集合源码学习——ArrayList/" class="article-date">
  	<time datetime="2015-12-11T06:48:41.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/Java 8集合源码学习——ArrayList/">Java 8集合源码学习——ArrayList</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>心得：<br>学习、实践的时候如果能够触类旁通是一件很爽的事，学习源码能很学到很多优秀思想和设计，而优秀的思想总是相通的。比如ArrayList中扩展数组大小时，最少扩展为原数组的3/2，这种做法避免了频繁小幅度的扩展造成频繁的复制动作（让我想到了TCP拥塞控制的滑动窗口的大小控制），集合框架中有很多精妙的思想和技巧，深入学习，仔细思考真的可以受益颇多。</p>
<h2 id="1-_ArrayList要点">1. ArrayList要点</h2><p><strong>（1）基于数组实现</strong>：内部表示通过控制对象数组的访问，数组是不能动态修改大小的，因此根据元素数量/指定容量大小，通过创建新数组，复制元素对象是ArrayList的核心原理之一；<br><strong>（2）性能特点</strong>：因为基于数组的，因此可以实现快速随机访问，比LinkedList效率高；但是增加/删除等需要通过复制数组元素（部分或全部）来实现，效率比LinkedList低；<br><strong>（3）线程不安全</strong>：同样使用modCount修改计数，类似乐观锁的fail-fast来防止并发修改带来的不一致，ArrayList的每个Iterator，ListIterator，SubList实例都独立维护一个基于ArrayList实例modCount的expectedModCount；<br><strong>（4）优化手段</strong>：<br><strong>单例模式应用</strong>：EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA这两个单例的空数组对象，分别被“空状态”和“默认状态”的ArrayList共享；<br><strong>grow方法的增长机制</strong>：每次扩展数组的大小至少扩展到原数据的3/2大小，减少了创建新数组和复制动作的次数；<br><strong>（5）克隆和序列化</strong>：实现了Serializable和Cloneable接口，支持序列化和克隆，其中序列化使用writeObject和readObject不采用默认的序列化机制，只保存size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销；<br><strong>（6）防止内存泄漏的置空动作</strong>：维护一个数组也是自己维护内存管理，因为数组也持有这引用，删除时要及时置空不能影响GC活动，虽然LinkedList已经说了，再强调下；</p>
<h2 id="2-_基本结构和操作">2. 基本结构和操作</h2><h3 id="2-1_重要属性">2.1 重要属性</h3><pre><code><span class="comment">//默认初始化容量</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;
<span class="comment">/*
 所有Empty数组列表共享一个空数组对象，不仅可以减少重复对象的创建（单例模式应用），还可以标识空列表状态
 单例模式（区别于享元模式）：
 一是这里只有一个对象；
 二是不仅仅是节省内存，更重要的是起到共享并标识“空数组列表”的作用；
 EMPTY_ELEMENTDATA标识“空”状态，DEFAULTCAPACITY_EMPTY_ELEMENTDATA标识默认状态
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span>[] EMPTY_ELEMENTDATA = {};
<span class="comment">/*
 默认状态创建数组列表实例使用该数组，使用一个单例空数组并且不直接使用EMPTY_ELEMENTDATA而是新键一个空数组的原因是：
 一是用于标识不同的状态，区别于“空数组列表”，DEFAULTCAPACITY_EMPTY_ELEMENTDATA表示数组列表还未插入元素；
 二是等到实际有元素再分配合适大小的数组内存空间，起到延迟加载的作用；
 三是同样单例可以让所有默认状态列表使用一个空数组对象，节省内存；
*/</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span>[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
<span class="comment">/*
使用transient的目的是为了隐藏内部表示
使用Object的原因：
（1）Object可以引用所有具体类型的数组对象；
（2）实际的ArrayList的类型参数对于ArrayList对象本身是不可知的，泛型的本质是擦除，并借助变量，方法，类的签名来进行类型检查和转换;
    因此可以用Object数组存放元素对象，依赖方法和类型参数让编译器和JVM进行类型检查和转换（比如插入checkcast指令等等）；
 */</span>
<span class="keyword">transient</span> <span class="keyword">Object</span>[] elementData;
<span class="comment">//元素个数</span>
<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span>;

<span class="comment">/*
翻译：
一些实现可能会保存一些首部信息在数组对象中。
试图分配一个比MAX_ARRAY_SIZE大的数组可能会造成OOM（Requested array size exceeds VM limit）。
也就是说一些JVM的实现可能会限制数组大小小于Integer.MAX_VALUE，因此检查是必要的。
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>; 
</code></pre><h3 id="2-2_不同版本的构造器">2.2 不同版本的构造器</h3><p>这里可以看到在创建ArrayList对象实例的时候：<br>（1）ArrayList()：默认状态，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这也是一个空数组，延迟加载，第一次插入时才分配内存；<br>（2）如果指定的初始化容量为0,拷贝构造器传入集合为空，使用EMPTY_ELEMENTDATA；</p>
<pre><code><span class="comment">/*
不同版本的构造器
 */</span>
<span class="comment">//如果指定初始化容量为“0”，使用EMPTY_ELEMENTDATA</span>
<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {
        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];
    } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {
        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;
    } <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+
                initialCapacity);
    }
}
<span class="comment">//创建默认初始化容量列表，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>
<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

<span class="comment">//拷贝构造器，注意使用toArray获取要插入元素对象</span>
<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{
    elementData = c.toArray();
    <span class="keyword">if</span>((size = elementData.length) != <span class="number">0</span>) {
        <span class="comment">/*
        注意，toArray返回的Object[]引用，而Object[]可以作为超类引用子类对象比如A[]（假设A是E的子类）
        如果toArray返回是A[]数组对象，那么如果类型B对象（B extends E）可能会引起后续的插入时的ArrayStoreException，读取元素时的ClassCheckException
        因此如果返回的不是Object[]对象，要创建一个Object[]并复制元素引用
         */</span>
        <span class="keyword">if</span>(elementData.getClass() != Object[].<span class="keyword">class</span>) {
            elementData = Arrays.copyOf(elementData, size, Objects[].<span class="keyword">class</span>);
        }
    } <span class="keyword">else</span> {
        <span class="comment">//一个空数组列表，直接使用EMPTY_ELEMENTDATA</span>
        elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre><h3 id="2-3_核心操作">2.3 核心操作</h3><p>主要方法包括：trimToSize（压缩缓存数组），grow（扩展容量），ensure～（不同情况下调用的扩容方法），removeRange（范围删除），batchRemove（批量删除），fastRemove（基于复制的快速复制），这些方法供之后方法调用；</p>
<pre><code><span class="comment">//压缩缓存区大小，最小化存储区域到size相同的大小</span>
<span class="keyword">public</span> <span class="keyword">void</span> trimToSize() {
    modCount++;
    <span class="keyword">if</span>(<span class="built_in">size</span> &lt; elementData.length) {
        elementData = (<span class="built_in">size</span> == <span class="number">0</span>)
                ? EMPTY_ELEMENTDATA
                : Arrays.copyOf(elementData, <span class="built_in">size</span>);
    }
}

<span class="comment">//增加容量到指定大小（溢出会抛出OOM），通过这个方法可以打破MAX_ARRAY_SIZE限制</span>
<span class="keyword">private</span> <span class="keyword">void</span> grow(<span class="built_in">int</span> minCapacity) {
    <span class="comment">// overflow-conscious code</span>
    <span class="built_in">int</span> oldCapacity = elementData.length;
    <span class="comment">//首先尝试将新容量设置为原容量的（3/2）</span>
    <span class="comment">//这样做可以避免频繁小幅度的扩张带来的开销，我联想到一个类似的做法是滑动窗口中修改窗口大小的机制</span>
    <span class="built_in">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);
    <span class="comment">//如果尚未达到指定大小（这说明扩张幅度够大），设置为指定大小</span>
    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)
        newCapacity = minCapacity;
    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>
    elementData = Arrays.copyOf(elementData, newCapacity);
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> hugeCapacity(<span class="built_in">int</span> minCapacity) {
    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();
    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
}

<span class="comment">//当ArrayList不处于默认状态时，才可能扩展大小为小于DEFAULT_CAPACITY的容量；</span>
<span class="comment">// 否则只有指定大小超过DEFAULT_CAPACITY时才进行扩展；</span>
<span class="comment">//注意这个方法是public，区别于ensureCapacityInternal，这个方法是在外部使用的；</span>
<span class="keyword">public</span> <span class="keyword">void</span> ensureCapacity(<span class="built_in">int</span> minCapacity) {
    <span class="built_in">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            <span class="comment">// any size if not default element table</span>
            ? <span class="number">0</span>
            <span class="comment">// larger than default for default empty table. It's already</span>
            <span class="comment">// supposed to be at default size.</span>
            : DEFAULT_CAPACITY;

    <span class="keyword">if</span> (minCapacity &gt; minExpand) {
        ensureExplicitCapacity(minCapacity);
    }
}

<span class="comment">//ArrayList内部扩展大小使用此方法，没有上个条件方法限制</span>
<span class="comment">//但如果处于默认状态，扩展大小仍然不能小于DEFAULT_CAPACITY</span>
<span class="keyword">private</span> <span class="keyword">void</span> ensureCapacityInternal(<span class="built_in">int</span> minCapacity) {
    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

<span class="keyword">private</span> <span class="keyword">void</span> ensureExplicitCapacity(<span class="built_in">int</span> minCapacity) {
    modCount++;

    <span class="comment">// overflow-conscious code</span>
    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)
        grow(minCapacity);
}

<span class="comment">//删除[fromIndex, toIndex)范围的元素</span>
<span class="comment">//操作后将末尾newSize之后的元素置空，防止内存泄漏</span>
<span class="keyword">protected</span> <span class="keyword">void</span> removeRange(<span class="built_in">int</span> fromIndex, <span class="built_in">int</span> toIndex) {
    modCount++; <span class="comment">//fail-fast</span>
    <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - toIndex;
    System.arraycopy(elementData, fromIndex, elementData, toIndex,
            numMoved);

    <span class="comment">//清空多余的元素引用</span>
    <span class="built_in">int</span> newSize = <span class="built_in">size</span> - (toIndex - fromIndex);
    <span class="keyword">for</span>(<span class="built_in">int</span> i = newSize; i &lt; <span class="built_in">size</span>; i++)
        elementData[i] = <span class="keyword">null</span>;
    <span class="built_in">size</span> = newSize;
}

<span class="comment">//批量删除，complement为false时删除数组缓冲区中集合c包含的元素，true，删除集合c中不包含的元素，可以用实现交，差等集合运算</span>
<span class="comment">//使用复制的方法，而不是调用remove()的方式，减少了元素的重复复制</span>
<span class="comment">//同样要将newSize之外的元素引用置空，防止内存泄漏</span>
<span class="keyword">private</span> <span class="built_in">boolean</span> batchRemove(Collection&lt;?&gt; c, <span class="built_in">boolean</span> complement) {
    <span class="keyword">final</span> <span class="keyword">Object</span>[] elementData = <span class="keyword">this</span>.elementData;
    <span class="built_in">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>; <span class="comment">//不变式，w &lt;= r</span>
    <span class="built_in">boolean</span> modified = <span class="keyword">false</span>;
    <span class="keyword">try</span> {
        <span class="keyword">for</span> (; r &lt; <span class="built_in">size</span>; r++) {
            <span class="keyword">if</span>(c.contains(elementData[r]) == complement) {
                elementData[w++] = elementData[r];
            }
        }
    } <span class="keyword">finally</span> {
        <span class="comment">//如果有异常抛出，保存好还未处理的数组元素</span>
        <span class="keyword">if</span> (r != <span class="built_in">size</span>) {
            System.arraycopy(elementData, r,
                    elementData, w,
                    <span class="built_in">size</span> - r);
            w += <span class="built_in">size</span> - r;
        }
        <span class="keyword">if</span>(w != <span class="built_in">size</span>) {
            <span class="keyword">for</span>(<span class="built_in">int</span> i = w; i &lt; <span class="built_in">size</span>; i++)
                elementData[i] = <span class="keyword">null</span>;
            modCount += <span class="built_in">size</span> - w;
            <span class="built_in">size</span> = w;
            modified = <span class="keyword">true</span>;
        }
    }
    <span class="keyword">return</span> modified;
}

<span class="comment">//由调用者检查index是否合法</span>
<span class="keyword">private</span> <span class="keyword">void</span> fastRemove(<span class="built_in">int</span> index) {
    modCount++;
    <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - index - <span class="number">1</span>;
    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)
        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,
                numMoved);
    elementData[--<span class="built_in">size</span>] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span>
}
</code></pre><h3 id="2-4_辅助方法">2.4 辅助方法</h3><p>（1）检查索引是否合法；<br>（2）返回指定位置的元素；</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> rangeCheck(<span class="keyword">int</span> <span class="keyword">index</span>) {
    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= size)
        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(<span class="keyword">index</span>));
}

<span class="keyword">private</span> <span class="keyword">void</span> rangeCheckForAdd(<span class="keyword">int</span> <span class="keyword">index</span>) {
    <span class="keyword">if</span> (<span class="keyword">index</span> &gt; size || <span class="keyword">index</span> &lt; <span class="number">0</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(<span class="keyword">index</span>));
}

<span class="keyword">private</span> String outOfBoundsMsg(<span class="keyword">int</span> <span class="keyword">index</span>) {
    <span class="keyword">return</span> <span class="string">"Index: "</span>+<span class="keyword">index</span>+<span class="string">", Size: "</span>+size;
}

<span class="comment">//复用</span>
@SuppressWarnings(<span class="string">"unchecked"</span>)
E elementData(<span class="keyword">int</span> <span class="keyword">index</span>) {
    <span class="keyword">return</span> (E) elementData[<span class="keyword">index</span>];
}
</code></pre><h3 id="2-5_SubList与ArrayList的关系">2.5 SubList与ArrayList的关系</h3><p>该SubList是非静态内部类实现，基于同一个缓存数组，和Iterator一样维护一个modCount副本，防止并发修改；</p>
<pre><code><span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{
    subListRangeCheck(fromIndex, toIndex, size);
    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);
}
</code></pre><h3 id="2-6_List实现要点">2.6 List实现要点</h3><p>toArray使用保护性拷贝；<br>总来的来说这一块比较简单；</p>
<pre><code><span class="comment">//获取指定位置的元素对象引用</span>
@Override
<span class="keyword">public</span> E <span class="built_in">get</span>(<span class="built_in">int</span> index) {
    rangeCheck(index);
    <span class="keyword">return</span> elementData(index);
}

<span class="comment">//注意set方法不是结构性修改，因此并没有modCount++</span>
@Override
<span class="keyword">public</span> E <span class="built_in">set</span>(<span class="built_in">int</span> index, E element) {
    rangeCheck(index);
    E oldValue = elementData(index);
    elementData[index] = element;
    <span class="keyword">return</span> oldValue;
}

<span class="comment">//各种add方法实现</span>
@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> <span class="built_in">add</span>(E e) {
    <span class="comment">//检查并扩增大小，该方法会增加修改计数器，并且一次扩展(3/2)大小防止了频繁扩展带来的开销</span>
    ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);
    elementData[<span class="built_in">size</span>++] = e;
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

@Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">add</span>(<span class="built_in">int</span> index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);
    <span class="comment">//将数组缓冲区中，index及之后的结点后移</span>
    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,
            <span class="built_in">size</span> - index);
    elementData[index] = element;
    <span class="built_in">size</span>++;
}

@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> addAll(Collection&lt;? extends E&gt; c) {
    <span class="comment">//获取集合中的元素数组，这样做的好处在于可以自由操作这些元素，而不用影响集合c</span>
    <span class="keyword">Object</span>[] a = c.toArray();
    <span class="built_in">int</span> numNew = a.length;
    ensureCapacityInternal(<span class="built_in">size</span> + numNew); <span class="comment">//增加modCount</span>
    System.arraycopy(a, <span class="number">0</span>, elementData, <span class="built_in">size</span>, numNew);
    <span class="built_in">size</span> += numNew;
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> addAll(<span class="built_in">int</span> index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);

    <span class="keyword">Object</span>[] a = c.toArray();
    <span class="built_in">int</span> numNew = a.length;
    ensureCapacityInternal(<span class="built_in">size</span> + numNew); <span class="comment">//增加modCount</span>

    <span class="comment">//如果是在尾部插入就不需要移动了</span>
    <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - index;
    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)
        System.arraycopy(elementData, index, elementData, index + numNew,
                numMoved);

    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);
    <span class="built_in">size</span> += numNew;
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="comment">//各种删除的实现</span>
@Override
<span class="keyword">public</span> E remove(<span class="built_in">int</span> index) {
    rangeCheck(index);

    modCount++; <span class="comment">//fail-fast</span>
    E oldValue = elementData(index);

    <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - index - <span class="number">1</span>;
    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)
        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,
                numMoved);
    elementData[--<span class="built_in">size</span>] = <span class="keyword">null</span>; <span class="comment">//防止内存泄漏</span>

    <span class="keyword">return</span> oldValue;
}

@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="keyword">Object</span> o) {
    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {
        <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; <span class="built_in">size</span>; index++)
            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) {
                fastRemove(index);
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
    } <span class="keyword">else</span> {
        <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; <span class="built_in">size</span>; index++)
            <span class="keyword">if</span> (o.equals(elementData[index])) {
                fastRemove(index);
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="comment">//保留差集</span>
@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> removeAll(Collection&lt;?&gt; c) {
    Objects.nonNull(c);
    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);
}

<span class="comment">//保留交集</span>
@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> retainAll(Collection&lt;?&gt; c) {
    Objects.nonNull(c);
    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);
}

<span class="comment">//置空防止内存泄漏</span>
@Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>() {
    modCount++;

    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)
        elementData[i] = <span class="keyword">null</span>;

    <span class="built_in">size</span> = <span class="number">0</span>;
}

<span class="comment">//正向查找，返回元素第一次出现的索引值</span>
@Override
<span class="keyword">public</span> <span class="built_in">int</span> indexOf(<span class="keyword">Object</span> o) {
    <span class="keyword">if</span>(o == <span class="keyword">null</span>) {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)
            <span class="keyword">if</span> (elementData[i] == <span class="keyword">null</span>)
                <span class="keyword">return</span> i;
    } <span class="keyword">else</span> {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)
            <span class="keyword">if</span> (o.equals(elementData[i]))
                <span class="keyword">return</span> i;
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
}

<span class="comment">//反向查找，返回元素最后一次出现的索引值</span>
@Override
<span class="keyword">public</span> <span class="built_in">int</span> lastIndexOf(<span class="keyword">Object</span> o) {
    <span class="keyword">if</span>(o == <span class="keyword">null</span>) {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)
            <span class="keyword">if</span>(elementData[i] == <span class="keyword">null</span>)
                <span class="keyword">return</span> i;
    } <span class="keyword">else</span> {
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)
            <span class="keyword">if</span> (o.equals(elementData[i]))
                <span class="keyword">return</span> i;
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
}

@Override
<span class="keyword">public</span> <span class="built_in">boolean</span> contains(<span class="keyword">Object</span> o) {
    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;
}

<span class="comment">//对数组进行排序</span>
@Override
@SuppressWarnings(<span class="string">"unchecked"</span>)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">sort</span>(Comparator&lt;? <span class="keyword">super</span> E&gt; c) {
    <span class="keyword">final</span> <span class="built_in">int</span> expectedModCount = modCount;
    Arrays.<span class="built_in">sort</span>((E[]) elementData, <span class="number">0</span>, <span class="built_in">size</span>, c);
    <span class="keyword">if</span> (modCount != expectedModCount) {
        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();
    }
    modCount++;
}


<span class="comment">//保护性拷贝</span>
@Override
<span class="keyword">public</span> <span class="keyword">Object</span>[] toArray() {
    <span class="keyword">return</span> Arrays.copyOf(elementData, <span class="built_in">size</span>);
}

@SuppressWarnings(<span class="string">"unchecked"</span>)
@Override
<span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) {
    <span class="keyword">if</span>(a.length &lt; <span class="built_in">size</span>)
        <span class="comment">//必须创建一个与参数类型相同的数组</span>
        <span class="keyword">return</span> (T[])Arrays.copyOf(elementData, <span class="built_in">size</span>, a.getClass());
    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, <span class="built_in">size</span>);
    <span class="keyword">if</span> (a.length &gt; <span class="built_in">size</span>)
        a[<span class="built_in">size</span>] = <span class="keyword">null</span>; <span class="comment">//用来帮助调用者确定集合长度（只有在明确知道集合中没有null元素时才有用）</span>
    <span class="keyword">return</span> a;
} 
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-8集合框架源码/">Java 8集合框架源码</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java并发（七）——内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/11/Java并发（七）——内存模型/" class="article-date">
  	<time datetime="2015-12-11T06:48:41.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/Java并发（七）——内存模型/">Java并发（七）——内存模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>心得：<br>内存模型的就是为了在现代计算机平台中保证程序可以正确性的执行，但是不同的平台实现是不同的，比如重排序，x86中只会对Store-Load可能重排序，ia64可以在不存在数据依赖性的操作之间重排序。JMM就是为了屏蔽底层的细节，在不同平台JVM采用不同的实现，保证正确性的基础上，追求效率。<br>在理解了锁语义，volatile语义，final语义在内存模型中的定义后，对DCL的发展和演进有了更清晰的认识。</p>
<p>学习参考资料：<br>（1）《Java并发编程实战》；<br>（2）《深入理解Java虚拟机》；<br>（3）jls8；<br>（4）jvms8；<br>（5）<a href="http://www.infoq.com/cn/minibooks/java_memory_model" target="_blank" rel="external">深入理解Java内存模型</a></p>
<h1 id="1-_为什么需要Java内存模型">1. 为什么需要Java内存模型</h1><h2 id="编译/运行环境对可见性/原子性的影响：">编译/运行环境对可见性/原子性的影响：</h2><p>（1）编译器中生成的指令顺序，可以与源代码中的顺序不同；<br>（2）编译器可能把变量保存在寄存器而不是内存中；<br>（3）处理器可以采用乱序或并行等方式来执行指令；<br>（4）缓存可能会改变将写入变量提交到主内存的次序；<br>（5）保存在处理器本地缓存中的值，对其他处理器是不可见的；</p>
<blockquote>
<p>缓存的存在就是为了减少CPU的停顿，减少IO的次数，减少CPU等待I/O的时间。通过批处理的方式刷新写缓冲区，以及合并写缓冲区对同一内存地址的多次写。</p>
<p>重排序，多核（并行性提升），CPU时钟频率的提升，多级缓存等等，编译器也进行指令重排，全局寄存器分配算法等可以大大提升计算性能；但这些可能会影响程序的正确性，那么必须要要保证的正确性的执行次序，JMM正是规定了JVM必须遵循的一组最小保证。</p>
<p><strong>“次序”</strong>的正确是一个关键问题；</p>
<p>并发编程需要处理两个关键问题是：线程之间如何<strong>通信</strong>及线程之间如何<strong>同步</strong>；命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>；</p>
</blockquote>
<h3 id="平台的内存模型">平台的内存模型</h3><p>提高CPU主频来提升计算性能出现了瓶颈，多核处理器是一个新的主要方向（也是是Amadhl定律为什么很重要的原因）；</p>
<p>在多核处理器环境下，每个处理器有自己的缓存，定期与主内存进行协调。<strong>高速缓存</strong>的使用为了解决处理器速度和内存读取速度的矛盾（存储器越小，速度越快，价格越高。高速缓存的一个核心原理就是<strong>局部性原理</strong>，这也是为什么这种小块缓存方案可行的原因）。<br>当然也就需要解决<strong>缓存一致性</strong>的问题，比如在<strong>操作系统层面</strong>，有MESI，MSI等等协议，来保证程序执行在多核处理器环境下的正确性。<br>但Java是一款“一次编译到处运行”的语言，那JMM（Java内存模型）就是JVM需要保证的模型，屏蔽底层OS的差异（JVM规范对JMM的定义委托给了Java语言规范）。</p>
<h3 id="重排序">重排序</h3><p>这里可以将：<br>（1）处理器的乱序执行，CPU将不存在数据依赖性的指令重叠执行（到流水线）；<br>（2）处理器并行执行，由于缓存和读/写缓冲区导致的行为上乱序；<br>（3）编译器的指令重排序；<br>使得为同步的程序的执行顺序的推断变“乱”的这些原因，统称为重排序；</p>
<p>不同处理器平台上允许的重排序类型列表：<br>|    平台      | load-load|load-store|store-store|store-load |数据依赖  |<br>|:——-:|:——–:|:——–:|:———:|:———:|:——-:|<br>|sparc-TSO| N        |N            |N            |Y            |N          |<br>|x86      | N        |N            |N            |Y            |N          |<br>|ia64      | Y        |Y            |Y            |Y            |N          |<br>|PowerPC  | Y        |Y            |Y            |Y            |N          |<br>注：x86包括x64和AMD64；</p>
<p><strong>内存屏障的类型</strong>：<br>（1）<strong>LoadLoad</strong>：load1; LoadLoad; load2;<br>（2）<strong>StoreStore</strong> ；<br>（3）<strong>LoadStore</strong>；<br>（4）<strong>StoreLoad</strong>：使得该屏障之前的所有内存访问指令（装载和存储）完成后，才执行屏障之后的内存访问指令；<br>StoreLoad，写读屏障是“全能屏障”，大多数处理器平台都支持这一屏障。该屏障的开销较大，因为要将缓存全部刷新到主存（LoadLoad和LoadStore只要保证顺序就好了）；</p>
<h4 id="数据依赖性和as-if-serial语义（单线程内的正确性）">数据依赖性和as-if-serial语义（单线程内的正确性）</h4><p><strong>单个处理器</strong>指令执行序列中，如果两个操作访问同一个变量，并且有一个操作是写操作，那就存在数据依赖性，具有编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<br>注意是单个处理器，不同处理器并行就需要另外的保证了。</p>
<p><strong>as-if-serial语义</strong>：<br>不管怎么重排序，（单线程）程序的执行结果不能被改变。as-if-serial语义可以保证单线程程序执行的正确性，但是并行情形下，这个是不够的。</p>
<h4 id="内存屏障（内存可见性的“底层”实现手段）">内存屏障（内存可见性的“底层”实现手段）</h4><p>内存屏障</p>
<h1 id="2-_Java内存模型的内容">2. Java内存模型的内容</h1><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。定义了线程（工作内存或本地内存）和主内存之间的抽象关系（当然这只是一种<strong>抽象</strong>的定义）。</p>
<p>每个线程有自己的私有本地内存，存储主内存中共享变量的副本；这里的变量包括实例域，静态域，数组元素。<br>线程之间的内存互相不可见，只能通过主内存来传递。JMM通过定义<strong>缓存一致性协议</strong>来保证必要的<strong>可见性</strong>和<strong>原子性</strong>。</p>
<h4 id="重排序和程序顺序规则（Happens-Before）">重排序和程序顺序规则（Happens-Before）</h4><p>上面说了as-if-serial可以保证在单线程环境下的正确性，但对于java程序来说这是远远不够的。</p>
<p>JMM规定了一种偏序关系，也就是Happens-Before（具有反对称，自反，传递属性）；两个操作之间不存在Happends-Before关系，JVM可以进行任意地重排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//操作A</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//操作B</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//操作C</span></span><br></pre></td></tr></table></figure></p>
<p>操作A，C之间，B，C之间存在Happens-Before关系，不能进行重排序（无论是否在同一个线程）；<br>操作A，B之间不存在Happens-Before关系，因此可以重排序，并行等；</p>
<p><strong>Happens-Before的规则有（8个）：</strong><br>（1）<strong>程序顺序规则</strong>：在一个线程内，书写在前面的操作先行发生于书写在后面的操作（主要考虑控制流顺序）；<br>（2）<strong>监视器锁规则</strong>：内置锁上的解锁操作必须先于发生于后面在同一个锁上的加锁操作；（之前我们总结过显式锁和内置锁具有相同的内存语义，后面是指绝对<strong>时间上</strong>先后）<br>（3）<strong>volatile变量规则</strong>：对volatile变量的写入操作必须先行发生于后面对该变量的读入操作（原子变量和volatile变量在读写操作上有相同的语义，后面同样是指时间上先后）；也就是说，如果在时间上，写操作发生在先面，那它的结果一定要被后面发生的读操作看到，无论是否在同一线程内，这就是可见性保证。<br>（4）<strong>线程启动规则</strong>：线程上对Thread.start()必须先行发生于对该线程中任务操作之前；<br>（5）<strong>线程终止规则</strong>：线程中所有操作必须先行发生于对此线程的终止检测；也就是说Thread.join()和Thread.alive()不可能在线程操作结束之前分别返回和返回true；<br>（6）<strong>线程中断规则</strong>：线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，保证Thread.interrupted()和Thread.currentThread().isInterruted()方法的正确性；<br>（7）<strong>终结器规则</strong>：对象的构造函数必须在启动它的终结器（finalize()方法）之前执行完成；<br>（8）<strong>传递性</strong>；</p>
<blockquote>
<p>as-if-serial语义保证了单线程内的正确性，Happens-Before更包含了并行环境下的正确性。</p>
</blockquote>
<h3 id="JMM和顺序一致性内存模型">JMM和顺序一致性内存模型</h3><p>首先说明JMM并不保证顺序一致性，所谓的顺序一致性内存模型保证一个线程的所有操作必须按照程序的顺序来执行；所有线程都只能看到一个单一的操作执行顺序，每个操作都必须原子执行且立刻对所有线程可见。</p>
<p>所以顺序一致性内存模型是一个很严格的规定，在每个线程存在缓存的情况下保证每个操作对所有线程立即可见需要很大的代价。</p>
<p>而JMM并不像这样严格，根据上面的8个Happens-Before，我们可以知道，在保证正确同步时，临界区是可以重排序的（当然要保证as-if-serial语义）：<br><img src="http://cdn2.infoqstatic.com/statics_s2_20160105-0313u5/resource/articles/java-memory-model-3/zh/resources/4.png" alt=""><br>（图片来源于info）</p>
<blockquote>
<p>所以JMM的目的在于保证程序执行正确性下，可以尽可能的利用并行，重排序等优化手段。</p>
</blockquote>
<p>对于未同步程序的执行特性，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（这也是为啥分配对象内存要清零初始化了）。</p>
<p>虽然JMM不支持顺序一致性模型，但通过对比也可以更好的理解JMM。</p>
<h3 id="long和double操作规则">long和double操作规则</h3><p>JMM要求<strong>lock</strong>，<strong>unlock</strong>，<strong>read</strong>，<strong>write</strong>，<strong>assign</strong>，<strong>use</strong>，<strong>load</strong>，<strong>store</strong>这8个操作具有原子性，对于64位的long和double来说，如果没有被volatile修饰，那可以鼓励但不保证原子性（可以划分为两个32位操作）。</p>
<p>这样规定是处于对不同OS实现考虑的，对于32位处理器，总线宽度是32位，64位数据的原子性读写开销较大。因此如果分成2个32位分配到不同的总线事务（单个总线事务中内存读写具有原子性），那就不再具有原子性。<br><img src="http://cdn2.infoqstatic.com/statics_s2_20160105-0313u5/resource/articles/java-memory-model-3/zh/resources/6.png" alt=""></p>
<blockquote>
<p>但是大部分商业JVM实现都保证了long和double的原子性。</p>
</blockquote>
<h3 id="volatile语义">volatile语义</h3><p><strong>写-读内存语义</strong>：<br><strong>写语义：</strong><br>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p>
<p><strong>读语义：</strong><br>主存更新后，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
<p><strong>JMM volatile语义实现和作用</strong>：<br>（1）<strong>保证可见性</strong>（之前的总结系列中也说过依赖当前值或者和其他变量组成不变性条件需要同步控制保证原子性）；<br>（2）<strong>禁止部分重排序</strong><br>|    是否能重排序    |    第二个操作    |            |            |<br>| :———— | :————:| :——–:|:———:|<br>|    第一个操作    |    普通读/写        |volatile读    | volatile写    |<br>|    普通读/写         |                |            |    NO        |<br>|    volatile读    |    NO            |    NO        |    NO        |<br>|    volatile写    |                 |    NO        |    NO        |</p>
<p><strong>volatile和内存屏障：</strong><br>编译器在生成字节码时，JMM在指令序列中插入内存屏障来禁止特定类型的处理器重排序：<br>（1）在volatile变量写之前，插入一个StoreStore，之后插入一个StoreLoad；<br>（2）在volatile变量读之前，插入一个LoadLoad和LoadStore；<br>这是一种严格的保守规定，不同的处理器平台可以根据自己的特点进行设计，只要保证语义正确性就可以：<br>比如x86只规定在写操作之后插入一个StoreLoad就可以了，因为x86中只有Store-Load前后指令才可以重排序，所以其他3个Barrier实际没有必要。</p>
<p>还有一个需要注意地方：如果写操作之后直接是return指令，也要保证插入一个StoreLoad，因为并不能确定之后的语句是什么；</p>
<p>PS：<br>（1）JSR-133之前的内存模型并不禁止普通变量的读写和volatile变量之间的重排序，因此JDK1.5之前的双检锁是有问题的。JSR-133将volatile的内存可见性语义“升级”的和监视器锁一样，解决这个问题，但是volatile是保证单个变量，而后者是整个临界区。<br>（2）不同的处理器平台实现volatile语义的具体方式不一样，比如IA-32处理器和Intel 64处理器通过MESI（修改，独占，共享，失效）保证对volatile的写入刷新到主内存，其他处理器通过嗅探到更新使得自己的对应缓存行失效，这样保证下一次读取的时候从主存中读取新的值。</p>
<p><strong>volatile语义和双检锁：</strong><br>之所以要使用双检锁就是为了减少同步的开销，提高效率，但是这要求检测到<code>helper != null</code> 时对象处于一致的状态。</p>
<p>PS：当前比较好的做法是使用枚举或者静态内部类的方式实现，随着JDK1.6以来对synchronized的优化，这种简单判断语句同步与否没有那么耸人听闻，不过追求“最优”总是一件有意义的事。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Helper result = helper;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                result = helper;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helper = result = <span class="keyword">new</span> Helper();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other functions and members...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JDK 1.5之前会有问题，前面说过JDK1.5之前volatile语义和普通变量读写之间可以被重排序，因此<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helper = result = <span class="keyword">new</span> Helper();</span><br></pre></td></tr></table></figure></p>
<p>这里构造器中的读写操作可能逸出到构造函数返回对象引用之后的，这样另一个线程判断到<code>helper != null</code>时，对象可能存在不一致的状态中，而JSR-133增强了volatile的语义，解决这个问题。</p>
<p>PS：这里使用一个本地变量result是为了减少volatile的访问，根据《Effective Java》（第2版）的说法，这样可以提高25%的效率。</p>
<h3 id="final语义">final语义</h3><p><strong>final域与重排序规则</strong>：<br>（1）构造函数内对一个final域的写入，与随后把个被构造的引用赋给一个引用变量之间不能重排序；<br>在<strong>写入final指令</strong>和<strong>构造函数结束</strong>之间插入一个<strong>StoreStore</strong>屏障，防止写入final域逸出到构造函数之外，保证其他线程得到对象引用的时候，final域一定写入过了；<br>（2）初次读入一个包含final域的的对象引用和初次读入这个被包含的final域之间，不能重排序；<br>在<strong>读取final域之前</strong>插入一个<strong>LoadLoad</strong>屏障，这样可以保证获得一个非null的对象引用时，结合规则（1）已经初始化完成，在读取final域一定是正确的；<br>（3）如果final域是引用类型，构造函数内对final引用对象的成员域的写入和被构造对象的引用赋值给一个变量的，这两个操作之间不能重排序；</p>
<p><strong>final语义与双检锁：</strong><br>基于JSR-133对final语义的加强，可以通过下面的方式实现安全的双检锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> FinalWrapper&lt;Helper&gt; helperWrapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      FinalWrapper&lt;Helper&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;Helper&gt;(<span class="keyword">new</span> Helper());</span><br><span class="line">              &#125;</span><br><span class="line">              wrapper = helperWrapper;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper.value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为对构造器中对final域写不能“逸出”构造器，所以当<code>wrapper</code>不为null时，helperWrapper引用的对象已经被完成了正确的初始化了，所以不会在判断<code>wapper != null</code>时对象处于不一致的状态；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java并发/">Java并发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java并发（一）——线程安全基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/11/Java并发（一）——线程安全基础/" class="article-date">
  	<time datetime="2015-12-11T06:48:41.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/Java并发（一）——线程安全基础/">Java并发（一）——线程安全基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>心得：线程安全最关键是保持正确性，先验条件、状态间的约束条件，后验条件，是我们写一个程序正确性的基础，我们保持不变性（final），可见性（volatile，锁），以及原子性（Synchronized，显示锁）和其他的同步工具就是为了让程序中那些存在竞争条件的部分始终保持正确的顺序执行；</p>
<p>学习参考资料：<br>（1）Java并发编程实战；<br>（2）<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">进程与线程的一个简单解释</a>；<br>（3）《操作系统精髓与设计原理》；<br>（4）<a href="http://www.infoq.com/cn/news/2007/10/whatisscalability/" target="_blank" rel="external">你真的明白什么是可伸缩性吗？</a>；<br>（5）jls8（Java语言规范8）；<br>（6）JVM规范8；</p>
<h1 id="一、总览和原理">一、总览和原理</h1><h2 id="1-_Java线程模型和操作系统">1. Java线程模型和操作系统</h2><p>基于JVM对OS底层的兼容，在使用Java时可以依赖Java的线程库来创建单进程多线程的Java应用。但Java线程很多重要的特性是和操作系统的表现相关，Thread中很多方法都是native方法也有这个因素。优先级，Sleep，Yield等语义包括线程的调度也都依赖于操作系统的实现。<br>当然，这些细节并不会影响具体的业务功能开发，但是明白它们对一些问题的理解显然很有帮助。比如allocateDirect在进行分配时的开销为什么会比allocate要大（系统调用，执行模式的切换）；不同类型应用在不同硬件环境下表现有怎样的差异等等。</p>
<p>进程作为<strong>分配资源</strong>的基本单位，而把线程作为<strong>独立运行和独立调度</strong>的基本单位。</p>
<h4 id="进程，线程与Java：">进程，线程与Java：</h4><p>在1.2之前是基于用户线程（绿色线程）实现的，这样做有什么问题：<br>（1）虽然用户线程的管理对内核不可见，不需要切换到内核态，但是一个线程调用系统调用比如I/O会导致整个进程阻塞；<br>（2）用户线程对内核不可见的另一个问题是，只能利用一个CPU（因为对内核来说只看见一个进程/线程）；<br>（3）如果使用纯粹的用户线程必然增加JVM的实现难度和额外负担；</p>
<p>Java的线程模型是基于操作系统原生线程模型实现的，Windows，Solaris，Linux都支持单进程多线程的实现，Linux的线程是通过轻量级子进程实现的（和Solaris类似）；</p>
<blockquote>
<p>以Linux为例，线程模型是，一个进程拥有多个用户线程，每个用户线程基于一个轻量级进程（LWP），每个LWP基于一个内核线程（KLT），由Thread Scheduler调度，分配CPU资源；</p>
</blockquote>
<p>基于这个模型特点和对Java线程模型的影响：<br>（1）依赖于操作的底层实现，线程的创建/销毁，优先级，yield/Sleep等等都基于操作系统实现；<br>（2）LWP对一个KLT，系统调用需要在用户态和内核态中切换，LWP需要占用一定内核资源（比如一个LWP要保存ID，优先级，信号掩码，寄存器，内核栈，地址空间，文件系统，处理器上下文等）；<br>（3）Linux中一个进程创建“线程”（实际上是子进程）可以通过<code>clone()</code>调用：<br>子线程<strong>复制</strong>那些可以写的部分（堆栈，数据段，文件，共享库，ipc），对Java应用来说，由于基于JVM，就是JVM运行时数据区域等，这是一个逻辑副本，共享地址空间，因此堆、方法区中的数据对线程是可见，虚拟栈（以及栈的PC寄存器等）基于JVM，Java线程之间互相独立，这时Java程序的用户线程部分；<br>子线程<strong>共享</strong>那些只读的部分，正文（程序）和数据，这和我们平时所见的Java程序没有直接关系，jar包的内容对于Java进程（JVM实例）来说是磁盘（或者网络）上的二进制字节码流；<br>子线程<strong>不会继承</strong>，进程ID，各种锁，定时锁，未决信号；</p>
<blockquote>
<p>当然JVM的存在对Java应用程序来说屏蔽了底层很多细节，这些说这些只是为了说明Java线程和轻量级进程之间的对应关系；</p>
</blockquote>
<h2 id="2-_Java中线程和锁定">2. Java中线程和锁定</h2><h3 id="Thread及其状态">Thread及其状态</h3><p>基于之前的表述，在一个支持多线程操作系统中，Java线程模型到操作系统（比如Linux）应该存在这样一条对应关系：<br>一个Java的<strong>Thread</strong>对象——（对应）——一个JVM中一个<strong>VMThread</strong>对象（HotSpot VM，C++）——（对应）——一个<strong>LWP</strong>（轻量级线程）——（对应）——一个<strong>KLT</strong>（内核级线程）；</p>
<p>正像操作系统中线程需要状态来描述一样，Java中Thread也有自己的状态（6种状态）：<br>（1）<strong>New</strong>：新创建，start之前；<br>（2）<strong>Runnable</strong>：可运行，包括正在运行；<br>（3）<strong>Blocked</strong>：被阻塞，等待<strong>内置锁</strong>时会进入Blocked；<br>（4）<strong>Waiting</strong>：等待，wait，join，等待Lock，Condition.await会导致进入等待状态；<br>（5）<strong>Timed Waiting</strong>：计时等待，sleep，带计时参数的wait，join，Condition.await，Lock.tryLock；<br>（6）<strong>Terminated</strong>：被终止，有两种情况，一是正常退出自然死亡，二是因为<strong>没有捕获的异常</strong>终止了run方法而意外退出；</p>
<p><strong>问题一：Blocked和Waiting有什么区别</strong><br>最直接的区别上面已经说过，Thread的Blocked状态只是在等待内置锁时才能产生，而等待状态则是在等待一段时间或者唤醒动作，但是很多教材在讨论Java中阻塞和等待时并不是对应于Thread的状态的，因此可能会有一些混淆，一般意义上阻塞和等待的意思相近都表示等待某个事件的发生或条件的满足，这和这里讨论的Thread的阻塞状态是由区别的。具体来说，一般意义上，我们可以将下列事件成为”阻塞“：<br>（1）等待<strong>内置锁</strong>，Thread为Blocked状态，不可中断；<br>（2）java.io中InputStream的read方法，Thread的状态为Runnable，同样是不可中断的，read方法一般会导致切换到内核状态，进行系统调用，等待IO事件，线程在OS中的状态会变成阻塞，但这对于Java的Thread并不需要知道；<br>（3）Object的wait方法，Thread为WAITING状态，等待通知，可以响应中断；<br>（4）J.U.C中的Lock的lock方法不会响应中断，但是lockinterruptible可以响应中断，Thread为WAITING状态；<br>等等；<br>可见，Thread的状态，能否响应中断，是否阻塞并不能一概而论，它们各自有自己的语义。</p>
<h3 id="Synchronized关键字">Synchronized关键字</h3><p>正如JLS中所说的，Synchroinzation语义是Java线程间同步的最简单的方式，当然”简单“是对使用者来说的。</p>
<p><strong>要点</strong>：<br>（1）Synchronized是互斥的，monitor监视器，又称为内置锁；<br>（2）等待内置锁的线程处于<strong>BLOCKED</strong>状态；<br>（3）static的Synchronized方法（类方法）基于该类的Class对象的内置锁；<br>（4）加锁和解锁动作有原子性保证；</p>
<h3 id="wait，notification，interrupt">wait，notification，interrupt</h3><h4 id="Wait">Wait</h4><p>wait语义很重要，像join等方法都是依赖wait来实现的；<br>前面我们已经知道wait有无限等待和计时等待两个版本；<br>JLS中用Wait Set表示等待一个锁对象的所有等待状态的线程的集合；<br><strong>wait要点</strong>：<br>（1）调用wait方法的条件时，当前线程必须拥有对应的锁，否则抛出IllegalMonitorStateException；<br>（2）wait可以响应中断，如果当前线程处于被中断，将会抛出InterruptedException，不仅是调用wait方法时，wait之后重新获得锁后，依然可以抛出InterruptedException；<br>（3）wait会释放锁，相对的sleep不会释放锁；</p>
<p><strong>wait的执行流程（Thread t中执行wait）</strong>（by JLS）：<br>（1）将Thread t加入wait set，释放锁；<br>（2）Thread t将不再执行任何指令，直到notify/notifyAll，或者Thread t被请求中断，等待超时；<br>（3）Thread t重新获得锁；<br>（4）如果第2步中是因为中断请求，抛出InterruptedException，<strong>并清除中断状态</strong>；</p>
<h4 id="Notification：">Notification：</h4><p>notify和notifyAll，notify选择一个等待线程通知唤醒，但是当存在对多个不同条件等待的线程时，由于不能保证哪一个线程被唤醒；因此notifyAll要安全一些；<br><strong>要点</strong>：<br>（1）必先获得锁；<br>（2）notify和interrupt，如果等待线程中一个线程被中断了，那么除非所有的线程都被中断了，不然notify必然会保证至少有一个线程可以被唤醒，正常执行；<br>（3）JLS中定义了当一个线程同时被中断和notify时，JVM实现有两种可能，一是正常被唤醒，但是保留中断状态；二是抛出InterruptedException，清除中断状态；<br>我实验了一下（Hotspot VM，还没看这块的源码），总是抛出异常，清除状态；</p>
<p><strong>问题：什么时候可以使用notify()？</strong><br>必须同时满足两个条件：<br>（1）所有等待线程的类型相同；<br>（2）单进单出，每次通知最多只能唤醒一个线程；</p>
<p><strong>notifyAll的效率问题：</strong><br>notifyAll由于会唤醒所有等待线程，当存在多个线程等待（不同的条件）时，可能大部分线程发现条件不满足又重新回到等待状态，这导致<strong>大量的上下文切换和竞争的锁获取操作</strong>，虽然比较“低效”，但是存在多个等待条件时，这是必须的；也就是说条件没有细化，而Lock+Condition可以细化不同的条件，这也是显式锁的一个优势；</p>
<p><strong>条件通知</strong>：<br>如果发生条件状态转换时再进行通知，而不是每次操作都通知可以优化减少“误唤醒”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> throw InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (isFull())</span><br><span class="line">		wait();</span><br><span class="line">	<span class="keyword">boolean</span> wasEmpty = isEmpty();</span><br><span class="line">	doPut(v);</span><br><span class="line">	<span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Interrupt：">Interrupt：</h4><p>首先得明白，这是一种协作机制，通过设置一个中断状态，wait等库函数会检查这个状态，或通过异常来协助处理；<br>（1）Thread.interrupted，返回当前中断状态，并清除，不用抛出异常了；<br>（2）t.isInterrupted()不清除状态，所以对于任务类来说通过Thread.currentThread().isInterrupted()一般要优于Thread.interruted()；<br>（3）一个好的做法是检查到中断状态时，要么抛出异常，要么捕获到异常后进行一次interrupt恢复中断状态，具体原因后面会说；</p>
<p><strong>问题：wait法和sleep方法的区别和联系</strong>：<br>（1）wait是Object的实例方法，sleep是Thread类方法；<br>（2）wait和sleep都会使Thread状态变为等待状态（WAITING/TIMED_WAITING），对应的都不再使用CPU执行时间，OS可以将执行时间分配给其他线程，区别在于wait需要notify/notifyAll之后才可以重新获得CPU执行时间，sleep计时完成后将可以重新获得CPU时间，sleep语义和底层操作系统有关（比如Solaris用poll调用实现，产生一个带timeout的io阻塞，线程进入阻塞队列）；<br>（3）sleep不会改变锁状态，wait必须先拥有锁并且释放锁，因此在同步控制块中使用sleep是一个糟糕的做法，在多线程争用一个锁的情况下，会极大的降低吞吐量；</p>
<h3 id="Sleep和Yield">Sleep和Yield</h3><p>sleep和yield语义依赖于操作系统的实现，它们没有同步语义，同时sleep的线程的恢复执行也要依赖调度和能否获得CPU时间。</p>
<h2 id="3-_显式锁">3. 显式锁</h2><blockquote>
<p>Lock提供了一种<strong>无条件的</strong>，<strong>可轮询的</strong>，<strong>定时的</strong>，<strong>可中断的</strong>锁获取操作，所有加锁和解锁方法都是显式的；<br>Lock的实现中必须提供与内置锁相同的内存可见性语义，但在<strong>加锁语义</strong>，<strong>调度算法</strong>，<strong>顺序保证</strong>，<strong>性能特性</strong>可以不同；</p>
</blockquote>
<h3 id="ReentrantLock">ReentrantLock</h3><p>提供了和synchronized相同的互斥性，内存可见性，可重入的加锁语义；</p>
<p><strong>显式锁和内置锁的不同</strong>：<br>（1）可中断，而内置锁不可中断正在等待锁的线程；<br>（2）显式锁可以实现非阻塞结构的加锁规则，JDK 1.6后synchronized虽然引入了偏向锁，轻量级锁和自适应自旋，但是这不是用户代码可控的；<br>（3）显式锁可以通过轮询锁和定时锁避免死锁等活跃性问题，内置锁一旦发生死锁就只能重启应用了；<br>（4）synchroinzed必须在获取锁的代码块中释放，结构简单易于使用，但是不如显式锁灵活，比如分段锁，链式加锁（比如链表遍历操作，直到获得了下个节点的锁，才释放前一个节点的锁），锁耦合；</p>
<blockquote>
<p>除了上述说的可中断，定时，可轮询这些明显的区别之外，还有一个重要的区别就是Lock+Condition有条件语义，而内置锁synchronized没有条件这一语义，很多时候一个条件满足了，我们调用<code>notifyAll()</code>，可能让多个等待条件上等待的线程被唤醒去竞争锁，想要细化就必须引入更多的锁，但即使引入再多的对象作为锁，对象本身可能是共享的，也没有办法百分百保证和条件绑定，所以我们说<code>notifyAll()</code>要比<code>notify()</code>更安全。<br>但如果看看ArrayBlockingQueue之类的阻塞队列的源码你可以发现，它们用的Lock和Condition，并且在唤醒时用的是<code>Condition.signal()</code>而不是<code>Condition.signalAll()</code>，因为通过Condition已经将等待某个条件的线程归于同一队列了，因此使用<code>singal()</code>是安全的，这也防止了唤醒所有线程同时竞争时的开销（每个线程都被唤醒，去竞争锁，检查，不满足再释放）。当然前面也说了，通过多个对象的内置锁也可实现，但是Java语言规范并没有给内置锁以条件语义，你能保证对象不被其他地方当作另外的锁用吗？显然很难，<strong>因此这就是Lock为什么要引入Condition的愿意和优势</strong>。</p>
</blockquote>
<p><strong>公平性（ReentrantLock和Samphore可以选择公平性）</strong>：<br>公平的锁：线程将按照它们发出请求的顺序来获得锁，即使是公平锁，tryLock轮询仍然可以插入；<br>非公平的锁：允许“插队”，如果在发出请求同时该锁的状态变为可用，那该线程可以跳过队列中所有等待线程；</p>
<p><strong>公平性和性能</strong>：<br>大多数情况，非公平性锁的性能要高于公平锁，如果算法需要保证公平性那另说；<br>公平性锁挂起线程和恢复线程存在的开销极大降低了性能；</p>
<blockquote>
<p>如果等待时间较长或者请求锁的平均时间较长，那么应该使用公平锁，因为这时，“插队”带来的吞吐量可能不会出现；</p>
</blockquote>
<p>synchronized和默认的ReentrantLock都是非公平的（当然在统计上是公平的）；</p>
<p><strong>读-写锁（避免读-写，写-写冲突）</strong>：<br>在多处理器系统上频繁读取，而写入较少，读-写锁可以提高性能，读写互斥，读读不互斥；其他情况，要比独占锁性能要略差一些，因为复杂性更高；</p>
<p>ReadWriteLock的特点：<br>（1）提高了可重入的语义；<br>（2）支持降级，写锁可以降级为读锁，但读锁不能审升级为写锁（防止死锁）；<br>（3）默认非公平可插队；<br>（4）写锁只能有唯一的所有者，读锁在JDK1.6后记录哪些线程已经获得了读锁；</p>
<h3 id="原子变量">原子变量</h3><p>互斥锁虽然简单，但是有如下问题：<br>（1）活跃性问题：死锁，饥饿，活锁等；<br>（2）优先级反转：低优先级的线程持有锁，高优先级的被阻塞；<br>（3）在协调不当的情况下，短时间持有锁，会由于线程上下文切换频繁，调度开销过大而降低性能；</p>
<p><strong>原子操作的硬件支持</strong>：<br>对于JVM来说，lock，unlock，read，write，load，store，use，assign这些操作是原子性的不可再分的，并且有硬件的支持（double和long另说）；除了这些基本的保证，处理对乐观，并发也有支持：<br>Test-And-Set；<br>Compare-And-Swap；<br>Fetch-And-Increment；<br>Swap；<br>Load-Linked/Store-Conditional；<br>这些指令都是处理器提供的原子性操作，Java中Unsafe类提供了这些功能（只能JDK框架内部使用，外部需要通过反射）；<br>J.U.C中的原子类也是基于这些机制实现的；</p>
<h3 id="封闭_VS_乐观_VS_悲观">封闭 VS 乐观 VS 悲观</h3><p>除了不可变对象之外，这三种可以说是实现线程安全的并发编程的主要手段。</p>
<p><strong>封闭</strong>：可重入，ThreadLocal；<br>如果能够做到每个线程各自封闭，就可以实现消除竞争和串行，根据Amadhl定律这是最理想的状态。</p>
<p><strong>乐观</strong>：原子类，自旋；<br>CAS，自旋等是乐观的同步方式：<br>（1）CAS自旋中应用代码要比锁要复杂，但是由调用者处理竞争问题；<br>（2）非阻塞，避免了阻塞带来的调度和上下文切换开销；<br>（3）在无竞争和竞争较少的情况下，效率要高于互斥锁，实际情况大多数情况是CAS更优；竞争较多的情况下，可能导致自旋次数过多浪费CPU，性能下降；<br>（4）不存在死锁，优先级反转等问题；但是也存在饥饿，活锁的风险；<br>（5）在单CPU环境下，CAS自旋也要由于锁，因为这样CAS失败的可能性很小；</p>
<p><strong>悲观</strong>：Lock，synchronized中的互斥锁；<br>Java中悲观锁的实现就是重量级的互斥锁了。<br>（1）应用代码简单，但JVM中执行的路径和开销较大；<br>（2）阻塞，需要处理调度和上下文切换开销；<br>（3）在高度竞争的情况下，效率要由于CAS自旋高；无竞争环境下，开销一般是CAS的两倍；竞争较少的情况下，CAS要优于互斥锁；<br>（4）存在死锁，优先级反转，饥饿，活锁等问题；</p>
<p>总的来看，Java中乐观和悲观之间的选择，在于CAS自旋的开销和阻塞调度/上下文切换之间的比较和权衡。这也是为什么JDK1.6引入自适应自旋的原因，即使从轻量级锁升级成了重量级锁，在真正阻塞之前也会进行一定次数的自旋（基于之前的统计）。</p>
<p><strong>其他领域的乐观和悲观：</strong><br>乐观和悲观的选择在很多领域都存在：比如<strong>大转盘（乐观）</strong>与<strong>红绿灯（悲观）</strong>，<strong>以太网（争用，乐观）</strong>与<strong>令牌环网（令牌互斥，悲观）</strong>。</p>
<h3 id="非阻塞算法">非阻塞算法</h3><p>一个线程的失败或挂起不会导致其他线程也失败或挂起。</p>
<blockquote>
<p>我觉得这是因为CAS自旋失败的原因就在于同样的操作，另一个线程成功了。因此总能保证有一个线程成功。</p>
</blockquote>
<p><strong>实例一：并发栈</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="keyword">new</span> AtomicReference&lt;&gt;(); <span class="comment">//栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        Node&lt;E&gt; newHead;</span><br><span class="line">        do &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            <span class="keyword">if</span> (oldHead == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            newHead = oldHead.next;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!top.compareAndSet(oldHead, newHead)); <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">return</span> oldHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        Node&lt;E&gt; newHead = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">        do &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            newHead.next = oldHead;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead)); <span class="comment">//自旋</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>实例二：并发队列</strong><br>我用反射使用Unsafe实现一个demo，实际上JDK源码中也是通过<code>Unsafe.objectFieldOffset</code>获取反射获取指定volatile域的偏移量结合<code>Unsafe.compareAndSwapObject</code>实现的，而不是直接使用原子类，这样做效率更高。（还有一个类似作用的东西叫原子域更新器，实际上是封装了上面的做法，不过不是用反射因为人家是JDK提供的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            Class&lt;?&gt; N = Node.class;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset(N.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        不在节点类中直接使用原子类性能更好</span><br><span class="line">        实际上J.U.C中也是采用Unsafe的cas更新+volatile；</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; dummy = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; head = dummy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Class&lt;?&gt; claz = sun.misc.Unsafe.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = claz.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (sun.misc.Unsafe)theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">            Class&lt;?&gt; k = MConcurrentLinkedQueue.class;</span><br><span class="line">            headOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">            tailOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    对于保证两个变量同时更新的原子性必须进行更复杂的判断和考虑（可见非阻塞算法比阻塞算法要复杂）</span><br><span class="line">    保证同时更新tail引用和oldTail.next引用，分为稳定状态和中间状态来考虑</span><br><span class="line">    一个关键的地方需要注意的是：设置保证tail在CAS设置时不用考虑成败，因为我们知道至少有一个线程可以修改成功，这经常被非阻塞算法所利用；</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Node&lt;E&gt; curTail = tail;</span><br><span class="line">            Node&lt;E&gt; tailNext = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (curTail == tail) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tailNext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span><br><span class="line">                    队列处于中间状态，说明有线程在进行插入操作</span><br><span class="line">                    注意这里不用成功与否，因此不成功说明其他线程成功设置了</span><br><span class="line">                     */</span></span><br><span class="line">                    UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, curTail, tailNext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//链表处于稳定状态</span></span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(curTail, Node.nextOffset, <span class="keyword">null</span>, newNode))  &#123;</span><br><span class="line">                        <span class="comment">//成功插入新节点，CAS设置tail，这里也一样不用考虑成败</span></span><br><span class="line">                        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, curTail, newNode);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"MConcurrentLinkedQueue["</span>);</span><br><span class="line">        <span class="keyword">while</span> (h.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;E&gt; n = h.next;</span><br><span class="line">            sb.append(n.item).append(<span class="string">','</span>);</span><br><span class="line">            h = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> ((len = sb.length()) &gt; <span class="string">"MConcurrentLinkedQueue["</span>.length())</span><br><span class="line">            sb.deleteCharAt(len - <span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用一个Barrier同步打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch LATCH = <span class="keyword">new</span> CountDownLatch(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertQueueTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MConcurrentLinkedQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InsertQueueTask</span><span class="params">(MConcurrentLinkedQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            queue.put(<span class="number">1</span>);</span><br><span class="line">            queue.put(<span class="number">2</span>);</span><br><span class="line">            queue.put(<span class="number">3</span>);</span><br><span class="line">            LATCH.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MConcurrentLinkedQueue&lt;Integer&gt; queue = <span class="keyword">new</span> MConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> InsertQueueTask(queue));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        LATCH.await();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ABA问题：</strong><br>如果只需基于一个正确old值就可以操作，那么ABA问题其实也不用考虑。如果A-&gt;B-&gt;A也认为发生了变化，那才需要考虑，使用<code>AtomicStampedReference</code>（提供一个额外的时间戳/version）来解决ABA问题。</p>
<h1 id="二、基础知识">二、基础知识</h1><h2 id="1-_线程安全是什么">1. 线程安全是什么</h2><p>线程安全代码的核心在于对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。</p>
<p><strong>保证线程安全的3种方式</strong>：<br>（1）不在线程之间共享该状态变量（共享性）；<br>（2）将状态变量修改为不可变的变量（可变性）；<br>（3）在访问状态变量时使用同步；</p>
<p><strong>怎么样设计以便于实现线程安全的关系</strong>：<br>封装性越好，越容易实现线程安全；<br>良好的面向对象技术，不可修改性，以及明确的不变性规范有利于实现线程安全；</p>
<p>总结：<br>（1）一方面从面向对象的角度，对外设计合理的接口，可以减少实现线程安全的难度，比如public成员变量这样的做法就很难维护；<br>（2）一方面从线程安全正确性的角度，向public成员变量，可能与其他状态之间存在一些约束条件，public相当于对外的一种承诺，那这种约束条件如果也让调用者承担显然是一种很可怕的事情。</p>
<p><strong>“线程安全”，“线程安全类”和“线程安全程序”</strong>：<br>使用线程安全类也不一定保证程序的就是线程安全的，线程安全类也可以包含非线程安全类，所谓的线程安全关于特定的状态并且是由特定的范围的；</p>
<p><strong>线程安全是什么</strong>：<br>线程安全最核心的是<strong>正确性</strong>，当多个线程访问某个类时，这个类始终表现出正确的行为，这个类就是线程安全（正确性包含<strong>不变性约束</strong>和<strong>后验条件</strong>组成）。</p>
<p><strong>无状态对象一定是线程安全的；</strong></p>
<h2 id="2-_原子性">2. 原子性</h2><h3 id="竞态条件：">竞态条件：</h3><p>当某个计算的正确性取决于多个线程的<strong>交替执行时序</strong>，就会发生竞态条件；<br><strong>常见的竞态条件</strong>：Check-Then-Act操作；</p>
<h3 id="复合操作的原子性：">复合操作的原子性：</h3><p>如果一组复合操作具有原子性也就不存在竞态条件；<br>使复合操作具有原子性本质上都需要加锁，Java中的原子类本质上是CAS自旋乐观锁；</p>
<h3 id="加锁：">加锁：</h3><p>当状态为多个时，仅仅各自保证对单个状态的原子性操作是远远不够的，<strong>状态之间的不变性约束条件</strong>也必须满足。</p>
<p><strong>（1）内置锁</strong>：每个Java对象都可以用做锁，对象头中Mark Word可以保存锁状态和锁记录，这是一种<strong>互斥锁</strong>，并且是<strong>可重入的锁</strong>；<br><strong>（2）重入</strong>：一个<strong>线程</strong>可以重复获取已经持有的锁，每个锁关联一个获取计数值和所有者线程，计数器为0表示为任何线程获取，一个线程每获取一次锁，计数器加1；</p>
<h4 id="重入和死锁">重入和死锁</h4><p>Java的锁<strong>粒度是线程</strong>，可重入最大的好处是防止死锁，一个同步控制块中可以调用基于同一个锁的，如果是不可重入的那么将会造成死锁。</p>
<h4 id="是否应该使用内置锁">是否应该使用内置锁</h4><p>使用内置锁可以省去创建显示的锁对象，但是很多时候直接使用内置锁同步控制状态的访问并不是好的做法：<br>（1）Synchronized同步阻塞是不可中断的，而显示锁可以中断，可以设置超时时间，可立即返回；<br>（2）使用内置锁迫使JVM需要在对象大小与加锁性能之间进行权衡；</p>
<h4 id="活跃与性能">活跃与性能</h4><p>（1）同步控制块尽可能<strong>小和少</strong>；<br>（2）耗时操作（比如网络，控制台I/O）一定不要持有锁；</p>
<h2 id="2-_对象的共享">2. 对象的共享</h2><h3 id="2-1_可见性">2.1 可见性</h3><p>一个线程对可变共享状态的修改能否被其他线程及时读取即对其他线程是否是可见的。</p>
<p>CPU的指令重排序，线程自身的缓存，非原子性的操作等会对可见性造成影响。</p>
<p>可见性仍然需要同步来保证，即使是volitable也是轻量级锁，它是通过锁缓存/总线（现代计算机应当是锁缓存）的方式来使得其他线程的缓存失效来保证可见性。</p>
<h4 id="失效数据">失效数据</h4><p>缺乏同步可能导致失效数据，即其他线程获取的是已经过期的数据。<br><strong>失效数据的栗子</strong>：<br>HashMap在并发环境下因为导致无限循环（resize过程中形成有环的链表）；</p>
<h4 id="最低安全性（out-of-thin-air-safety）">最低安全性（out-of-thin-air-safety）</h4><p>变量的读写操作都必须是原子操作，这保证即使我们可能读取是一个失效值，但至少这个值是由之前某个线程设置的。</p>
<p>Java中局部变量表和操作数栈的slot是32位的，因此long和double这样的64位需要分解为两个32位的操作。这long和double导致读取和写入不是原子操作，volatile或者锁可以保证long和double的原子性操作。</p>
<h4 id="保证可见性的手段">保证可见性的手段</h4><p>（1）加锁：Synchronized和ReentraLock，记住它们不仅仅是互斥，同样可以保证内存可见性；<br>（2）volatile变量：轻量级的同步机制，开销和它的语义相比可以忽略不计，保证不同线程对volatile变量的可见性，理解了<strong>锁缓存</strong>实现方式也就基本明白volatile能干什么，不能干什么；</p>
<p><strong>volatile的应用</strong>：<br>（1）对于“Check-Then-Act”，volatile是一种典型的应用，保证volatile变量自身状态的可见性，比如状态标志（是否已初始化/关闭），双检锁等都可以用volatile的布尔变量控制；<br>（2）volatile显然不能保证复合操作的原子性，对于状态的复杂判断（比如状态之间有约束等）就不要用volatitle了，它只能保证可见性；<br>（3）server模式和client模式：server模式下JVM会进行更多优化，比如将循环中为被修改的变量提升到循环外部，使用volatitle声明，防止这一点；</p>
<p><strong>使用volatile的条件</strong>：<br>（1）对变量的写入操作不依赖变量的当前值或者确保只有一个单个线程更新值；<br>（2）该变量不会与其他状态变量一起纳入不变性条件中；<br>（3）访问变量时不需要加锁，已经加锁了volatile也是多此一举；</p>
<h2 id="2-2_发布与逸出（帮助我们判断线程安全的界限）">2.2 发布与逸出（帮助我们判断线程安全的界限）</h2><p><strong>发布（Public）</strong>：对象能够在当前作用域之外的代码中使用；<br><strong>逸出（escapse）</strong>：某个不应该发布或者不应该在某个时刻发布的对象被发布就是“逸出”；对于后者，我觉得还是在于保持正确的时序，比如某个对象应该在构造器调用完成前才能进行使用，就不应该因为某些不当的操作造成逸出导致不正确的调用时序；</p>
<p>对象逸出的情况：<br>（1）在构造器中启动线程；<br>（2）在构造器中调用可被覆盖的方法，这还会因为多态导致不安全的问题；<br>（3）在构造器中将<code>this</code>注入到其他已经发布的对象中，因为你不能保证外部方法到底干了什么，比如：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ThisEscape</span> {
    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span>(<span class="params">EventSource source</span>) </span>{
        source.registerListener(
            <span class="keyword">new</span> EventListener() {
                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span>(<span class="params">Event e</span>) </span>{
                    doSomething(e)
                } 
            });
    }
}
</code></pre><p>通过定义<code>init()</code>方法，<code>dispose()</code>方法将初始化/释放的过程分离出来，保证时序的正确性；因此这不仅仅在抽象出回调接口，它的存在是必要的；</p>
<h2 id="2-3_线程封闭">2.3 线程封闭</h2><p>封闭是相对于逸出的，可共享的，将变量限制在线程中使用从而保证线程安全。</p>
<p><strong>Java中的线程封闭手段：</strong><br><strong>（1）Ad-hoc线程封闭</strong>：维护线程封闭性的职责完全由程序实现来承担，十分脆弱；它本身基于单线程子系统，自己保证只有单个线程对它进行使用。<br><strong>（2）栈封闭</strong>：使用局部变量，局部变量保存在栈的局部变量表中。需要保证的就是防止对象不会逸出，比如创建一个对象局部变量引用使用这问题，但是将它传入已经发布的方法，数组，集合等等这都存在破坏封闭的风险；<br><strong>（3）ThreadLocal类</strong>：我觉得在使用上<code>ThreadLocal&lt;T&gt;</code>相当于<code>Map&lt;ThreadId,T&gt;</code>，每个变量一个独立的副本，通常用于防止对可变的单实例变量或全局变量进行共享。ThreadLocal避免了使用共享静态缓冲区带来同步和频繁反配问题，线程终止后，这些值可以作为垃圾回收；</p>
<h2 id="2-4_不变性">2.4 不变性</h2><p>不可变对象一定是线程安全的；</p>
<p><strong>不可变对象的条件</strong>：<br>（1）状态一旦被创建就不再改变；<br>（2）所有的域都是final的（并不是绝对的，比如不可变类一个常用的优化是缓存hashCode，但它是计算一次并且基于不可变状态的）；<br>（3）对象被正确的构造；</p>
<p>final成员变量+构造器控制，这里涉及到一个final是否会被CPU重排导致逸出的问题。基于Java内存模型的定义，通过内存屏障可以保证：<br>（1）在构造函数中对一个final写入和将这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能被重排序；<br>（2）初次读一个包含final域的对象引用，与随后读取这个final域，这两个操作之间不能被重排序；</p>
<p><strong>保护性拷贝</strong>：<br>不可变对象中可变域或者不可变域中也可能进一步引用可变对象，同样要注意防止逸出，通过保护性拷贝是一种常用的手段。</p>
<h2 id="2-5_安全发布和共享">2.5 安全发布和共享</h2><p><strong>常用的安全发布模式</strong>（基于正确构造的对象）：<br>（1）在静态初始化函数中初始化一个对象引用，static块只执行一次并且是加锁阻塞的，这是有JVM来保证的（锁保护）；<br>（2）将对象的引用保存到volatile类型的域或者AtomicReferance对象中（可见性）；<br>（3）将对象的引用保存到某个正确构造对象的final类型域中（不可变）；<br>（4）将对象的引用保存到一个由锁保护的域中（锁保护）；</p>
<p><strong>对象的可变性和发布需求：</strong><br>（1）不可变对象可以任意的发布；<br>（2）事实不可变对象必须通过安全方式发布（对象实际上不会改变，那么读写对象引用本身的安全就要靠安全的发布方式来保证）；<br>（3）可变对象必须通过安全方式来发布，并且必须是线程安全的或者某个锁保护起来；</p>
<p><strong>安全的使用和共享对象的常用策略</strong>：<br>大部分线程安全问题在于共享性，可变性问题，首先要明确对象需要进行哪些操作，在此基础上，选择合适的线程安全策略：<br>（1）线程封闭：Ad-hod，栈封闭，ThreadLocal；<br>（2）只读共享（不可变对象和事实不可变对象）；<br>（3）线程安全共享：对象内部实现同步；<br>（4）保护对象：加锁；</p>
<h1 id="栗子：">栗子：</h1><p>（1）自增操作：由三个指令构成的：读取-修改-写入（load，const，store），如果对一个状态进行并发修改就会存在竞态条件；<br>（2）延迟初始化：典型的Check-Then-Act操作；<br>（3）NoVisibility；<br>（4）Integer.toString()使用ThreadLocal保存线程独立的缓冲区；<br>（5）多个存在约束条件的变量可以放在一个不可变对象之中，使用volatile变量引用该类型不可变对象，这样可以同时保证约束不变和可见性；</p>
<h1 id="3-_对象的组合（封装+组合模式——线程安全的设计）">3. 对象的组合（封装+组合模式——线程安全的设计）</h1><h2 id="3-1_设计线程安全的类（对象的状态的“安全”划分，哪些是封装自己控制，哪些是和别人共享的）">3.1 设计线程安全的类（对象的状态的“安全”划分，哪些是封装自己控制，哪些是和别人共享的）</h2><h3 id="基本原则：">基本原则：</h3><p><strong>设计线程安全类的3个基本要素</strong>：<br>（1）找出构成对象状态的所有变量；<br>（2）找出约束状态变量的不变性条件；<br>（3）建立对象状态的并发访问管理策略；</p>
<p><strong>同步策略</strong>：基于所有状态和状态以及之间的<strong>先验，不变，后验条件</strong>，选择<strong>不可变性（对应可变性），线程封闭（对应共享性），加锁保护</strong>等结合起来维护线程安全性。</p>
<p><strong>那些条件会影响线程安全</strong>：<br>（1）约束条件（不变性/后验条件）——&gt;存在无效状态——&gt;进行封装+原子性操作；<br>（2）不变性条件包含多个变量：<br>锁保护；<br>不可变对象包含所有的状态+volatile或者原子类引用这个对象；<br>（3）依赖状态：<br>先验条件（队列不为空），Check-then-Act；</p>
<h3 id="状态的所有权：进行封装的基础">状态的所有权：进行封装的基础</h3><p>（1）独占控制权：自身内部状态可以封装在对象内部，而不逸出的部分（可以通过保护性拷贝传递给外界副本）；<br>（2）共享控制权：从外部传入或者需要发布的状态，那么这些对象可以是线程安全的对象，事实不可变对象，锁保护；</p>
<p>栗子：容器类——“所有权分离”，ServletContext，Map；</p>
<h2 id="3-2_实例封闭（独占控制权）">3.2 实例封闭（独占控制权）</h2><p>封装：实例封闭+加锁保护——&gt;线程安全方式使用非线程安全的对象，并且这个对象必须不能逸出；</p>
<p>比如，SynchronizedMap与HashMap，封装了HashMap这个非线程安全的类，装饰器模式；</p>
<p>通过实例封闭分析类的线程安全无须检查整个程序；</p>
<h3 id="Java监视器模式">Java监视器模式</h3><p>监视器模式在于使用自己的内置锁来保护，简单明确。</p>
<p><strong>私有锁，内置锁还是公有锁</strong>：<br>如果使用<code>synchronized(&quot;SOME_STR&quot;)</code>设置<code>synchronized(Integer.valueOf(1)</code>这样的公有锁的风险在于你不能保证其他地方是否会使用这样的锁，即使不是这样的全局单例的锁，而是一个成员变量形式的锁，如果存在逸出同样具有这样的风险。在这样情形下产生活跃性问题就是一个全局的问题。</p>
<p><strong>使用私有锁</strong>的一个好处在于封闭性，这样我们就只需检查类本身，而不是整个程序，将耦合局限在局部。</p>
<p><strong>实例封闭的优缺点</strong>：<br>优点：可以很好的保证内部的一致性需求；<br>缺点：可能需要结合保护性拷贝开销较大，不能支持实时的最新信息；</p>
<h2 id="3-3_线程安全性的委托（共享控制权）">3.3 线程安全性的委托（共享控制权）</h2><p>PS：委托是创建线程安全类最有效的策略；</p>
<p>注意虽然委托给线程安全的类，但如果多个变量存在约束条件，仍然需要考虑增加一个线程安全层；</p>
<p>当一个类的多个可变状态时，一个做法是将它们统一的输入/输出，比如SafePoint，用一个数组输入和返回坐标(x,y)，<strong>我觉得这只是保证了最低安全性，但是x和y如果存在约束条件仍然是不安全的</strong>；</p>
<p><strong>使用线程安全性委托的优缺点</strong>：<br>优点：可以反映最新的信息；<br>缺点：当内部的状态之间存在约束时，可能导致内部状态不一致；</p>
<h2 id="3-4_现有的线程安全类添加功能">3.4 现有的线程安全类添加功能</h2><p>使用<strong>组合</strong>，装饰器模式；</p>
<h2 id="线程安全类设计小结">线程安全类设计小结</h2><p>和进行复杂的系统的设计一样，在设计线程安全的程序时没有绝对好模式可以套，需要分析复杂的实际情况，依据一些原则，模式，经验来设计。<br>我深深的感到线程安全问题和设计类体系结构息息相关，比如考虑封装还是委托，委托中是否又可以抽象出线程安全层，具体使用那一种手段来设计。能够面对复杂情况设计合适策略，真的需要大量的实践经验和分析复杂问题的能力。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java并发/">Java并发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java并发（三）——并发容器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/11/Java并发（三）——并发容器/" class="article-date">
  	<time datetime="2015-12-11T06:48:41.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/Java并发（三）——并发容器/">Java并发（三）——并发容器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Queue BlocingQueue</p>
<p>ConcurrentMap</p>
<p>ConcurrentSkipListMap——&gt;SortedMap（TreeMap）<br>ConcurrentSkipListSet——&gt;SortedSet（TreeSet）</p>
<p>CopyOnWriteArrayList/Set</p>
<p>Java 5之后提供了很多并发容器类。<br>相对与同步容器：<br>（1）同步容器是锁整个容器的，因此竞争的概率更大，随着容器包含的元素越多，竞争的概率，阻塞的时间可能越长，可伸缩性差，并且对容器状态访问都是串行化；<br>（2）并发容器利用分段锁，事实不可变对象，volatile可见性，克隆副本等方式提供并发访问设计，比如ConcurrentHashMap的读完全支持任意线程数量的并发，支持一定数量线程并发写；可伸缩性强；</p>
<h1 id="1-_ConcurrentHashMap">1. ConcurrentHashMap</h1><h2 id="1-1_要点">1.1 要点</h2><p>分段锁，弱一致性迭代器（支持并发修改）；size/isEmpty也具有非实时性<br>不支持独占加锁访问；<br>红黑树；</p>
<h2 id="1-2_结构和操作">1.2 结构和操作</h2><p>ConcurrentHashMap的一些基本功能和HashMap实现基本相同，HashMap也已经总结过了，这里重点分析并发相关的控制；<br><a href="http://blog.zerohuan.com/2015/12/12/Java%208%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94HashMap/">Java 8集合框架源码学习——HashMap </a></p>
<h3 id="重要的常量值">重要的常量值</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java并发/">Java并发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Zerohuan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>