<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Servlet深入学习，规范，理解和实现（上） | Zerohuan的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习参考资料：（1）Servet 3.1 final 规范；（2）《Java Web高级编程》；（3）《深入分析Java Web技术内幕》（第2版）；
心得：虽然现在是实际工作中很少直接使用Servlet，但了解Servlet规范中对不同组件（Servlet，Filter，Listener等等）以及Servlet容器的实现对于基于Servlet的Java EE应用的理解也是大有益处的。因此基于上面">
<meta property="og:type" content="article">
<meta property="og:title" content="Servlet深入学习，规范，理解和实现（上）">
<meta property="og:url" content="http://blog.zerohuan.com/2015/12/12/Servlet深入学习，规范，理解和实现（上）/index.html">
<meta property="og:site_name" content="Zerohuan的博客">
<meta property="og:description" content="学习参考资料：（1）Servet 3.1 final 规范；（2）《Java Web高级编程》；（3）《深入分析Java Web技术内幕》（第2版）；
心得：虽然现在是实际工作中很少直接使用Servlet，但了解Servlet规范中对不同组件（Servlet，Filter，Listener等等）以及Servlet容器的实现对于基于Servlet的Java EE应用的理解也是大有益处的。因此基于上面">
<meta property="og:image" content="http://blog.zerohuan.com/images/tomcat-servlet-structure.png">
<meta property="og:image" content="http://blog.zerohuan.com/images/tomcat-request-response.png">
<meta property="og:image" content="http://blog.zerohuan.com/images/tomcat-mapper.png">
<meta property="og:image" content="http://blog.zerohuan.com/images/tomcat-filter.png">
<meta property="og:updated_time" content="2016-01-18T12:43:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Servlet深入学习，规范，理解和实现（上）">
<meta name="twitter:description" content="学习参考资料：（1）Servet 3.1 final 规范；（2）《Java Web高级编程》；（3）《深入分析Java Web技术内幕》（第2版）；
心得：虽然现在是实际工作中很少直接使用Servlet，但了解Servlet规范中对不同组件（Servlet，Filter，Listener等等）以及Servlet容器的实现对于基于Servlet的Java EE应用的理解也是大有益处的。因此基于上面">
  
    <link rel="alternative" href="/atom.xml" title="Zerohuan的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zerohuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Talk is cheap, show me the code!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/Java-8集合框架源码/" style="font-size: 14px;">Java 8集合框架源码</a> <a href="/tags/Java基础知识/" style="font-size: 20px;">Java基础知识</a> <a href="/tags/Java并发/" style="font-size: 16px;">Java并发</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 12px;">TCP/IP</a> <a href="/tags/java-web/" style="font-size: 12px;">java web</a> <a href="/tags/思考和求解/" style="font-size: 18px;">思考和求解</a> <a href="/tags/技术更新/" style="font-size: 10px;">技术更新</a> <a href="/tags/杂谈-感悟/" style="font-size: 10px;">杂谈/感悟</a> <a href="/tags/算法和数据结构/" style="font-size: 10px;">算法和数据结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">现南京大学研究生一枚，目前专注于Java Web方向。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Zerohuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Zerohuan</h1>
			</hgroup>
			
			<p class="header-subtitle">Talk is cheap, show me the code!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zerohuan" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/yan-jin-heng" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:yanjinheng@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Servlet深入学习，规范，理解和实现（上）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Servlet深入学习，规范，理解和实现（上）/" class="article-date">
  	<time datetime="2015-12-12T06:48:41.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Servlet深入学习，规范，理解和实现（上）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-web/">java web</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>学习参考资料</strong>：<br>（1）Servet 3.1 final 规范；<br>（2）《Java Web高级编程》；<br>（3）《深入分析Java Web技术内幕》（第2版）；</p>
<p><strong>心得</strong>：虽然现在是实际工作中很少直接使用Servlet，但了解Servlet规范中对不同组件（Servlet，Filter，Listener等等）以及Servlet容器的实现对于基于Servlet的Java EE应用的理解也是大有益处的。因此基于上面3个资料的学习所得以及我自己阅读Tomcat 8相关部分源码的一些收获在这里总结记录一下。</p>
<h1 id="1-_Servlet容器">1. Servlet容器</h1><p>Servlet 容器是 web server 或 application server 的一部分，提供基于请求/响应发送模型的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器也包含了管理 Servlet 生命周期。</p>
<h1 id="2-_Servlet">2. Servlet</h1><p>Servlet 是基于 Java 技术的 web 组件，被容器所托管的，用于生成动态内容。像其他基于 Java 的组件技术一样，Servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 web server 动态加载并运行。</p>
<h2 id="2-1_Servlet的数量">2.1 Servlet的数量</h2><p>Servlet默认是线程不安全的，一个容器中只有每个servlet一个实例，但是如果实现了<code>SingleThreadModule</code>接口，容器将实现多个servlet实例<br><code>SingleThreadModule</code>也不能保证线程安全，它只能保证任意两个线程不会使用同一个Servlet实例（可能由一个对象池来维护），servlet2.4已经将这个接口已经标注为<strong>已过时</strong>了；</p>
<blockquote>
<p>我查看了Tomcat 8.0中StandardWrapper源码，这个类负责Servlet的创建，其中SingleThreadModule模式下创建的实例数不能超过20个，也就是同时只能支持20个线程访问这个Serlvet，因此，这种对象池的设计会进一步限制并发能力和可伸缩性。</p>
</blockquote>
<h2 id="2-2_servlet的生命周期">2.2 servlet的生命周期</h2><p>加载和实例化：servlet容器负责加载和实例化Servlet，在容器启动时根据设置决定是在启动时初始化（loadOnStartup大于等于0在容器启动时进行初始化，值越小优先级越高），还是延迟初始化致第一次请求前；</p>
<h3 id="初始化：">初始化：</h3><p><code>init()</code>，执行一些一次性的动作，可以通过ServletConfig配置对象，获取初始化参数，访问ServletContext上下文环境；<br>初始化时可能发生错误，UnavailableException和ServletException，那么servlet不应放置活动服务中，未成功初始化，destroy方法也应被调用</p>
<h3 id="请求处理：">请求处理：</h3><p>servlet容器封装Request和Response对象传给对应的servlet的service方法，对于HttpServlet，就是HttpServletRequest和HttpServletResponse；<br>HttpServlet中使用<strong>模板方法模式</strong>，<code>service</code>方法根据HTTP请求方法进一步分派到doGet，doPost等不同的方法来进行处理；</p>
<blockquote>
<p>对于HTTP请求的处理，只有重写了支持HTTP方法的对应HTTP servlet方法（doGet），才可以支持，否则放回405（Method Not Allowed）。</p>
</blockquote>
<p><strong>线程不安全</strong><br>servlet中默认线程不安全，单例多线程，因此对于共享的数据（静态变量，堆中的对象实例等）自己维护进行同步控制，不要在service方法或doGet等由service分派出去的方法，直接使用synchronized方法，很显然要根据业务控制同步控制块的大小进行细粒度的控制，将不影响线程安全的耗时操作移出同步控制块；</p>
<p><strong>异常</strong><br>请求处理时同样可能抛出异常，UnavailableException和ServletException；<br>UnavailableException表示不可用，永久不可用状态返回404；暂时不可用返回503（服务不可用），标注Retry-After头；</p>
<h3 id="异步处理：">异步处理：</h3><p>在<strong>Servlet中等待</strong>是一个低效的操作，因为这是阻塞操作。<br>异步处理请求能力，使线程可以返回到容器，从而执行更多的任务。当开始异步处理请求时，<strong>另一个线程或回调</strong>可以（1）产生响应；或者，（2）请求分派；或者，（3）调用完成；</p>
<h4 id="关键方法：">关键方法：</h4><p><strong>启用</strong>：让servlet支持异步支持：asyncSupported=true；</p>
<p><strong>启动</strong>：AsyncContextasyncContext=req.startAsyncContext();或startAsyncContext(req,resp);</p>
<p><strong>完成</strong>：asyncContext.complete();必须在startAsync调用之后，分派进行之前调用；同一个AsyncContext不能同时调用dispatch和complete</p>
<p><strong>分派</strong>：asyncContext.dispatch();dispatch(Stringpath);dispatch(ServletContextcontext,Stringpath);<br>不能在complete之后调用；<br>从一个同步servlet分派到异步servlet是非法的；</p>
<p><strong>超时</strong>：asyncContext.setTimeout(millis);<br>超时之后，将不能通过asyncContext进行操作，但是可以执行其他耗时操作；<br>在异步周期开始后，容器启动的分派已经返回后，调用该方法抛出IllegalStateException；如果设置成0或小于0就表示notimeout；<br>超时表示HTTP连接已经结束，HTTP已经关闭，请求已经结束了。</p>
<p><strong>启动新线程</strong><br>通过<code>AsyncCOntext.start(Runnable)</code>方法，向<strong>线程池</strong>提交一个任务，其中可以使用AsyncContext（未超时前）；</p>
<p><strong>事件监听</strong>：addListener(newAsyncListener{…})；<br>    <strong>onComplete</strong>：完成时回调，如果进行了分派，onComplete方法将延迟到分派返回容器后进行调用；<br>    <strong>onError</strong>：可以通过AsyncEvent.getThrowable获取异常；<br>    <strong>onTimeout</strong>：超时进行回调；<br>    <strong>onStartAsync</strong>：在该AsyncContext中启动一个新的异步周期（调用startAsyncContext）时，进行回调；</p>
<p><strong>超时和异常处理</strong>，步骤：<br>（1）调用所有注册的AsyncListener实例的onTimeout/onError；<br>（2）如果没有任何AsyncListener调用AsyncContext.complete()或AsyncContext.dispatch()，执行一个状态码为HttpServletResponse<br>.SC_INTERNAL_SERVER_ERROR出错分派；<br>（3）如果没有找到错误页面或者错误页面没有调用AsyncContext.complete()/dispatch()，容器要调用complete方法；</p>
<h3 id="终止：">终止：</h3><p>servlet容器确定从服务中移除servlet时，可以通过调用<code>destroy()</code>方法将释放servlet占用的任何资源和保存的持久化状态等。调用destroy方法之前必须保证当前所有正在执行service方法的线程执行完成或者超时；<br>之后servlet实例可以被垃圾回收，当然什么时候回收并不确定，因此destroy方法是是否必要的。</p>
<h2 id="2-3_Servlet（Filter）中的url-pattern">2.3 Servlet（Filter）中的url-pattern</h2><p>Serlvet和Filter有三种不同的匹配规则：<br>（1）精确匹配：/foo；<br>（2）路径匹配：/foo/<em>；<br>（3）后缀匹配：</em>.html；<br>Serlvet的匹配顺序是：<br>首先进行精确匹配；如果不存在精确匹配的进行路径匹配；最后根据后缀进行匹配；一次请求只会匹配一个Servlet；（Filter是只要匹配成功就添加到FilterChain）</p>
<p>PS：其他写法（/foo/，/<em>.html，</em>/foo）都不对；“/foo*”不能匹配/foo，/foox；</p>
<h1 id="3-_Request">3. Request</h1><h2 id="3-1_HTTP协议参数">3.1 HTTP协议参数</h2><p>通过HttpServletRequest对象获取Http参数：<br>getParameter，getParameterNames，getParameterValues，getParameterMap；</p>
<blockquote>
<p>这些方法从getRequestURI方法或getPathInfo方法返回的字符串值中解析，如果是POST方法，也是在第一次调用getParameter方法时候进行解码获取到参数集合当中，因此要在调用这些方法之前设置编解码方式，否则可能导致乱码；</p>
<p>POST表单数据也会被汇总到请求参数集合中，但要满足：<br>（1）Content-Type必须是application/x-www-form-urlencoded；<br>（2）进行getParameter调用；<br>如果不满足获取POST参数的条件，servlet可以通过request对象的输入流得到POST数据；相反如果满足条件，输入流中也不再可以读取POST数据（因为已经读取过了）；</p>
</blockquote>
<h2 id="3-2_文件上传">3.2 文件上传</h2><p>数据以multipart/form-data格式发送，servlet支持文件上传；<br>通过    <code>HttpServletRequest</code>的：<br><code>public Collection&lt;Part&gt; getParts()</code>；<br><code>public Part getPart(String name)</code>；</p>
<p>每个Part类代表从multipart/form-data格式的POST请求中接受的一个部分或表单项，每个Part可以通过<code>Part.getInputStream</code>方法访问头部，内容类型和内容；</p>
<p>对于表单数据的Content-Disposition，即使没有文件名，也可使用part的名称通过HttpServletRequest的getParameter和getParameterValues得到part的字符串值；</p>
<h2 id="3-3_属性：">3.3 属性：</h2><p>属性的作用域与请求相关；<br>getAttribute/getAttributeNames/setAttribute；</p>
<h2 id="3-4_请求路径元素">3.4 请求路径元素</h2><p>对于这样的请求各个部分是怎样的：<a href="http://localhost:8080/example/servlets/servlet/空幻?author=空幻#success" target="_blank" rel="external">http://localhost:8080/example/servlets/servlet/空幻?author=空幻#success</a></p>
<p><strong>Context Path</strong>：ServletContext关联路径，<code>getContextPath</code>，“/example”；<br><strong>Servlet Path</strong>：getServletPath，“/servlets/servlet”，请求“/<em>”与“”模式匹配对应的servlet path是空字符串；<br><strong>PathInfo</strong>：请求路径一部分，不属于Content Path或Servlet Path，“/空幻”，要么为null，要么为以“/”开头的字符串；<br><strong>Request URI</strong>：getRequestURI，等于contetPath + servletPath + pathInfo；<br><strong>QueryString</strong>：getQueryString，“author=空幻”；<br><em>*Request URL</em></em>：<a href="http://localhost:8080/example/servlets/servlet/空幻；" target="_blank" rel="external">http://localhost:8080/example/servlets/servlet/空幻；</a></p>
<h3 id="路径转换方法">路径转换方法</h3><p><code>ServletContext.getRealPath</code>；<br><code>HttpServletRequest.getPathTranslated</code>；<br>比如：<br>（1）“<a href="http://localhost:8080/s/request/pathinfo”" target="_blank" rel="external">http://localhost:8080/s/request/pathinfo”</a>, 在我的机器上<code>`getPathTranslated()</code>返回“/home/yjh/wks/workspace/ServletTest/target/servletTest/pathinfo”；<br>其中”/request”是serlvet path，“servletTest”是项目根目录名；这两个方法都是基于项目根目录返回的；</p>
<h2 id="3-5_Servlet_3-1新特性，非阻塞I/O">3.5 Servlet 3.1新特性，非阻塞I/O</h2><p>非阻塞I/O只能用在Serlvet和Filter的<strong>异步请求处理</strong>和<strong>升级处理</strong>中； 否则设置时抛出IllegalStateException；</p>
<p>Request——ServletInputStream——ReadListener；<br>Response——ServletOutputStream——WriterListener；</p>
<p>ReadListener：<br>（1）<strong>onDataAvailable</strong>：当可以从传入请求流中读取数据，onDataAvailable将被调用，和<code>ServletInputStream.isReady</code>相关；<br>（2）<strong>onAllDataRead</strong>：读取完成ServletRequest的所有数据时调用onAllDataRead方法，和ServletInputStream.isFinished()相关；<br>（3）<strong>onError</strong>(Throwable)；</p>
<h2 id="3-6_请求数据编码">3.6 请求数据编码</h2><blockquote>
<p>getParameter等参数获取方法会将参数部分从流中读取出来，因此一定要在getParameter调用前设置编解码方式：</p>
</blockquote>
<p>Request：<br><code>setCharacterEncoding()</code>；</p>
<p>Response：<br><code>setCharacterEncoding()</code>；<br><code>setHead()</code>；<br><code>setContentType()</code>；</p>
<h2 id="3-7_Request_对象的生命周期">3.7 Request 对象的生命周期</h2><p>每个Request对象在Servlet的service（这就包括JSP的表达式，脚本，声明），Filter的doFilter的作用域中有效；</p>
<p>启用了异步处理后，request对象将到AsyncContext的complete调用时；</p>
<h1 id="4-_ServletContext接口">4. ServletContext接口</h1><p>每个基于Servlet的Web应用都有自己的ServletContext保存和维护自己的上下文信息，包括：初始化参数，Servlet，Filter，Listener配置，容器属性等等。</p>
<h2 id="4-1_配置">4.1 配置</h2><p>主要有3种方式：<br>（1）Web.xml部署描述符；<br>（2）注解；<br>（3）通过ServletContextListener/ServletContainerInitializer使用Servlet/Filter的Registration配置；</p>
<h2 id="4-2_上下文属性">4.2 上下文属性</h2><p>容器也有自己的属性，这里提一下是因为这涉及到：<br>（1）EL表达式的<strong>隐式变量</strong>及<strong>作用域</strong>：applicationScope包含所有绑定到ServletContext的特性；EL表达式中变量的作用域也是一层层查找的，最后一层查找范围就是ServletContext的特性；<br>（2）同样JSP中的隐式变量application也是ServletContext实例；</p>
<h2 id="4-3_资源">4.3 资源</h2><p>获取Web应用下的资源：<br><code>getResource</code>和<code>getResourceAsStream</code>；<br>传入path，必须要以“/”开头，相对与两个目录：<strong>上下文的根目录</strong>和<strong>web应用的WEB-INF/lib中的JAR文件中的META-INF/resources目录</strong>。依次查找这两个地方；</p>
<blockquote>
<p>这两个方法不能获取<strong>动态内容</strong>，比如jsp，获取的是jsp文件源码而不是处理后的响应；</p>
</blockquote>
<h2 id="4-4_临时工作目录">4.4 临时工作目录</h2><blockquote>
<p>Servlet容器必须为每一个servlet上下文提供一个私有的临时目录，并将通过javax.servlet.context.tempdir上下文属性使其可用，该属性关联的是java.io.File。<br>这个目录也是Multipart处理中临时目录的默认目录，并且location如果是相对路径也是基于它的。</p>
</blockquote>
<h1 id="5-_Response">5. Response</h1><blockquote>
<p>Response的<code>getWriter</code>和<code>getOutputStream</code>在同一次请求中不能同时被调用。调用了一个之后在调用另一个会抛出IllegalStateException；</p>
</blockquote>
<h1 id="5-1_缓冲">5.1 缓冲</h1><p><strong>获取和设置缓冲区大小</strong>：getBufferSize和setBufferSize，不能在缓冲区写入内容之后设置缓冲区大小调用setBufferSize；</p>
<p>PS：tomcat 8中缓冲区大小为8192</p>
<p><strong>是否提交到客户端</strong>：isCommitted；</p>
<p><strong>刷新缓冲区</strong>：flushBuffer，也可以通过getWriter/getOutputStream调用输出流的flush；</p>
<p><strong>重置缓冲区</strong>：reset和resetBuffer，不能在响应提交后调用，否则抛出IllegalStateException，响应及关联的缓冲区不变；</p>
<h2 id="5-2_重定向和设置Error">5.2 重定向和设置Error</h2><p><code>sendRedirect</code>和<code>sendError</code>；<br>这两方法有一些相似性：<br>（1）如果在调用前已有响应<strong>提交</strong>到客户端，调用它们将抛出IllegalStateException；<br>（2）如果没有响应提交，sendRedirect和sendError将<strong>重置缓冲区</strong>，舍弃原来缓冲区中的旧数据，Servlet中之后的输出也是无效的（将被忽略）；</p>
<h2 id="5-3_Response编码和国际化">5.3 Response编码和国际化</h2><p>同样需要在响应未提交或resp.getWriter()之前进行设置，否则将无效（面向字符的输出已经设置默认编码）；</p>
<p><strong>国际化配置</strong><br>在部署描述符中配置，如果没有配置将使用容器依赖的mapping等配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">locale-encoding-mapping-list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">locale-encoding-mapping</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">locale</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="title">locale</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">locale-encoding-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">locale-encoding-mapping-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>setLocale也可以设置编码，在<code>setContentType</code>和<code>setCharacterEncoding</code>之前，调用<code>setLocale</code>设置编码，使用上面配置中的编码；但是这并不会设置HTTP响应头的content-type等头，因此浏览器/客户端将使用默认的解码方式来解码这可能导致乱码；</p>
<p>PS：setLocale将通过<code>Content-Language</code>响应头来传递；但是编码方式如果没有指定Content-Type，是不能通过HTTP header传递的；</p>
<p>因此，应该在getWriter方法被调用或响应被提交之前通过<code>setContentType</code>或<code>setCharacterEncoding</code>或<code>addHeader</code>设置编码方式，否则将使用默认编码：ISO-8859-1；</p>
<p><strong>setCharacterEncoding</strong>：这个方法可以覆盖<code>setLocale</code>和<code>setContentType</code>设置的编码方式，但不会设置Content-Type头；</p>
<blockquote>
<p><code>setLocale</code>，<code>setCaracterEncoding</code>和<code>setContentType</code>都可以设置编码方式，但是要通过<code>setContentType</code>和<code>addHeader</code>设置<code>Content-Type</code>响应头，并且它们都要在<code>getWriter</code>调用前或响应提交前设置；</p>
</blockquote>
<h2 id="5-4_结束响应对象">5.4 结束响应对象</h2><p>以下时间表明servlet满足了请求且响应对象即将关闭“<br>（1）servlet的service方法终止；<br>（2）响应的<code>setContentLength</code>或<code>setContentLong</code>制定了大于零的内容量，且已经写入到响应；<br>（3）<code>sendError</code>方法或<code>sendRedirect</code>方法已调用；<br>（4）AsyncContext的<code>compelete</code>方法已调用；</p>
<blockquote>
<p><code>setContentLength</code>和<code>setContentLengthLong</code>方法一般有Web容器在响应完成后负责调用，后者是Servlet3.1的新方法；</p>
</blockquote>
<h2 id="5-5_Response生命周期">5.5 Response生命周期</h2><p>和Request相似，在servlet的service方法和Filter的doFilter方法内有效，如果启动异步处理，知道complete方法被调用有效。</p>
<h1 id="6-_Filter">6. Filter</h1><h2 id="6-1_对Filter的理解">6.1 对Filter的理解</h2><p><strong>Filter</strong>和<strong>Servlet/其他Web资源（包括静态资源）</strong>组合起来使用，实现了一个职责链模式的请求处理调用栈，<strong>Servlet/Web资源</strong>是最后一个“入栈的节点”（当然Filter可以阻止请求到达Servlet/Web资源，）。Filter可以在servlet调用前和调用后进行一些额外的处理过程（比如，验证，日志，压缩等等）。</p>
<blockquote>
<p><code>FilterChain.doFilter(req, resp)</code>调用前后，正分别是调用栈“入栈”和“出栈”之时，做相应的处理。</p>
<p>每个Filter配置对应的每个JVM的容器仅实例化一个实例。</p>
</blockquote>
<h2 id="6-2_Filter的生命周期">6.2 Filter的生命周期</h2><p>（1）<code>init()/init(FilterConfig filterConfig)</code>：和Servlet一样可能抛出UnavaliableException（暂时不可用/永久不可用）；<code>init()</code>方法总是在应用程序启动时调用（ServletContextListener初始化之后，Servlet初始化之前）；<br>（2）<code>doFilter()</code>：服务中，处理传入请求和返回响应：可以进行检查请求头，修改请求头/数据，修改响应头等等；</p>
<blockquote>
<p>Filter可以调用chain.doFilter()方法调用过滤器链中下一个实体；也可以不调用来阻止请求；</p>
<p>doFilter过程中也可能抛出UnavailableException，容器负责停止处理剩下的过滤器链，若不是永久不可用，可以选择稍后重试整个链。</p>
</blockquote>
<p>（3）<code>destroy()</code>：容器把服务中的Filter实例移除前，先调用它的destroy方法，进行释放资源等清理工作；</p>
<h2 id="6-3_Filter的类型">6.3 Filter的类型</h2><p>Servlet容器中，存在多种分派方式，Servlet2.4之后，可以对不同的请求分派进行过滤：<br>（1）<strong>普通请求</strong>；<br>（2）<strong>转发请求</strong>：<code>RequestDispatcher.forward()</code>或<code>&lt;jsp:forward&gt;</code>触发的请求，这种转发，本质上是服务器应用内部的方法调用；<br>（3）<strong>包含请求</strong>：<code>RequestDispatcher.include()</code>或<code>&lt;jsp:include&gt;</code>，注意这种是包含输出和<code>&lt;%@ inlcude %&gt;</code>静态导入的区别；<br>（4）<strong>错误资源请求</strong>：发生异常，请求错误页面；<br>（5）<strong>异步请求</strong>：如果要结合异步处理的Servlet使用，Filter同样也要开启支持异步处理。这里异步请求指的是有<code>AsyncContext</code>派发的请求，实现异步过滤器要注意可能被单个异步请求调用多次（潜在的多个不同线程）；</p>
<p>在部署描述符中，通过<code>&lt;dispatcher&gt;</code>元素中可以选择Filter支持的请求类型。</p>
<h2 id="6-4_Filter的配置">6.4 Filter的配置</h2><p><strong>初始化参数的设置</strong>；<br>同样Filter也可以通过<strong>编程</strong>，<strong>注解</strong>和<strong>XML</strong>三种方式配置；</p>
<blockquote>
<p>到Serlvet 3.1，注解配置Filter不能保证设置顺序。</p>
</blockquote>
<p><strong>Filter的顺序</strong>：<br>（1）基本顺序：<br><strong>首先</strong>，<code>&lt;url-pattern&gt;</code>匹配，按照Filter在部署描述符中<strong>出现的顺序</strong>匹配过滤器映射；<br><strong>其次</strong>再按照<code>&lt;serlvet-name&gt;</code>出现的顺序匹配；<br>（2）编程设置Filter顺序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registration.addMappingForUrlPatterns(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="string">"/foo"</span>, <span class="string">"bar/*"</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二个参数表示<strong>是否在部署描述符之后的Filter之后</strong>；</p>
<h2 id="6-5_Servlet，Filter和UnavailableException">6.5 Servlet，Filter和UnavailableException</h2><p><code>UnavailableException</code>表示Servlet或Filter不可用，这种情况一般Servlet容器负责处理，重试或者返回响应；<br>UnavailableException的分为两种：<br>（1）<strong>永久不可用</strong>：比如servlet配置不正确或者Filter状态异常。<br>（2）<strong>暂时不可用</strong>：可能由于一些system-wide的问题导致请求无法处理，比如第三方服务不可用，内存和磁盘不足等等；可以在稍后重试；</p>
<h1 id="7-_Servlet及其容器的工作原理（Tomcat_8-0为例）">7. Servlet及其容器的工作原理（Tomcat 8.0为例）</h1><p>Tomcat分为4层结构：Container容器-&gt;Engine容器-&gt;Host容器-&gt;Servlet容器；</p>
<p>一个请求，根据它的URL，Tomcat将根据它的Host，Context一层层将其转发到合适的Servlet（对于很多MVC是映射到一个Servlet，在根据之后的pathinfo解析分派到对应的处理函数）。</p>
<p>一个Context对应一个Web工程：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Context</span> <span class="attribute">path</span>=<span class="value">"/projectOne"</span> <span class="attribute">docBase</span>=<span class="value">"/home/xxx/xxx"</span> <span class="attribute">reloadable</span>=<span class="value">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="7-1_Servlet容器的启动">7.1 Servlet容器的启动</h2><p>这里的config也是通过<code>addWebApp</code>的重载版本中调用构造器创建的，传入该方法进行设置；contextPath和docBase分别对应Web应用的<strong>访问路径</strong>和<strong>物理路径</strong>。<br>（1）新增Web应用，设置访问路径，工作目录监听器，创建注入ContextConfig对象；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">addWebapp</span><span class="params">(Host host, String contextPath, String docBase, ContextConfig config)</span> </span>&#123;</span><br><span class="line">       silence(host, contextPath);</span><br><span class="line"></span><br><span class="line">       Context ctx = createContext(host, contextPath);</span><br><span class="line">       <span class="comment">//设置访问路径</span></span><br><span class="line">       ctx.setPath(contextPath);</span><br><span class="line">       <span class="comment">//设置物理工作目录 </span></span><br><span class="line">       ctx.setDocBase(docBase);</span><br><span class="line">       <span class="comment">//添加监听器</span></span><br><span class="line">       ctx.addLifecycleListener(<span class="keyword">new</span> DefaultWebXmlListener());</span><br><span class="line">       ctx.setConfigFile(getWebappConfigFile(docBase, contextPath));</span><br><span class="line">	<span class="comment">//ContextConfig也同样实现了监听接口</span></span><br><span class="line">       ctx.addLifecycleListener(config);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// prevent it from looking ( if it finds one - it'll have dup error )</span></span><br><span class="line">       config.setDefaultWebXml(noDefaultWebXmlPath());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将Servlet容器（Context）添加到Host下</span></span><br><span class="line">       <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">           getHost().addChild(ctx);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           host.addChild(ctx);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ctx;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）Tomcat启动<code>Tomcat.start()</code>：<br>Tomcat中启动中使用了观察者设计模式，所有容器实现了LifeCycle接口（也就是Observable），所有修改和状态变化由容器通知已注册的Observer（Listener）。</p>
<p>（3）Context容器初始化：<br>当Context容器初始化状态为init时，ContextConfig实现了LifeCycleListener接口，之前在<code>addWebApp()</code>已经将其注册到了Context中，这时会被调用。ContextConfig负责整个Web应用配置文件的<strong>解析工作</strong>，在<code>ContextConfig.init()</code>方法中（包括/conf目录下的context.xml，默认HOST配置文件/server.xml，Context自身的配置文件）。</p>
<p>（4）配置文件解析完成后调用<code>Context.startInternal</code>：这个方法十分重要，包含很多工作，之后要涉及的比如<strong>Web应用初始化</strong>，<strong>servlet的创建初始化</strong>（loadOnStartup的），<strong>Filter的创建和初始化</strong>等等都是这个方法子环节：</p>
<p>创建读取资源文件的对象；<br><strong>创建ClassLoader对象</strong>（WepAppClassLoader，加载Web应用目录lib下的jar包中的类，不同Web应用这里相互隔离）；<br>设置应用的工作目录‘；<br>启动相关的辅助类（logger，realm，resources等）；<br>修改启动状态，通知感兴趣的观察者；<br>子容器的初始化；<br>获取ServletContext并设置必要的参数；<br><strong>创建并初始化Filter</strong>；<br><strong>初始化LoadOnStartup的Servlet</strong>；</p>
<p>（5）Web应用初始化：<br>在上面说过<code>Context.startInternal</code>方法中会“修改启动状态，通知感兴趣的观察者”，查看该方法源码可以发现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个方法通知注册对于<code>CONFIGURE_START_EVENT</code>感兴趣的监听器，就包括<code>ContextConfig</code>，这时<code>ContextConfig</code>调用<code>configureStart</code>方法开始Web应用的初始化工作，主要的工作就是web.xml文件的解析（包括全局的web.xml，应用自己的web.xml，jar包中META-INF/web-fragment.xml，注解的读取，解析，合并）。</p>
<p>这些web.xml部署描述符和注解是依据Serlvet规范的，WebXml对象将它们抽象组装成StandardWapper，Tomcat容器内部的表示方法，而不是直接强耦合于Serlvet规范。</p>
<p>这个过程将我们熟悉的Serlvet，Filter，Multipart配置抽象包装成StandardWrapper对象，作为子容器添加到Context中，Context容器是真正运行Servlet的Servlet容器，一个Web应用一个Context容器。</p>
<h2 id="7-2_创建Servlet实例">7.2 创建Servlet实例</h2><p>这个工作是在<code>Context.startInternal()</code>中开始的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loadOnStartup(findChildren())) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.servletFail"</span>));</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>StandardContext.loadOnStartup</code>对loadOnstartup值大于等于0的StandardWrapper调用其<code>load</code>方法，开始创建和初始化Servlet对象。</p>
<p>/conf/web.xml全局的部署描述符中定义两个Servlet：<br><code>org.apache.catalina.servlets.DefaultServlet</code>和<code>org.apache.jasper.servlet.JspServlet</code>（loadOnStartup分别是1和3）；根据/conf/web.xml总的定义我们可以知道它们分别是处理静态资源和jsp文件请求的Servlet。</p>
<h3 id="7-2-1_创建Servlet对象：Servlet创建中的单例模式（synchronized+反射创建）">7.2.1 创建Servlet对象：Servlet创建中的单例模式（synchronized+反射创建）</h3><p>之前在介绍Servlet规范时，我们提及了Servlet是单例的，这里就看看Tomcat是怎样支持这一规范要求的。</p>
<p>首先，根据前面的知识，已经知道我们在部署描述符中定义的每个Servlet会被解析组装成对应一个StandardWrapper对象，也正是这个对象负责创建Servlet；创建就在<code>StandardWrapper.loadServlet</code>方法中，下面来看看这个方法的一些关键步骤：</p>
<p>（1）基于synchronized同步控制，保证create-if-not的原子性/内存可见性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Servlet <span class="title">loadServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br></pre></td></tr></table></figure></p>
<p>这里到没有DCL，静态内部类，枚举等丰富多彩的单例模式实现方法，其中也没有什么比较特别耗时的操作；但是这也说明了Serlvet使用LoadOnStartup可以避免在Web应用运行的时候因为创建Servlet的一些同步开销。</p>
<p>（2）如果单例已存在，直接返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nothing to do if we already have an 			instance or an instance pool</span></span><br><span class="line">        <span class="keyword">if</span> (!singleThreadModel &amp;&amp; (instance != <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br></pre></td></tr></table></figure></p>
<p>singleThreadModel（以下简称STM）前面已经说过使用对象池来保证不会有两个线程使用同一个Servlet实例（但这不是一个好办法）。</p>
<p>（3）获取InstatnceManager实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();</span><br></pre></td></tr></table></figure></p>
<p>（4）InstanceManager通过反射创建servlet实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">             servlet = (Servlet) instanceManager.newInstance(servletClass);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">             <span class="comment">/* 略 */</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             <span class="comment">/* 略 */</span></span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）开始初始化Servlet，初始化完成后通知执行回调：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initServlet(servlet);</span><br><span class="line">fireContainerEvent(<span class="string">"load"</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-2_初始化Servlet">7.2.2 初始化Servlet</h3><p>在上面一小节的<code>StandardWrapper.loadServlet</code>的结尾开始进行Servlet的初始化工作（根据StandardWrapper的源码，<code>initServlet</code>方法一般会在loadServlet调用后，检查如果没有完成初始化就进行调用，因为loadServlet可能因为一些异常，比如UnavailableException等原因中途退出而没有完成初始化）。</p>
<p><code>initServlet</code>方法中有大量的回调事件通知：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">InstanceEvent</span><span class="class">.BEFORE_INIT_EVENT</span></span><br><span class="line"><span class="comment">/* servlet.init(facade)*/</span></span><br><span class="line"><span class="tag">InstanceEvent</span><span class="class">.AFTER_INIT_EVENT</span></span><br></pre></td></tr></table></figure></p>
<p>（1）基于synchronized关键字的同步控制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initServlet</span><span class="params">(Servlet servlet)</span></span><br><span class="line">           <span class="keyword">throws</span> ServletException</span></span><br></pre></td></tr></table></figure></p>
<p>（2）如果已经初始化过了或者不是STM模式直接返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instanceInitialized &amp;&amp; !singleThreadModel) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></p>
<p>（3）将StandardWrapper包装成<code>StandardWrapperFacade</code>作为ServletConfig传给Servlet，调用<code>Servlet.init(facade)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">             <span class="comment">/* 略：SecurityUtil.doAsPrivilege方法调用 */</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             servlet.init(facade);</span><br><span class="line">         &#125;</span><br><span class="line">         instanceInitialized = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>（4）<code>GenericServlet</code>（HttpServlet，JspServlet基类）的<code>init</code>注入保存了ServletConfig对象。<br>如果Servlet是<code>JspServlet</code>，需要编译这个JSP文件为类，并初始化这个类。</p>
<h2 id="7-3_Serlvet核心结构和门面设计模式">7.3 Serlvet核心结构和门面设计模式</h2><p>Servet直接相关的几个类：ServletConfig，ServletReuqest，ServletResponse。</p>
<p>Tomcat容器中使用内部的表示方法，通过门面设计模式将Facade对象传递给Servlet：<br><img src="http://blog.zerohuan.com/images/tomcat-servlet-structure.png" alt="Tomcat-Servlet体系结构"><br>从这个类图中，我们可以看到ServletConfig和ServletContext与Servlet的关系，以及Tomcat对它们的实现：<br>（1）一个ServletContext对应多个Servlet，Tomcat中的实现类型是ApplicationContext，ApplicationContextFacade是它的门面类；<br>（2）一个ServletConfig对应一个Servlet，Tomcat中的实现类型是StandardWrapper，StandardWrapperFacade是其门面类；<br>（3）ServletConfig是Servlet配置集合，ServletContext是容器内所有Servlet的“交易环境”；<br>（4）Servlet桶构<code>init</code>方法获取ServletConfig（实际上是StandardWrapperFacade对象）；<br>（5）ApplicationContext和StandardWrapper都是在StandardContext中创建的。</p>
<p><strong>Request</strong>和<strong>Response</strong>：<br><img src="http://blog.zerohuan.com/images/tomcat-request-response.png" alt="Tomcat-Request-Response体系结构"><br>Tomcat同样使用<strong>内部表示</strong>&lt;—&gt;<strong>门面类</strong>&lt;—&gt;传入Servlet；</p>
<p>（1）Tomcat接收到请求后创建<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Resposne</code>，这两个类是轻量级的类，对象很小；这是有Tomcat内部工作线程创建的；<br>（2）将<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Resposne</code>传递给用户线程，创建<code>org.apache.catalina.connector.Request</code>和<code>org.apache.catalina.connector.Resposne</code>，这两个对象一直整个Servlet容器直到要传给Servlet；<br>（3）创建门面类<code>RequestFacade</code>和<code>ResponseFacade</code>给Servlet；</p>
<h2 id="7-3_请求和映射/分派">7.3 请求和映射/分派</h2><p>Tomcat8通过<code>org.apache.catalina.mapper</code>（和Tomcat7位置有差别）保存容器中所有子容器的信息，在<code>org.apache.catalina.connector.Request</code>进入Container容器前，Mapper会根据这次请求的hostname和contextPath将host和context容器设置到Request的<code>mappingData</code>属性中。</p>
<p>这里同样使用观察者模式，<code>MappingListener</code>注册到Engine，Host各级容器上，容器状态发生变化就通知它变化更新到Mapper中。</p>
<p>根据Mapper可以确定将请求分派到哪个Host和哪个Servlet容器上以及哪个Servlet上，在传到Servlet前，通过Filter链并在这个过程中调用可能的Listener，最终执行Servlet的service方法。<br><img src="http://blog.zerohuan.com/images/tomcat-mapper.png" alt="Tomcat-Mapper结构"></p>
<h2 id="7-4_Listener的体系结构和创建">7.4 Listener的体系结构和创建</h2><p>Servlet规范中定义了很多监听器，基于观察者模式将主要流程的控制/管理和事件的响应处理分离。主要分为两类：<br>（1）<strong>LifeCycleListener</strong>：ServletContextListener，HttpSessionListener；监听目标对象的创建和销毁事件；<br>（2）<strong>EventListener</strong>：ServletContextAttributeListener，ServletRequestAttributeListener，ServletRequestListener，HttpSessionAttributeListener等等；</p>
<p>PS：ServletContextListeer在容器启动之后不能在添加新的，因为容器启动这个事件不会再次发生；我们可以在ServletContainerInitializer中创建配置它。</p>
<h3 id="Listener的创建">Listener的创建</h3><p>再次回到<code>StandardContext.startInternal</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!listenerStart()) &#123;</span><br><span class="line">          log.error(sm.getString(<span class="string">"standardContext.listenerFail"</span>));</span><br><span class="line">          ok = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的关键还是<code>listenerStart方法</code>，该方法在<code>StandardContext.filterStart</code>之前，我们来看一看这个方法的关键步骤：<br>（1）反射创建所有Listener：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiate the required listeners</span></span><br><span class="line">String listeners[] = findApplicationListeners();</span><br><span class="line">Object results[] = <span class="keyword">new</span> Object[listeners.length];</span><br><span class="line"><span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">	<span class="comment">/* 略 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String listener = listeners[i];</span><br><span class="line">        results[i] = getInstanceManager().newInstance(listener);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">/* 略 */</span></span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）将监听器整理为eventListeners和lifecycleListeners两类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort listeners in two arrays</span></span><br><span class="line">ArrayList&lt;Object&gt; eventListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Object&gt; lifecycleListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((results[i] <span class="keyword">instanceof</span> ServletContextAttributeListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> ServletRequestAttributeListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> ServletRequestListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> HttpSessionIdListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> HttpSessionAttributeListener)) &#123;</span><br><span class="line">        eventListeners.add(results[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((results[i] <span class="keyword">instanceof</span> ServletContextListener)</span><br><span class="line">        || (results[i] <span class="keyword">instanceof</span> HttpSessionListener)) &#123;</span><br><span class="line">        lifecycleListeners.add(results[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）将Intializers或其他通过编程方式添加的监听添加到位：<br>这里就不一定是反射创建的了，在<code>ServletContainerInitializer.onStratup</code>中我们可以通过构造器来创建指定的listener；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listener instances may have been added directly to this Context by</span></span><br><span class="line">        <span class="comment">// ServletContextInitializers and other code via the pluggability APIs.</span></span><br><span class="line">        <span class="comment">// Put them these listeners after the ones defined in web.xml and/or</span></span><br><span class="line">        <span class="comment">// annotations then overwrite the list of instances with the new, full</span></span><br><span class="line">        <span class="comment">// list.</span></span><br><span class="line">        <span class="keyword">for</span> (Object eventListener: getApplicationEventListeners()) &#123;</span><br><span class="line">            eventListeners.add(eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">        setApplicationEventListeners(eventListeners.toArray());</span><br><span class="line">        <span class="keyword">for</span> (Object lifecycleListener: getApplicationLifecycleListeners()) &#123;</span><br><span class="line">            lifecycleListeners.add(lifecycleListener);</span><br><span class="line">            <span class="keyword">if</span> (lifecycleListener <span class="keyword">instanceof</span> ServletContextListener) &#123;</span><br><span class="line">                noPluggabilityListeners.add(lifecycleListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setApplicationLifecycleListeners(lifecycleListeners.toArray());</span><br></pre></td></tr></table></figure></p>
<p>（4）调用ServletContextListener的<code>contextInitialized</code>；</p>
<h2 id="7-5_Filter的创建，初始化和使用">7.5 Filter的创建，初始化和使用</h2><h3 id="Filter的创建">Filter的创建</h3><p>回到<code>StandardContext.startInternal</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure and call application filters</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!filterStart()) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.filterFail"</span>));</span><br><span class="line">              ok = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>StandardContext.filterStart</code>中将根据配置创建所有的<code>ApplicationFilterConfig</code>以及根据FilterClass反射创建爱Filter实例，实际上还是通过（<strong>synchronized</strong>+反射创建保证<strong>单例</strong>），该方法在<code>StandardContext.loadOnStartup</code>之前调用。</p>
<h3 id="Filter链的结构和调用过程">Filter链的结构和调用过程</h3><p>上面我们根据Servlet规范介绍了Filter的基本情况。这里结合Tomcat 8具体介绍下Filter的创建，初始和相关细节。<br><img src="http://blog.zerohuan.com/images/tomcat-filter.png" alt="Tomcat-Filter结构"></p>
<p>Tomcat容器主要通过<code>ApplicationFilterChain</code>管理和执行过滤器链。它通过一个数组保存所有Filter的FilterConfig对象，在Tomcat中是<code>ApplicationFilterConfig</code>（每个FilterConfig包含一个Filter引用）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationFilterConfig[] filters =</span><br><span class="line">       <span class="keyword">new</span> ApplicationFilterConfig[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<p>该数组是一个大小动态增长的数组（每次增长10）。处理请求时通过<code>ApplicationFilterChain.doFilter</code>该方法会调用数组中每个<code>Filter.doFilter</code>。</p>
<h2 id="7-6_Initializer，Listener，Filter，Servlet的创建/初始化，销毁顺序">7.6 Initializer，Listener，Filter，Servlet的创建/初始化，销毁顺序</h2><p>Listener，Filter，Servlet的创建和初始化上面已经结合Tomcat 8的实现进行了总结说明。它们都是在<code>StandardContext.startInternal</code>这一生命周期方法中进行的。加上Initializer顺序依次是：<br>Initaializer—&gt;Listener—&gt;Filter—&gt;Servlet（loadOnstart）；</p>
<p>因为前面没有提及Intializer的相关知识，我们在这里介绍下：<br>ServletContainInitalizer是Java EE 6中Servlet 3.0的新增接口；它的<code>onStartup</code>方法是一个web应用中我们的代码可以控制到的最早时间点。</p>
<p>它不需要通过web.xml部署描述符来定义，需要在/META-INF/services/javax.servlet.ServletContainerInitializer中列出具体的实现，Servlet容器在启动时会自动扫描加载它们并调用onStartUp方法。但是文件不能放在WAR文件的/META-INF/services中，而是需要放在JAR文件的/META-INF/services中，这样就很不方便。如果你使用Spring的话，Spring Framework提供了一个桥接口，在Spring中SpringServletContainerInitializer类实现了ServletContainerInitializer接口，Spring的JAR中列出了SpringServletContainerInitializer，如下。在SpringServletContainerInitializer中会扫描所有WebApplicationInitializer的实现，调用它们的onStartUp方法，因此我们不必在劳神费心了。</p>
<h3 id="Initializer的调用">Initializer的调用</h3><p><code>StandardContext.startInternal</code>中在lislistener，filter，servlet（loadOnStartup）之前对所有的ServletContainerInitializers进行调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call ServletContainerInitializers</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">    initializers.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                getServletContext());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.sciFail"</span>), e);</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，我们可以看到，根据规范结合实现，Initializer中可以配置servlets，filters和listeners；在ServletContextListener可以配置其他的listener（因此<code>listenerStart</code>中分了两步加载），filters和servlets；而Filter链在Servlet之前调用。因此我们能看到这样一个顺序：<br>Initaializer—&gt;Listener—&gt;Filter—&gt;Servlet（loadOnstart）；</p>
<h3 id="销毁顺序">销毁顺序</h3><p>和C++构造&amp;析构等等这类东西很相似，它们的销毁顺序和加载/初始化顺序是相反的。</p>
<p>结合Servlet规范中一些定义，我们也能看到上述初始化和销毁顺序，这也是必须要理解明白的重要知识点。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/15/数据结构的理解和应用——红黑树/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          数据结构的理解和应用——红黑树
        
      </div>
    </a>
  
  
    <a href="/2015/12/12/Java 8集合框架源码学习——HashMap/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java 8集合框架源码学习——HashMap</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Servlet深入学习，规范，理解和实现（上）" data-title="Servlet深入学习，规范，理解和实现（上）" data-url="http://blog.zerohuan.com/2015/12/12/Servlet深入学习，规范，理解和实现（上）/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Zerohuan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>